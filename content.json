[{"title":"javascript立即执行函数(IIFE)","date":"2017-09-11T13:46:54.000Z","path":"2017/09/11/javascript立即执行函数-IIFE/","text":"通常我们声明一个函数有以下几种方式：12345678910111213141516171819202122// 声明函数f1function f1() &#123; console.log(\"f1\");&#125;// 通过()来调用此函数f1();//一个匿名函数的函数表达式，被赋值给变量f2:var f2 = function() &#123; console.log(\"f2\");&#125;//通过()来调用此函数f2();//一个命名为f3的函数的函数表达式(这里的函数名可以随意命名，可以不必和变量f3重名)，被赋值给变量f3:var f3 = function f3() &#123; console.log(\"f3\");&#125;//通过()来调用此函数f3(); 如果你看过一些自定义控件的话你会发现他们大多数都是沿用这种写法： 1234(function() &#123; ... // 这里开始写功能需求 &#125;)(); 这是我们常说的立即执行函数(IIFE)，顾名思义，也就是说这个函数是立即执行函数体的，不需要你额外去主动的去调用，一般情况下我们只对匿名函数使用IIFE，这么做有两个目的： 一是不必为函数命名，避免了污染全局变量二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 如果看到这两句话无法理解，那么先从IIFE的运行原理说起。因为IIFE通常用于匿名函数，这里就用简单的匿名函数作为栗子： 1234var f = function()&#123; console.log(\"f\");&#125;f(); 我们发现这里f只是这个匿名函数的一个引用变量，那么既然f()能够调用这个函数，我把f替换成函数本身可以么： 123function()&#123; console.log(\"f\"); &#125;(); 运行之后得到如下结果： 1Uncaught SyntaxError: Unexpected token ( 产生这个错误的原因是，Javascript引擎看到function关键字之后，认为后面跟的是函数声明语句，不应该以圆括号结尾。解决方法就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算，这里区分一下函数声明和函数表达式： 12345671、函数声明(即我们通常使用function x()&#123;&#125;来声明一个函数)function myFunction () &#123; /* logic here */ &#125;2、函数表达式(类似以这种的形式)var myFunction = function () &#123; /* logic here */ &#125;;var myObj = &#123; myFunction: function () &#123; /* logic here */ &#125;&#125;; 小学我们就学过用()括起来的表达式会先执行，就像下面这样： 11+(2+3) //这里先运行小括号里面的内容没有意见撒 其实在javascript中小括号也有相似的作用，Javascript引擎看到function关键字会认为是函数声明语句，那么如果Javascript引擎优先看到小括号会怎么样： 1234//用小括号把函数包裹起来(function()&#123; console.log(\"f\"); &#125;)(); 函数成功执行了： 1f //控制台输出 这种情况下Javascript引擎就会认为这是一个表达式，而不是函数声明，当然要让Javascript引擎认为这是一个表达式的方法还有很多： 1234567!function()&#123;&#125;();+function()&#123;&#125;();-function()&#123;&#125;();~function()&#123;&#125;();new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // 只有传递参数时，才需要最后那个圆括号。... 回到前面的问题，为什么说IIFE这种形式避免了污染全局变量，如果你见过别人写的jquery插件，里面通常会有类似这样的代码： 1234(function($)&#123; ... //插件实现代码&#125;)(jQuery); 这里的jquery其实是该匿名函数的参数，联想一下我们调用匿名函数时候是用f()那么匿名带参数的就是f(args)对吧，这里把jquery作为参数传入该函数，那么在函数内部使用形参$的时候就不会影响到外部环境，因为有些插件也会用到$这个限定符，你在这个函数内部可以随意折腾。 以上，在此过程中参考了以下两篇文章：javascript立即执行某个函数：插件中function(){}()再思考JavaScript中的立即执行函数","tags":[{"name":"IIFE","slug":"IIFE","permalink":"https:///www.limuyang.cc/tags/IIFE/"},{"name":"javascript","slug":"javascript","permalink":"https:///www.limuyang.cc/tags/javascript/"}]},{"title":"告别五月","date":"2017-06-01T14:06:01.000Z","path":"2017/06/01/告别五月/","text":"2017年6月1号转眼就跑到那似水流年里去了，然而身边的人都不珍视自己的似水流年我要告别5月 诉一整个5月是我成长最快的日子我心里很乱，当我沿着这条路走下去的时候心里总想着另一条路上的事好像王小波在《黄金时代》中描述到的：”那一年我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。” 别在2017-06-01这个节点我把多说换成了搜狐畅言让我和你告个别开源不易，且行且珍惜 离我只愿蓬勃的生活在此时此刻成为一名真正意义上的移动WEB前端开发工程师“移动”两字是我刻意加上去的，很好的显露出我没有如愿成为一名移动开发工程师的不忿最后，我发现我真的胖了。","tags":[{"name":"告别","slug":"告别","permalink":"https:///www.limuyang.cc/tags/告别/"}]},{"title":"自始至终","date":"2017-02-17T14:25:29.000Z","path":"2017/02/17/自始至终/","text":"长安有男儿，二十心已朽我已经快忘了来这座城市的初衷 我总是没有勇气把生活过的波澜壮阔 2016-6-26，我终于离开了生活和学习了四年的城市，这个城市含着与我记忆无关的繁华，就这么走了也没捎上一句不咸不淡的问候 人最可悲的心甘情愿用不知道多少个日夜的交替去执着自己不该执着的事物,然而早已白露不是惊蛰，世间也不存在那壶让人醉生梦死的酒我只知道这个城市有我无法割舍的记忆和无法忘却的故人… “如果我有孤独和酒，你跟不跟我走”伪文艺总是打着孤独的帆在人海浪尖处踮着脚尖儿跳舞。 船到尽头方知那些粗布麻衣闲茶淡酒垂钓岸边的人，才是真性情。 2017年元旦去了一趟东极之东，那里晚霞中的风车阵太美,傍晚的暮霭渐渐化成粉色的温柔…其实东极还有另一种宁静，那是大家启程返航的时候，我们懈怠了一点，于是看到的也多一点，那时候的东极才是真正的东极… 你很难找到跟你性情相通的人，你发现你只是一个存在， 又或者在别人眼里根本就看不见你。 如果你找到我，那么，你能否为我，作片刻的停留？","tags":[{"name":"自始至终","slug":"自始至终","permalink":"https:///www.limuyang.cc/tags/自始至终/"}]},{"title":"Handler机制从入门到放弃(二)","date":"2016-10-29T14:48:19.000Z","path":"2016/10/29/Handler机制从入门到放弃-二/","text":"从注释看起Hander的源码只有不到800行，而且大多数代码相对来说还是比较好理解的，尤其是相对于其他更加接近底层的代码来说，在看源码时候有一点挺重要的就是不要忽略注释的作用，Handler类开头有这么几行注释： 123&lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own. 归纳一下就是：- 安排消息和任务在将来的某一个点执行- 使一个动作进入队列为了能够在另一个线程中执行回顾一下我们为什么要用Handler：&gt; 在Android中，当要更新UI的时候，我们必须要在主线程中进行更新，原因时当主线程被阻塞了5s以上就会出现ANR异常，会导致程序崩溃。所以一些耗时的操作必须要放在子线程中，但是在子线程中又不能做更新UI的操作，所以为了解决这个问题，Android设计了handler机制。这么一对比，很容易的印证了这段话：使一个动作进入队列在另一个线程中执行：这不就是异步执行耗时任务么；安排消息和任务在将来的某一个点执行：联想一下postDelayed之类的延时操作的方法，或者给出一个很常见的例子，比如说引导页延时启动：12345678910111213141516171819new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; Log.d(\"ThreadName 1\",Thread.currentThread().getName()); //第一次登陆扫描本地音乐 if (SPUtils.getValue(SplashActivity.this, \"isFirst\", \"First\", true)) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //耗时操作 //清空表 Log.d(\"ThreadName 2\",Thread.currentThread().getName()); DataSupport.deleteAll(MusicInfoDetail.class); MusicUtils.scanMusic(SplashActivity.this, musicInfo); DataSupport.saveAll(musicInfo); SPUtils.putValue(SplashActivity.this, \"isFirst\", \"First\", false); &#125; &#125;).start(); &#125;, 2000); 这里是我自己的Demo里面的一部分代码，这里使用postDelayed延时2s启动，然后在子线程执行更新数据库的操作，很好的印证了上面两点。 创建Handler在上一篇文章Handler机制从入门到放弃(一)里面我们已经演示了两种创建Handler的方法并且给出了部分实际操作的代码，但是都是在主线程也就是UI线程创建的，我们可以尝试一下在子线程中创建Handler： 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; private Handler mainHandler; private Handler childHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainHandler=new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; childHandler=new Handler(); &#125; &#125;).start(); &#125;&#125; 运行一下，果不其然代码蹦了： 报错信息： 1java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare() 告诉我们说在Thread里面创建Handler需要调用Looper.prepare( )，那把这一句加上试试： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private Handler mainHandler; private Handler childHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainHandler=new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); childHandler=new Handler(); &#125; &#125;).start(); &#125;&#125; 果然很成功的运行了，但是这是为什么，来看一下Handler的源码： 这里提供一个简便的方法，为了快速找到原因可以在打开的源码(我这里使用sublimeText查看)里使用ctrl+f快捷键搜索Looper.prepare( )出现的地方： 123456789101112131415161718public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 这是Handler的其中一个构造方法，看到这么一段： 12345mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; 在构造方法里通过Looper.myLooper()获取到一个Looper对象mLooper，如果为空则报错，找到Looper.myLooper()方法： 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 注释给出的解释是这个方法回返回跟当前线程相关联的Looper对象，如果没有则返回空，还是没找到答案，接着找Looper类里面对sThreadLocal的定义： 12// sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 又是注释里面告诉了我们重要信息，这里告诉我们只有你调用了Looper.prepare()方法sThreadLocal.get()才不会返回空，那么说来说去还是要看Looper.prepare()的代码： 12345678910111213141516/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 看下面那个，Looper.prepare()调用了prepare()的重载方法prepare(boolean quitAllowed)并且传入了true参数，这个方法判断sThreadLocal.get()是否会返回一个Looper对象，如果没有的话就set一个新的Looper进去，如果已经有了再调用prepare()方法的话就会报错，不信邪的可以在mainHandler创建之前也调用一个Looper.prepare()，控制台就会出现这个错误： 那么问题来了，为什么我们在主线程创建Handler不需要调用Looper.prepare()，而在子线程中需要呢，可以合理的猜想是不是系统给我们主动调用了，毕竟我们大部分的操作还是在主线程上，每次都要那么Looper.prepare()来一次多麻烦，有了猜想还要去源码寻求验证，主线程是ActivityThread，从ActivityThread类里搜索相关信息，用跟上面一样的方法： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 抓重点： 1Looper.prepareMainLooper(); 找到Looper类中关于这个方法的定义： 123456789101112131415/** * Initialize the current thread as a looper, marking it as an * application&apos;s main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125; 这里又会主动调用prepare(boolean quitAllowed)方法，通过注释也了解到我们不需要主动去创建UI线程的looper，系统自动会给我们创建好了，这里印证了前面的猜想。 这里得出一个结论： 在主线程中可以直接创建Handler对象，而在子线程中需要先调用Looper.prepare()才能创建Handler对象。 这里先不管Looper是什么，暂时知道有这个东西，下面可以看一下如何发送消息。 如何发送消息这里就用到了第二种创建Handler的方法： 1234567891011Handler myHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //根据参数进行操作 break; &#125; super.handleMessage(msg); &#125; &#125;; //其他地方调用myHandler.sendMessage(xxx); 这里的其他地方调用指的就是在子线程里面，当我们在子线程里面执行完耗时操作之后如果需要传递一些数据给主线程，比如通知主线程更新UI之类的，就可以这么做： 12345678910111213141516171819202122final Handler myHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //根据参数进行操作 &#125; &#125; &#125;; new Thread(new Runnable() &#123; @Override public void run() &#123; Message msg=new Message(); //what是用户自定义的识别码 msg.what=1; //通过arg1和arg2可以给Message传递简单的int型数据 msg.arg1=123; msg.arg2=456; //通过给obj赋值Object类型传递向Message传入任意数据 msg.obj=null; myHandler.sendMessage(msg); &#125; &#125;).start(); 当然除了传递这些简单数据之外Message类还能以setData方式携带Bundle数据： 123Bundle bundle = new Bundle(); bundle.putString(\"data\", \"data\"); message.setData(bundle); 我们看到这里是在子线程中调用了sendMessage(msg)方法，然而我们却在主线程中使用handleMessage(Message msg)接受消息，这之间一定发生了一些不可描述的事情，让我们来找找看，当然除了sendMessage(msg)方法Message类还有许多其他发送消息的方法： 1234567891011121314151617181920212223public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0); &#125; public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis); &#125; public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis); &#125; ..... 巧的是，这些方法无论转折多少次都走向了同一个方法： 1234567891011121314151617181920212223242526272829/** * Enqueue a message into the message queue after all pending messages * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;. * &lt;b&gt;The time-base is &#123;@link android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt; * Time spent in deep sleep will add an additional delay to execution. * You will receive it in &#123;@link #handleMessage&#125;, in the thread attached * to this handler. * * @param uptimeMillis The absolute time at which the message should be * delivered, using the * &#123;@link android.os.SystemClock#uptimeMillis&#125; time-base. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. */ public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; 这个方法接受两个参数，msg和uptimeMillis，msg就是我们需要传递的消息，uptimeMillis则是发送消息时候的绝对时刻，它的值等于自系统开机到当前时间的毫秒数再加上延迟时间，这个延迟时间就是我们调用sendxxxDelayed里面传入的时间参数，这个方法会把一个消息放入消息队列(message queue)，然后把这个方法的两个参数加上新建的MessageQueue 对象传入enqueueMessage(queue, msg, uptimeMillis)方法里，从字面上理解MessageQueue 是一个消息队列，那么队列就会有入队和出队的方法，这个enqueueMessage(queue, msg, uptimeMillis)应该就是入队的方法： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 没有发现什么，这里又调用了enqueueMessage(msg, uptimeMillis)方法，这个方法在MessageQueue类里面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 代码有点长，一步一步看，先看前面一部分： 123456if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; 这里判断了一下msg.target对象是否为空，还记得之前的enqueueMessage(queue, msg, uptimeMillis)方法吗： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 这个方法是在Handler中执行的，这里把一个this对象赋值给msg.target，那么从Message类找一下这个target到底是什么，找到这个： 1/*package*/ Handler target; 这样脉络就很清晰了，这里是把Handler跟Message对象绑定起来，接着往下看： 12345678910111213141516171819202122232425262728293031323334msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; 这个msg.when就是用传入的uptimeMillis参数赋值，表示入队时间，看到这个if判断： 12345678if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; ... &#125; 有人可能会好奇这个when怎么会为0呢，这里提一嘴，Handler除了有正常的sendMessage之流的方法还有一个比较特殊的方法： 12345678910public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0); &#125; 这个方法特殊在什么地方呢，打个比方，如果说我们正常的sendMessage之流的方法是一群正常排队的人，按照来的时间先后有序排队，但是sendMessageAtFrontOfQueue就是那种个别不老实的，它能直接插队到最前面，然后他传递的uptimeMillis为0，这也是唯一一个特殊的发送消息的方法。 这个判断语句成立的条件有三点：p == null || when == 0 || when &lt; p.when p == null说明当前looper处于空闲状态，也就是没有什么消息需要处理 when == 0说明有消息插队插到了MessageQueue最前面 when &lt; p.when指的是新入队的消息队列需要排队的时间比正在执行的消息排队的时间短 综合来说就是，如果这时候新进来一个消息，这时候消息队列里面没有需要执行的消息，或者新进来的这个消息是通过sendMessageAtFrontOfQueue(Message msg)方法传进来的，或者说新进来的这个消息需要等待的时间比之前在等待的消息等待的时间短，那么就把这个消息插入链表的表头，此时系统会唤醒这个消息队列无论队列是否堵塞。 12// Got a message. mBlocked = false; 这一行代码说明只要消息队列有消息，这个队列就不阻塞，然后把这个布尔值传递： 12boolean needWakeneedWake = mBlocked; 那么这一块代码就打通了，下面这块else语句块： 12345678910111213141516171819else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; 讲的是如何把消息插入链表的内部，这时候就不需要去调整唤醒消息队列的时间，因为唤醒的时间是跟表头有关的，这样整个入队的操作差不多就过了一遍. 出队操作既然有入队操作那么肯定也有出队操作，如果你还记得我们最开始使用的Looper类的话，那么这里不妨直接告诉你，出队的方法就在Looper类里面，这里有个loop()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); //死循环 for (;;) &#123; //把消息从队列取出 Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 注意这两段代码： 12final Looper me = myLooper();final MessageQueue queue = me.mQueue; 之前说过一个线程必须有一个Looper，这里不仅获取到了Looper，还获取到了当前线程绑定的MessageQueue也就是消息队列，然后loop()方法最开始是判断当前线程是否有Looper对象，之后进入一个死循环，在循环体内不断的从消息队列(Message queue)中取出消息对象，为什么这么说，看这个next()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Message next()&#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; . . . . . . nativePollOnce(mPtr, nextPollTimeoutMillis); // 阻塞于此 . . . . . . // 获取next消息，如能得到就返回之。 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; // 先尝试拿消息队列里当前第一个消息 if (msg != null &amp;&amp; msg.target == null) &#123; // 如果从队列里拿到的msg是个“同步分割栏”，那么就寻找其后第一个“异步消息” do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; // 重新设置一下消息队列的头部 &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); msg.markInUse(); return msg; // 返回得到的消息对象 &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; . . . . . . // 处理idle handlers部分 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; &#125;&#125; 注释已经很详细了，现在知道了哪里把消息取出来，但是还不知道消息是哪里处理的，接着上面的loop()方法的代码往下看： 1msg.target.dispatchMessage(msg); 这一行很关键，字面意思都可以看出来这里是分发消息，找到源码查看一下，之前说过msg.target就是与Message绑定的Handler，所以在Handler的源码里面找： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 代码很简单，但是答案就快揭晓了，Handler通过post和sendMessage之类的方法把消息发出去，绕了一大圈又回到了Handler，先别激动，看看代码到底说了什么： 12if (msg.callback != null) &#123; handleCallback(msg); 这里的msg.callback其实就是一个Runnable对象，可以通过查看Message源码发现： 1234567891011121314/** * Same as &#123;@link #obtain(Handler)&#125;, but assigns a callback Runnable on * the Message that is returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @param callback Runnable that will execute when the message is handled. * @return A Message object from the global pool. */ public static Message obtain(Handler h, Runnable callback) &#123; Message m = obtain(); m.target = h; //创建Message类时候系统建议使用Message msg=Message.obtain()；形式 m.callback = callback; return m; &#125; 你想到了什么，在回想一遍我们使用Handler的两种方式，一种是post(Runnable r)的形式，一种是sendMessage(Message msg)形式，第一种方式刚好传递的就是一个Runnable对象，看一下这个handleCallback(msg)方法： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 简单粗暴，走的就是post(Runnable r) 所传递参数的 run()方法，那么第二种形式呢： 12345if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; 这个mCallback是Hanlder.Callback类对象，这个Callback是Handler的内部的一个接口： 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 这就对应了sendMessage(Message msg)的形式，到此，真相大白，这里还有一点要注意的是，ActivityThread也就是UI线程是自动调用了Looper.loop()方法的所以在主线程使用Handler是不需要再去调用了，但是在子线程中却是要自己调用的，否则不会进入MessageQueue，而且Handler不仅仅只有更新UI的作用，它是与所创建的线程所绑定的，所以可以使用它在主线程向子线程发送消息，反过来也一样，关于这点的使用详见 Android主线程.子线程通信（Thread+handler） 总结从最开始的使用到从源码的角度去分析，写这篇博客花了很长的时间，最后做个总结： 在整个Android内部通信进程中，Handler机制如果捋顺了相互之间的关系的话其实不难理解，下面上一张图帮助理解： 套用一段很形象的话解释这幅图： 我们可以把传送带上的货物看做是一个个的Message，而承载这些货物的传送带就是装载Message的消息队列MessageQueue。传送带是靠发送机滚轮带动起来转动的，我们可以把发送机滚轮看做是Looper，而发动机的转动是需要电源的，我们可以把电源看做是线程Thread，所有的消息循环的一切操作都是基于某个线程的。一切准备就绪，我们只需要按下电源开关发动机就会转动起来，这个开关就是Looper的loop方法，当我们按下开关的时候，我们就相当于执行了Looper的loop方法，此时Looper就会驱动着消息队列循环起来。 那Hanlder在传送带模型中相当于什么呢？我们可以将Handler看做是放入货物以及取走货物的管道：货物从一端顺着管道划入传送带，货物又从另一端顺着管道划出传送带。我们在传送带的一端放入货物的操作就相当于我们调用了Handler的sendMessageXXX、sendEmptyMessageXXX或postXXX方法，这就把Message对象放入到了消息队列MessageQueue中了。当货物从传送带的另一端顺着管道划出时，我们就相当于调用了Hanlder的dispatchMessage方法，在该方法中我们完成对Message的处理。 这段话出自 参考博客 深入源码解析Android中的Handler,Message,MessageQueue,Looper 从Handler+Message+Looper源码带你分析Android系统的消息处理机制 Android异步消息处理机制完全解析，带你从源码的角度彻底理解 聊一聊Android的消息机制","tags":[{"name":"Android","slug":"Android","permalink":"https:///www.limuyang.cc/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"https:///www.limuyang.cc/tags/Handler/"},{"name":"源码分析","slug":"源码分析","permalink":"https:///www.limuyang.cc/tags/源码分析/"}]},{"title":"Handler机制从入门到放弃(一)","date":"2016-10-29T14:41:23.000Z","path":"2016/10/29/Handler机制从入门到放弃-一/","text":"闲来无事，准备好好梳理一下Handler机制，之前分析过没有写成博客，结果就是慢慢的淡忘了，这次趁着刚分析完，赶紧写下来。 在开始分析之前先打打基础，理解理解什么是线程以及什么是Handler，这里大部分内容引用一篇来自伯乐在线的文章，因为看来看去关于基础的部分这个人已经说得很好了，我就负责把主要的部分抽取出来。 原文地址：Android线程和Handler基础入门 现在大多数的移动设备已经变得越来越快，但是它们其实也不算是非常快。如果你想让你的APP既可以承受一些繁杂的工作而又不影响用户体验的话，那么必须把任务并行执行。在Android上，我们使用线程。 什么是线程？线程或者线程执行本质上就是一串命令（也是程序代码），然后我们把它发送给操作系统执行。 一般来说，我们的CPU在任何时候一个核只能处理一个线程。多核处理器（目前大多数Android设备已经都是多核）顾名思义，就是可以同时处理多线程（通俗地讲就是可以同时处理多件事）。 多核处理与单核多任务处理的实质上面我说的是一般情况，并不是所有的描述都是一定正确的。因为单核也可以用多任务模拟出多线程。 每个运行在线程中的任务都可以分解成多条指令，而且这些指令不用同时执行。所以，单核设备可以首先切换到线程1去执行指令1A，然后切换到线程2去执行指令2A，接着返回到线程1再去执行1B、1C、1D，然后继续切换到线程2，执行2B、2C等等，以此类推。 这个线程之间的切换十分迅速，以至于在单核的设备中也会发生。几乎所有的线程都在相同的时间内进行任务处理。其实，这都是因为速度太快造成的假象，就像电影《黑客帝国》里的特工Brown一样，可以变幻出很多的头和手。 Java核心里的线程在Java中，如果要想做平行任务处理的话，会在Runnable里面执行你的代码。可以继承Thread类，或者实现Runnable接口： 1234567891011121314151617181920212223242526// 1public class IAmAThread extends Thread &#123; public IAmAThread() &#123; super(\"IAmAThread\"); &#125; @Override public void run() &#123;// your code (sequence of instructions) &#125;&#125;// to execute this sequence of instructions in a separate thread.new IAmAThread().start();// 2public class IAmARunnable implements Runnable &#123; @Override public void run() &#123;// your code (sequence of instructions) &#125;&#125;// to execute this sequence of instructions in a separate thread.IAmARunnable myRunnable = new IAmARunnable();new Thread(myRunnable).start(); 这两个方法基本上是一样的。第一个版本是创建一个Thread类，第二个版本是需要创建一个Runnable对象，然后也需要一个Thread类来调用它。 Android上的线程无论何时启动APP，所有的组件都会运行在一个单独的线程中（默认的）—-叫做主线程。这个线程主要用于处理UI的操作并为视图组件和小部件分发事件等，因此主线程也被称作UI线程(Main Thread)。除了Main Thread之外的线程都可称为Worker Thread。Main Thread主要负责控制UI页面的显示、更新、交互等。 因此所有在UI线程中的操作要求越短越好，只有这样用户才会觉得操作比较流畅。一个比较好的做法是把一些比较耗时的操作，例如网络请求、数据库操作、 复杂计算等逻辑都封装到单独的线程，这样就可以避免阻塞主线程，这样就需要用到了Android的Handler机制。 这里划重点：Handler负责与子线程进行通讯，从而让子线程与主线程之间建立起协作的桥梁，使Android的UI更新的问题得到完美的解决 怎么创建Handler既然Handler有这样的好处，那么看Handler怎么用，官方给出了两种方式创建一个Handler： 1、使用默认的构造方法：new Handler()。 2、使用带参的构造方法，参数是一个Runnable对象或者回调对象。 12345678910111213141516171819202122//第一种方法private Handler handler = new Handler(); private Runnable myRunnable= new Runnable() &#123; public void run() &#123; //一些耗时操作 &#125; &#125;; //其他地方调用 handler.post(xxx); 这里就写一个post方法，实际上还有很多，诸如postDelayed、postAtTime//第二种方法Handler myHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //根据参数进行操作 break; &#125; super.handleMessage(msg); &#125; &#125;; //其他地方调用myHandler.sendMessage(xxx); 如何使用Handler这里使用一个简单的Demo来演示Handler的用法，界面偏简单就不贴了，直接贴代码，模拟的是点击Button执行下载，下载完成后更新UI。 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends Activity implements Button.OnClickListener &#123; private TextView statusTextView = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); statusTextView = (TextView)findViewById(R.id.statusTextView); Button btnDownload = (Button)findViewById(R.id.btnDownload); btnDownload.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; DownloadThread downloadThread = new DownloadThread(); downloadThread.start(); &#125; class DownloadThread extends Thread&#123; @Override public void run() &#123; try&#123; System.out.println(\"开始下载文件\"); //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程 Thread.sleep(5000); System.out.println(\"文件下载完成\"); //文件下载完成后更新UI MainActivity.this.statusTextView.setText(\"文件下载完成\"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 按照以前写Java的思路的话可能会这么写，但是运行程序时候会发现控制台报错： 1android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 错误的意思是只有创建View的原始线程才能更新View。出现这样错误的原因是Android中的View不是线程安全的，下面给出合理的解释： 因为UI访问是没有加锁的，在多个线程中访问UI是不安全的，如果有多个子线程都去更新UI，会导致界面不断改变而混乱不堪。所以最好的解决办法就是只有一个线程有更新UI的权限，所以这个时候就只能有一个线程振臂高呼：放开那女孩，让我来！那么最合适的人选只能是主线程。 来自—Android中线程那些事 那么为了规避Android的这种机制，我们这里分别采用Handler的两种方式来实现上面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118A、使用post方式public class MainActivity extends Activity implements Button.OnClickListener &#123; private TextView statusTextView = null; //uiHandler在主线程中创建，所以自动绑定主线程 private Handler uiHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); statusTextView = (TextView)findViewById(R.id.statusTextView); Button btnDownload = (Button)findViewById(R.id.btnDownload); btnDownload.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; DownloadThread downloadThread = new DownloadThread(); downloadThread.start(); &#125; class DownloadThread extends Thread&#123; @Override public void run() &#123; try&#123; System.out.println(\"开始下载文件\"); //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程 Thread.sleep(5000); System.out.println(\"文件下载完成\"); //文件下载完成后更新UI Runnable runnable = new Runnable() &#123; @Override public void run() &#123; MainActivity.this.statusTextView.setText(\"文件下载完成\"); &#125; &#125;; uiHandler.post(runnable); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;B、使用sendMessage方式实现public class MainActivity extends Activity implements Button.OnClickListener &#123; private TextView statusTextView = null; //uiHandler在主线程中创建，所以自动绑定主线程 private Handler uiHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 1: System.out.println(\"msg.arg1:\" + msg.arg1); System.out.println(\"msg.arg2:\" + msg.arg2); MainActivity.this.statusTextView.setText(\"文件下载完成\"); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); statusTextView = (TextView)findViewById(R.id.statusTextView); Button btnDownload = (Button)findViewById(R.id.btnDownload); btnDownload.setOnClickListener(this); System.out.println(\"Main thread id \" + Thread.currentThread().getId()); &#125; @Override public void onClick(View v) &#123; DownloadThread downloadThread = new DownloadThread(); downloadThread.start(); &#125; class DownloadThread extends Thread&#123; @Override public void run() &#123; try&#123; System.out.println(\"开始下载文件\"); //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程 Thread.sleep(5000); System.out.println(\"文件下载完成\"); //文件下载完成后更新UI Message msg = new Message(); //虽然Message的构造函数式public的，我们也可以通过以下两种方式通过循环对象获取Message //msg = Message.obtain(uiHandler); //msg = uiHandler.obtainMessage(); //what是我们自定义的一个Message的识别码，以便于在Handler的handleMessage方法中根据what识别 //出不同的Message，以便我们做出不同的处理操作 msg.what = 1; //我们可以通过arg1和arg2给Message传入简单的数据 msg.arg1 = 123; msg.arg2 = 321; //我们也可以通过给obj赋值Object类型传递向Message传入任意数据 //msg.obj = null; //我们还可以通过setData方法和getData方法向Message中写入和读取Bundle类型的数据 //msg.setData(null); //Bundle data = msg.getData(); //将该Message发送给对应的Handler uiHandler.sendMessage(msg); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 以上代码来自博客：Android中Handler的使用 上面这两种形式都能达到我们的要求，在此不一一测验，注释写的很详细了，看到这里应该已经大致知道了如何使用Handler，但是我想我们应该远远不满足于此，下一篇博客将带着大家从源码一起看看Handler机制到底是怎么实现的。","tags":[{"name":"Android","slug":"Android","permalink":"https:///www.limuyang.cc/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"https:///www.limuyang.cc/tags/Handler/"}]},{"title":"人生苦短，我用Python--分分钟下载知乎美图给你看","date":"2016-08-11T11:45:46.000Z","path":"2016/08/11/人生苦短，我用Python-分分钟下载知乎美图给你看/","text":"起上次说了要爬知乎的图片，于是花了一下午的时间去完成这件事，发现暂时接触到的爬虫总是逃脱不了一个规律： 模拟登陆 获取真实网页HTML源代码 解析获取到的网页源代码 获取想要的资源(下载到某个文件夹或者输出到表格中整合起来) 也许和我说的有一些出入，应该是刚学这个东西的原因，接下来还想研究一下多线程爬虫、添加代理、爬取海量数据并整合成图表形式，先把能做的做了。 承因为是在上一次的基础上进行的，所以没有看上一篇文章的可以先看一下，这里用到的工具跟之前一样： win7 64位 旗舰版 Python 3.5 64-bit PyCharm 这里模拟登陆是跟之前一样的代码，直接贴就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576logn_url = 'http://www.zhihu.com/#signin'session = requests.session()headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36',&#125;content = session.get(logn_url, headers=headers).contentsoup = BeautifulSoup(content, 'html.parser')def getxsrf(): return soup.find('input', attrs=&#123;'name': \"_xsrf\"&#125;)['value'] # 获取验证码def get_captcha(): t = str(int(time.time() * 1000)) captcha_url = 'http://www.zhihu.com/captcha.gif?r=' + t + \"&amp;type=login\" r = session.get(captcha_url, headers=headers) with open('captcha.jpg', 'wb') as f: f.write(r.content) f.close() # 用pillow 的 Image 显示验证码 # 如果没有安装 pillow 到源代码所在的目录去找到验证码然后手动输入 try: im = Image.open('captcha.jpg') im.show() im.close() except: print(u'请到 %s 目录找到captcha.jpg 手动输入' % os.path.abspath('captcha.jpg')) captcha = input(\"please input the captcha\\n&gt;\") return captchadef isLogin(): # 通过查看用户个人信息来判断是否已经登录 url = \"https://www.zhihu.com/settings/profile\" login_code = session.get(url, allow_redirects=False).status_code if int(x=login_code) == 200: return True else: return Falsedef login(secret, account): # 通过输入的用户名判断是否是手机号 if re.match(r\"^1\\d&#123;10&#125;$\", account): print(\"手机号登录 \\n\") post_url = 'http://www.zhihu.com/login/phone_num' postdata = &#123; '_xsrf': getxsrf(), 'password': secret, 'remember_me': 'true', 'phone_num': account, &#125; else: print(\"邮箱登录 \\n\") post_url = 'http://www.zhihu.com/login/email' postdata = &#123; '_xsrf': getxsrf(), 'password': secret, 'remember_me': 'true', 'email': account, &#125; try: # 不需要验证码直接登录成功 login_page = session.post(post_url, data=postdata, headers=headers) login_code = login_page.text print(login_page.status) print(login_code) except: # 需要输入验证码后才能登录成功 postdata[\"captcha\"] = get_captcha() login_page = session.post(post_url, data=postdata, headers=headers) login_code = eval(login_page.text) print(login_code['msg']) 这里的代码来自GitHub上的fuck-login项目，在此表示感谢，我在原始代码上进行了改进，原始代码是适配了Python2.x和Python3.x，但是我学的是Python3.x所以去掉了一些我没用过的模块，也就是说我改进了后的代码是适用于Python3.x的。 下面就是准备获取图片了，先找一个目标，最近有一个问题很火： 长得好看，但没有男朋友是怎样的体验 还记得我列出来的步骤么，模拟登陆之后是获取真实的网页源代码，什么叫真实的，这个问题问得好，你没发现知乎很喜欢用动态加载技术么，也就是说，你看到的只是表象，这里也一样。 转 来，我们先点开点赞数最高的妹子上传的图片： 咳咳咳，好像跑偏了，我们的目标是星辰大海，正确的做法是鼠标右键查看网页源代码： 是不是看到了很多图片链接，当然我们要找.jpg、.jpeg、.png后缀的： 1&lt;img data-rawwidth=\"1632\" data-rawheight=\"2040\" src=\"//zhstatic.zhihu.com/assets/zhihu/ztext/whitedot.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1632\" data-original=\"https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_b.jpg\"&gt; 这里有两个：data-original和data-actualsrc，实际查看的图片是data-original的图片比data-actualsrc的大，下载下来也是如此，但是因为是使用正则去匹配规则，而data-original有多项，上面代码只是贴出来的一部分，实际匹配的结果类似这样： data-actualsrc12data-actualsrc=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_b.jpg&quot;&gt;data-actualsrc=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_b.jpg&quot;&gt; data-original 12345data-original=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_r.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_b.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_r.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_b.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/0930549116d22ffce22e98c32683d621_r.jpg&quot;&gt; 这是在同一段网页源码测试下的结果，匹配后一种会得到多个相同的url地址，解析起来也更麻烦，这也跟正则写的简单有关系，有兴趣的可以到时候自己修改一下正则表达式，这样下下来的图片也更高清的多。 分析了正则，下面要获取所有的图片该分析Chrome开发者面板的Post数据，因为知乎默认只显示部分回答，我们可以不断往下拉，直到看到这个： 点击的时候注意观察开发者面板： 简直完美，传递的数据： 12method:nextparams:&#123;&quot;url_token&quot;:37709992,&quot;pagesize&quot;:10,&quot;offset&quot;:30&#125; 很眼熟，url_token就是问题后面那串数字： 1https://www.zhihu.com/question/37709992 pagesize是固定的10，最后一个offset偏移量同样很好理解，这里显示10应该说的就是默认显示的10个答案，后面还查看到如下数据：12method:nextparams:&#123;&quot;url_token&quot;:37709992,&quot;pagesize&quot;:10,&quot;offset&quot;:20&#125; 12method:nextparams:&#123;&quot;url_token&quot;:37709992,&quot;pagesize&quot;:10,&quot;offset&quot;:30&#125; 也就是说我们在浏览器上每翻过10个答案浏览器就会向服务器发送Post请求在加载十个答案，恩差不多可以开始写代码了。 合模拟登陆之后的操作是找到Post的真实地址模拟浏览器向服务器发送请求： 1234567891011121314url = 'https://www.zhihu.com/node/QuestionAnswerListV2'header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Referer': 'https://www.zhihu.com/question/37709992', 'Origin': 'https://www.zhihu.com', 'Accept-Encoding': 'gzip, deflate, br',&#125;data = &#123; 'method': 'next', 'params': '&#123;\"url_token\":' + str(37709992) + ',\"pagesize\": \"10\",' + \\ '\"offset\":' + str(offset) + \"&#125;\", '_xsrf': getxsrf(),&#125; 注意 发送Post请求时候请加上&#39;_xsrf&#39;: getxsrf()这一行，否则的话返回的只会是404 Forbidden，应该是做了防伪登陆的缘故 然后是写正则，这里发现图片都是被包含在这里面： 1234&lt;div class=\"zm-editable-content clearfix\"&gt;......&lt;/div&gt; 所以先匹配到这一大串内容： 12pattern = re.compile('&lt;a class=\"author-link\".*?&lt;span title=.*?&lt;div class=\"zh-summary.*?' + '&lt;div class=\"zm-editable-content.*?&gt;(.*?)&lt;/div&gt;', re.S) 然后在匹配data-actualsrc里面的图片链接： 1pattern = re.compile('data-actualsrc=\"(.*?)\"&gt;', re.S) 还有一点要注意的是我们请求之后返回来的是json格式的数据，所以这里还要用到json模块： 123question = session.post(url, headers=header, data=data)dic = json.loads(question.content.decode('ISO-8859-1'))li = dic['msg'][0] 然后对其进行解析： 12345678910# 这里使用的是第一个正则表达式items = re.findall(pattern, li)# 接下来items = re.findall(pattern, li)# 存储图片链接imagesurl = []pattern = re.compile('data-actualsrc=\"(.*?)\"&gt;', re.S)for item in items: urls = re.findall(pattern, item) imagesurl.extend(urls) 执行下载操作： 123456789101112131415161718192021222324252627282930# 存放图片的地址PWD = \"D:/work/python/zhihu/\" for url in imagesurl: myurl = url filename = PWD + str(count) + '.jpg' if os.path.isfile(filename): print(\"文件存在：\", filename) count += 1 continue else: # 执行下载操作的方法 downpic(filename, myurl) count += 1 photoNum += 1 print(\"一共下载了&#123;0&#125; 张照片\".format(photoNum)) if not os.path.exists(PWD): os.makedirs(PWD) # 递归调用 change(offset, count, photoNum)# downpic方法源码def downpic(filename, url): print(\"正在下载 \" + url) try: r = requests.get(url, stream=True) with open(filename, 'wb') as fd: for chunk in r.iter_content(): fd.write(chunk) except Exception as e: print(\"下载失败了\", e) 运行结果 这只是一部分，我之前下了四五百张还在下~当然这是后话，感觉现在写的东西都很简单，希望下一次能写出难一点的东西出来。 这里正则部分参考了这里： 通过Python爬虫爬取知乎某个问题下的图片 最后是源码 源码中注释部分只能下载前十个答案里包含的图片的方法，还有一些想法未完成，本来是想打印一下正在下载哪个答主的回答，然后把图片分别保存到相应的单独文件夹，实现起来有点麻烦就没去搞，仅供参考。 亲测如果需要下载另一个问题的答案，只需要在:1234567data = &#123; &apos;method&apos;: &apos;next&apos;, &apos;params&apos;: &apos;&#123;&quot;url_token&quot;:&apos; + str(37709992) + &apos;,&quot;pagesize&quot;: &quot;10&quot;,&apos; + \\ &apos;&quot;offset&quot;:&apos; + str(offset) + &quot;&#125;&quot;, &apos;_xsrf&apos;: getxsrf(), &#125; 更换那串数字就行，就好比这样的形式： https://www.zhihu.com/question/48720845 但是这种形式的把数字换上去不起效： https://www.zhihu.com/question/49078894#answer-41776282 这个好像是知乎热门问答的链接形式，暂时没有深究","tags":[{"name":"知乎","slug":"知乎","permalink":"https:///www.limuyang.cc/tags/知乎/"},{"name":"爬虫","slug":"爬虫","permalink":"https:///www.limuyang.cc/tags/爬虫/"},{"name":"数据采集","slug":"数据采集","permalink":"https:///www.limuyang.cc/tags/数据采集/"}]},{"title":"人生苦短，我用Python--一起来爬知乎娘","date":"2016-08-09T11:14:46.000Z","path":"2016/08/09/人生苦短，我用Python-一起来爬知乎娘/","text":"上次爬了教务处的成绩，接下来想去爬一爬知乎娘，好像大家都很喜欢爬知乎娘，GitHub上貌似已经有人把获取各种知乎数据的操作封装好了：zhihu-python ，但是良辰表示还是想自己试一试，我就爬点简单的，难度大的我也不会，我瞄准的是我自己关注的人的数据，差不多就这些东西： 关注者 / 提问 / 回答 / 赞同 那么下面开始分析，要拿到这个数据肯定是要先登陆的，那么先找到登陆界面： 这算是比较正常的界面，不知道为什么有的时候会出现新的验证码形式： 这种形式登陆的话我看传递的表单数据是你鼠标点击的坐标，这种情况暂时不知道怎么办，留给高手，我们分析上面那种，知乎登陆分为手机号登陆或者邮箱登陆，先试试邮箱登陆，查看Post数据： 然后是手机号登陆的: 现在理一下思路，我们要登录知乎要传递的数据如下： _xsrf() 用于防伪登陆 password captcha 验证码 phone_num/email 不同登陆方式传递的东西不同 phone_num/email以及passsword都需要自己输入，这个好办，我们需要解决如何获取 _xsrf和captcha 的问题，先解决 _xsrf，这个更简单一点，我们在知乎登陆页面 右键查看网页源代码，直接搜_xsrf： 1234&lt;div class=\"view view-signin\" data-za-module=\"SignInForm\"&gt;&lt;form&gt;&lt;input type=\"hidden\" name=\"_xsrf\" value=\"cf1ee28f15cea5dba3243a1c31a1b284\"/&gt;&lt;div class=\"group-inputs\"&gt; 我们要做的就是解析出这个元素，直接上代码： 12345678910logn_url = 'http://www.zhihu.com/#signin'session = requests.session()headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36',&#125;content = session.get(logn_url, headers=headers).contentsoup = BeautifulSoup(content, 'html.parser')def getxsrf(): return soup.find('input', attrs=&#123;'name': \"_xsrf\"&#125;)['value'] 下面获取验证码， 我发现无论是使用哪一种登陆方式，Chrome的开发者面板都会有这么一行： 当我把这个Request URL输入浏览器中就会转到这个验证码图片的界面，说明这个验证码是我们加载这个页面时候，浏览器向服务器发出请求然后下载下来的，那么现在我们有了URL地址： 这还是一个GET请求，这里注意这个传递的r参数是会不断变化的，这是一个当前Unix的时间戳，知道了这些可以着手获取验证码然后让用户自己输入： 12345678910111213141516171819202122try: from PIL import Imageexcept: pass# 获取验证码def get_captcha(): t = str(int(time.time() * 1000)) captcha_url = 'http://www.zhihu.com/captcha.gif?r=' + t + \"&amp;type=login\" r = session.get(captcha_url, headers=headers) with open('captcha.jpg', 'wb') as f: f.write(r.content) f.close() # 用pillow 的 Image 显示验证码 # 如果没有安装 pillow 到源代码所在的目录去找到验证码然后手动输入 try: im = Image.open('captcha.jpg') im.show() im.close() except: print(u'请到 %s 目录找到captcha.jpg 手动输入' % os.path.abspath('captcha.jpg')) captcha = input(\"please input the captcha\\n&gt;\") return captcha 这里获取验证码的代码来自GitHub上的fuck-login项目，在此表示感谢，接下里就是写一个方法判断用户是使用了哪一种登陆方式，然后传递相应的数据： 12345678910111213141516171819202122232425262728293031323334def login(secret, account): # 通过输入的用户名判断是否是手机号 if re.match(r&quot;^1\\d&#123;10&#125;$&quot;, account): print(&quot;手机号登录 \\n&quot;) post_url = &apos;http://www.zhihu.com/login/phone_num&apos; postdata = &#123; &apos;_xsrf&apos;: getxsrf(), &apos;password&apos;: secret, &apos;remember_me&apos;: &apos;true&apos;, &apos;phone_num&apos;: account, &#125; else: print(&quot;邮箱登录 \\n&quot;) post_url = &apos;http://www.zhihu.com/login/email&apos; postdata = &#123; &apos;_xsrf&apos;: getxsrf(), &apos;password&apos;: secret, &apos;remember_me&apos;: &apos;true&apos;, &apos;email&apos;: account, &#125; try: # 不需要验证码直接登录成功 login_page = session.post(post_url, data=postdata, headers=headers) login_code = login_page.text print(login_page.status) print(login_code) except: # 需要输入验证码后才能登录成功 postdata[&quot;captcha&quot;] = get_captcha() login_page = session.post(post_url, data=postdata, headers=headers) login_code = eval(login_page.text) print(login_code[&apos;msg&apos;])# 这部分代码同样来自[**fuck-login**](https://github.com/xchaoinfo/fuck-login)项目,我偷了很多懒,囧 这个时候判断是否登陆成功可以随便查看一个页面发送GET请求看是否返回200，这里就不多说，接下来才是关键，为了获取我关注的人的信息，先打开开发者面板，这个地方打钩： 因为网页有时候会跳转，这里打钩之后新跳转的页面的信息就不会覆盖之前接受到的信息，然后找到我关注的人，URL地址是： https://www.zhihu.com/people/GitSmile/followees 最开始我走了弯路，我以为直接在这个页面解析出我关注的人的信息就行，所以一开始我是这么做的，查看网页源代码，这里随便找一个我关注的人的信息： 1234567891011121314151617181920212223&lt;a title=\"死者代言人\"data-hovercard=\"p$t$forensic\"class=\"zm-item-link-avatar\"href=\"/people/forensic\"&gt;&lt;img src=\"https://pic1.zhimg.com/be39d110759e68f389b7d2934d7353bc_m.jpg\" class=\"zm-item-img-avatar\"&gt;&lt;/a&gt;&lt;div class=\"zm-list-content-medium\"&gt;&lt;h2 class=\"zm-list-content-title\"&gt;&lt;a data-hovercard=\"p$t$forensic\" href=\"https://www.zhihu.com/people/forensic\" class=\"zg-link author-link\" title=\"死者代言人\"&gt;死者代言人&lt;/a&gt;&lt;span class=\"icon icon-badge-best_answerer icon-badge\" data-tooltip=\"s$b$优秀回答者\"&gt;&lt;/span&gt;&lt;/h2&gt;&lt;div class=\"ellipsis\"&gt;&lt;span class=\"badge-summary\"&gt;优秀回答者&lt;/span&gt;&lt;span class=\"bio\"&gt;不养喵的爱喵法医。&lt;/span&gt;&lt;/div&gt;&lt;div class=\"details zg-gray\"&gt;&lt;a target=\"_blank\" href=\"/people/forensic/followers\" class=\"zg-link-gray-normal\"&gt;35968 关注者&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/forensic/asks\" class=\"zg-link-gray-normal\"&gt;2 提问&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/forensic/answers\" class=\"zg-link-gray-normal\"&gt;305 回答&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/forensic\" class=\"zg-link-gray-normal\"&gt;51278 赞同&lt;/a&gt;&lt;/div&gt; 然后在对比另一条： 1234567891011121314151617181920212223&lt;a title=\"陈亦飘\"data-hovercard=\"p$t$chen-yi-piao\"class=\"zm-item-link-avatar\"href=\"/people/chen-yi-piao\"&gt;&lt;img src=\"https://pic2.zhimg.com/d495751efbf837b1b5b08571add7df3d_m.jpg\" class=\"zm-item-img-avatar\"&gt;&lt;/a&gt;&lt;div class=\"zm-list-content-medium\"&gt;&lt;h2 class=\"zm-list-content-title\"&gt;&lt;a data-hovercard=\"p$t$chen-yi-piao\" href=\"https://www.zhihu.com/people/chen-yi-piao\" class=\"zg-link author-link\" title=\"陈亦飘\"&gt;陈亦飘&lt;/a&gt;&lt;/h2&gt;&lt;div class=\"ellipsis\"&gt;&lt;span class=\"bio\"&gt;音乐和电影是我的爱与慈悲&lt;/span&gt;&lt;/div&gt;&lt;div class=\"details zg-gray\"&gt;&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/followers\" class=\"zg-link-gray-normal\"&gt;74469 关注者&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/asks\" class=\"zg-link-gray-normal\"&gt;0 提问&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/answers\" class=\"zg-link-gray-normal\"&gt;80 回答&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao\" class=\"zg-link-gray-normal\"&gt;315971 赞同&lt;/a&gt;&lt;/div&gt; 要分解出这些元素，只要找出他们的共同点，当时机智如我一眼就发现每一个我关注的人的名字都有这么一行元素： 1class=&quot;zm-item-link-avatar&quot; 而且都包含在一个&lt;a&gt;&lt;/a&gt;标签里面，这就好办了，使用BeautifulSoup先分解出每一个我关注的人的名字： 123456789101112def getdetial(): followees_url = &apos;https://www.zhihu.com/people/GitSmile/followees&apos; followees_headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36&apos;, &apos;Referer&apos;: &apos;https://www.zhihu.com/people/GitSmile/about&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch, br&apos; &#125; myfollowees = session.get(followees_url, headers=followees_headers) mysoup = BeautifulSoup(myfollowees.content, &apos;html.parser&apos;) print(mysoup.find(&apos;span&apos;, attrs=&#123;&apos;class&apos;: &apos;zm-profile-section-name&apos;&#125;).text) 然后继续观察，突破点依然在这个&lt;a&gt;&lt;/a&gt;标签，拿”陈亦飘”的信息做个例子，看官们看这里面是不是有个href=&quot;/people/chen-yi-piao，然后看一下她的相关信息： 1234567&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/followers\" class=\"zg-link-gray-normal\"&gt;74469 关注者&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/asks\" class=\"zg-link-gray-normal\"&gt;0 提问&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/answers\" class=\"zg-link-gray-normal\"&gt;80 回答&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao\" class=\"zg-link-gray-normal\"&gt;315971 赞同&lt;/a&gt; 发现没有，每一个信息里面的href元素都是我们最开始看到的/people/chen-yi-piao元素加上一些字符串组成的，那么我就可以在这上面做点文章： 12345678910111213141516171819202122232425获取详细信息def getdetial(): followees_url = 'https://www.zhihu.com/people/GitSmile/followees' followees_headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Referer': 'https://www.zhihu.com/people/GitSmile/about', 'Upgrade-Insecure-Requests': '1', 'Accept-Encoding': 'gzip, deflate, sdch, br' &#125; myfollowees = session.get(followees_url, headers=followees_headers) mysoup = BeautifulSoup(myfollowees.content, 'html.parser') print(mysoup.find('span', attrs=&#123;'class': 'zm-profile-section-name'&#125;).text) for result in mysoup.findAll('a', attrs=&#123;'class': 'zm-item-link-avatar'&#125;): print(result.get('title')) # 解析出href元素信息 href = str(result.get('href')) # 关注者 print(mysoup.find('a', attrs=&#123;'href': href + '/followers'&#125;).text) # 提问 print(mysoup.find('a', attrs=&#123;'href': href + '/asks'&#125;).text) # 回答 print(mysoup.find('a', attrs=&#123;'href': href + '/answers'&#125;).text) # 赞同 print(mysoup.find('a', attrs=&#123;'href': href, 'class': 'zg-link-gray-normal'&#125;).text + '\\n') 上面的代码应该很简单了，看一看就能看懂，然后就我信心满满地在PyCharm上输出的时候，发现来来回回只输出20条信息，也就是说，我关注了26人，但是控制台只输出了20个人的信息，然后我就上网查，发现不止一个人有我这样的疑问，当然也多亏了前人踩坑，网上给出来的答案是知乎获取关注的人的时候使用了AJAX技术，也就是动态加载，但是这一部分代码不会再网页Html代码中显示出来，所以为了获取其他关注的人的信息我这里要另辟蹊径。 然后我翻看我关注的人的信息的时候，在开发者面板抓到这么一条POST信息： 这条POST之后下面刷出来的图片是我关注的人的头像并且这些头像在我之前看到的20条数据里面是没有的，加上我总共就关注了27个人，所以我有理由相信这个Post就是浏览器向服务器发送请求的Post，看一下Post的信息： 一个偏移量(offset)，一个哈希值(hash_id)外加一个”order_by”:”created”的键值对，这里偏移量很好理解，这个”hash_id”据我多次登陆发现是一个不变的值，或者说每一台电脑或许精确一点每一个浏览器都会有这么一个给定的值，照抄，那么改进后的代码如下： 123456789101112131415161718192021222324252627282930313233343536# 获取所有关注的人的信息def getallview(): nums = 27 # 这个是我关注的人数 followees_headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36&apos;, &apos;Referer&apos;: &apos;https://www.zhihu.com/people/GitSmile/followees&apos;, &apos;Origin&apos;: &apos;https://www.zhihu.com&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;, &apos;CG - Sid&apos;: &apos;57226ad5 - 793b - 4a9d - 9791 - 2a9a17e682ef&apos;, &apos;Accept&apos;: &apos;* / *&apos; &#125; # 序号 count = 0 for index in range(0, nums): fo_url = &apos;https://www.zhihu.com/node/ProfileFolloweesListV2&apos; m_data = &#123; &apos;method&apos;: &apos;next&apos;, &apos;params&apos;: &apos;&#123;&quot;offset&quot;:&apos; + str( index) + &apos;,&quot;order_by&quot;:&quot;created&quot;,&quot;hash_id&quot;:&quot;de2cb64bc1afe59cf8a6e456ee5eaebc&quot;&#125;&apos;, &apos;_xsrf&apos;: str(getxsrf()) &#125; result = session.post(fo_url, data=m_data, headers=followees_headers) dic = json.loads(result.content.decode(&apos;utf-8&apos;)) li = dic[&apos;msg&apos;][0] mysoup = BeautifulSoup(li, &apos;html.parser&apos;) for result in mysoup.findAll(&apos;a&apos;, attrs=&#123;&apos;class&apos;: &apos;zm-item-link-avatar&apos;&#125;): print(index + 1) print(result.get(&apos;title&apos;)) href = str(result.get(&apos;href&apos;)) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href + &apos;/followers&apos;&#125;).text) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href + &apos;/asks&apos;&#125;).text) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href + &apos;/answers&apos;&#125;).text) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href, &apos;class&apos;: &apos;zg-link-gray-normal&apos;&#125;).text + &apos;\\n&apos;) count += 1 print(&apos;一共关注了 %d人&apos; % count) 放上程序的入口： 123456789if __name__ == &apos;__main__&apos;: if isLogin(): print(&apos;您已经登录&apos;) else: account = input(&apos;请输入你的用户名\\n&gt; &apos;) secret = input(&quot;请输入你的密码\\n&gt; &quot;) login(secret, account) getallview() 看一下实际效果： 写在结尾 虽然简单，但是提供了一些初学者的思路，下一次准备爬一些知乎上的图片，好像很多人都热衷于这种事，嘻嘻，荆轲刺秦王。 源码","tags":[{"name":"知乎","slug":"知乎","permalink":"https:///www.limuyang.cc/tags/知乎/"},{"name":"爬虫","slug":"爬虫","permalink":"https:///www.limuyang.cc/tags/爬虫/"},{"name":"网络","slug":"网络","permalink":"https:///www.limuyang.cc/tags/网络/"}]},{"title":"人生苦短，我用Python--爬虫模拟登陆教务处并且保存数据到本地","date":"2016-08-04T11:26:46.000Z","path":"2016/08/04/人生苦短，我用Python-爬虫模拟登陆教务处并且保存数据到本地/","text":"刚开始接触Python，看很多人玩爬虫我也想玩，找来找去发现很多人用网络爬虫干的第一件事就是模拟登陆，增加点难度就是模拟登陆后在获取数据，但是网上好少有Python 3.x的模拟登陆Demo可以参考，加上自己也不怎么懂HTML，所以这第一个Python爬虫写的异常艰难，不过最终结果还是尽如人意的，下面把这次学习的过程整理一下。工具 系统：win7 64位系统 浏览器：Chrome Python版本：Python 3.5 64-bit IDE：JetBrains PyCharm (貌似很多人都用这个) 我把目标瞄准了我们的教务处，这次爬虫的目的是从教务处获取成绩并且把成绩输入Excel表格中保存起来， 我们学校教务处的地址是：http://jwc.ecjtu.jx.cn/ ，往常每次我们获取成绩都需要先进入教务处，然后点击成绩查询，输入公共的账号密码进入，最后输入相关信息获取成绩表格，这里登陆不需要验证码省了我一番功夫，这样我们先进入成绩查询系统登陆界面，先看看怎么模拟登陆这个过程，在Chrome浏览器下按F12打开开发者面板： 这里我们学校的教务处查询系统的密码是公共的jwc也就是拼音缩写，我们输入用户名和密码点击登陆，这时候注意POST请求： 发现了什么，好像Chrome并没有把Post提交的表单信息保留下来直接跳转到了另一个界面然后展示另一个界面的数据，这里就需要我们自己动手操作一下，注意开发者面板左上角的小红点表示这时候正在抓取数据，如果点击一下就会变成灰色，就可以变相地保存下当时抓取到的包，我在点击登陆后新界面未刷新出来之前点击了这个小红点，如愿以偿的得到了Post的表单数据： 这样就获取了浏览器在登陆时候向服务器传递的表单数据，看一下这个表单都有些什么： 这里看到我们需要传递三个参数，分别是：user、pass、Submit，可以很容易的理解这几个单词的字面意思，这样有了思路，我们就可以写出这次代码的第一步：模拟登陆教务处 直接上代码: 1234567891011121314151617#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsurl = 'http://jwc.ecjtu.jx.cn/mis_o/login.php'datas = &#123;'user': 'jwc', 'pass': 'jwc', 'Submit': '%CC%E1%BD%BB' &#125;headers = &#123;'Referer': 'http://jwc.ecjtu.jx.cn/mis_o/login.htm', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 ' '(KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8', &#125;sessions = requests.session()response = sessions.post(url, headers=headers, data=datas)print(response.status_code) 代码输出： 1200 说明我们模拟登陆成功了，这里用到了Requests模块，还不会使用的可以查看中文文档 ，它给自己的定义是：HTTP for Humans，因为简单易用易上手，我们只需要传入Url地址，构造请求头，传入post方法需要的数据，就可以模拟浏览器登陆了，这里因为有进一步获取成绩的操作所以使用了session来保持连接，这里单看最后的返回码的话我们是成功了的，具体如何还要看下一步操作，接下来： 这里为了简便代码我们设定输入学号查询所有成绩，减少其他判断，同样对Post数据进行抓包： 同样查看Post的数据： 因为这里就分析输入学号的情况所以其他都为空，这样我们就可以写出查询成绩的代码： 1234567891011121314151617181920212223score_healders = &#123;'Connection': 'keep-alive', 'User - Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Content - Type': 'application / x - www - form - urlencoded', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Content - Length': '69', 'Host': 'jwc.ecjtu.jx.cn', 'Referer': 'http: // jwc.ecjtu.jx.cn / mis_o / main.php', 'Upgrade - Insecure - Requests': '1', 'Accept - Language': 'zh - CN, zh;q = 0.8' &#125;score_url = 'http://jwc.ecjtu.jx.cn/mis_o/query.php?start=' + str( pagenum) + '&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=' + numscore_data = &#123;'Name': '', 'StuID': num, 'Course': '', 'Term': '', 'ClassID': '', 'Submit': '%B2%E9%D1%AF' &#125;score_response = sessions.post(score_url, data=score_data, headers=score_healders)content = score_response.content 这里解释一下上面的代码，上面的score_url 并不是浏览器上显示的地址，我们要获取真正的地址，在Chrome下右键–查看网页源代码，找到这么一行： 1a href=query.php?start=1&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=xxxxxxx 这个才是真正的地址，点击这个地址转入的才是真正的界面，因为这里成绩数据较多，所以这里采用了分页显示，这个start=1说明是第一页，这个参数是可变的需要我们传入，还有StuID后面的是我们输入的学号，这样我们就可以拼接出Url地址： 1score_url = &apos;http://jwc.ecjtu.jx.cn/mis_o/query.php?start=&apos; + str(pagenum) + &apos;&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=&apos; + num 同样使用Post方法传递数据并获取响应的内容： 12score_response = sessions.post(score_url, data=score_data,headers=score_healders)content = score_response.content 这里采用Beautiful Soup 4.2.0来解析返回的响应内容，因为我们要获取的是成绩，这里到教务处成绩查询界面，查看获取到的成绩在网页中是以表格的形式存在： 观察表格的网页源代码： 12345678910111213&lt;table align=center border=1&gt;&lt;tr&gt;&lt;td bgcolor=009999&gt;学期&lt;/td&gt;&lt;td bgcolor=009999&gt;学号&lt;/td&gt;&lt;td bgcolor=009999&gt;姓名&lt;/td&gt;&lt;td bgcolor=009999&gt;课程&lt;/td&gt;&lt;td bgcolor=009999&gt;课程要求&lt;/td&gt;&lt;td bgcolor=009999&gt;学分&lt;/td&gt;&lt;td bgcolor=009999&gt;成绩&lt;/td&gt;&lt;td bgcolor=009999&gt;重考一&lt;/td&gt;&lt;td bgcolor=009999&gt;重考二&lt;/td&gt;&lt;/tr&gt;......&lt;/tr&gt;&lt;/table&gt; 这里拿出第一行举例，虽然我不太懂Html但是从这里可以看出来&lt;tr&gt; 代表的是一行，而&lt;td&gt;应该是代表这一行中的每一列，这样就好办了，取出每一行然后分解出每一列，打印输出就可以得到我们要的结果： 1234from bs4 import BeautifulSoupsoup = BeautifulSoup(content, 'html.parser')# 找到每一行target = soup.findAll('tr') 这里分解每一列的时候要小心，因为这里表格分成了三页显示，每页最多显示30条数据，这里因为只是收集已经毕业的学生的成绩数据所以不对其他数据量不足的学生成绩的情况做统计，默认收集的都是大四毕业的学生成绩数据。这里采用两个变量i和j分别代表行和列： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 注:这里的print单纯是我为了验证结果打印在PyCharm的控制台上而已i=0, j=0for tag in target[1:]: tds = tag.findAll('td') # 每一次都是从列头开始获取 j = 0 # 学期 semester = str(tds[0].string) if semester == 'None': break else: print(semester.ljust(6) + '\\t\\t\\t', end='') # 学号 studentid = tds[1].string print(studentid.ljust(14) + '\\t\\t\\t', end='') j += 1 # 姓名 name = tds[2].string print(name.ljust(3) + '\\t\\t\\t', end='') j += 1 # 课程 course = tds[3].string print(course.ljust(20, ' ') + '\\t\\t\\t', end='') j += 1 # 课程要求 requirments = tds[4].string print(requirments.ljust(10, ' ') + '\\t\\t', end='') j += 1 # 学分 scredit = tds[5].string print(scredit.ljust(2, ' ') + '\\t\\t', end='') j += 1 # 成绩 achievement = tds[6].string print(achievement.ljust(2) + '\\t\\t', end='') j += 1 # 重考一 reexaminef = tds[7].string print(reexaminef.ljust(2) + '\\t\\t', end='') j += 1 # 重考二 reexamines = tds[8].string print(reexamines.ljust(2) + '\\t\\t') j += 1 i += 1 这里查了很多别人的博客都是用正则表达式来分解数据，表示自己的正则写的并不好也尝试了但是没成功，所以无奈选择这种方式，如果有人有测试成功的正则欢迎跟我说一声，我也学习学习。 把数据保存到Excel 因为已经清楚了这个网页保存成绩的具体结构，所以顺着每次循环解析将数据不断加以保存就是了，这里使用xlwt写入数据到Excel，因为xlwt模块打印输出到Excel中的样式宽度偏小，影响观看，所以这里还加入了一个方法去控制打印到Excel表格中的样式: 123456789101112file = xlwt.Workbook(encoding='utf-8')table = file.add_sheet('achieve')# 设置Excel样式def set_style(name, height, bold=False): style = xlwt.XFStyle() # 初始化样式 font = xlwt.Font() # 为样式创建字体 font.name = name # 'Times New Roman' font.bold = bold font.color_index = 4 font.height = height style.font = font return style 运用到代码中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354for tag in target[1:]: tds = tag.findAll(&apos;td&apos;) j = 0 # 学期 semester = str(tds[0].string) if semester == &apos;None&apos;: break else: print(semester.ljust(6) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) table.write(i, j, semester, set_style(&apos;Arial&apos;, 220)) # 学号 studentid = tds[1].string print(studentid.ljust(14) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, studentid, set_style(&apos;Arial&apos;, 220)) table.col(i).width = 256 * 16 # 姓名 name = tds[2].string print(name.ljust(3) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, name, set_style(&apos;Arial&apos;, 220)) # 课程 course = tds[3].string print(course.ljust(20, &apos; &apos;) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, course, set_style(&apos;Arial&apos;, 220)) # 课程要求 requirments = tds[4].string print(requirments.ljust(10, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, requirments, set_style(&apos;Arial&apos;, 220)) # 学分 scredit = tds[5].string print(scredit.ljust(2, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, scredit, set_style(&apos;Arial&apos;, 220)) # 成绩 achievement = tds[6].string print(achievement.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, achievement, set_style(&apos;Arial&apos;, 220)) # 重考一 reexaminef = tds[7].string print(reexaminef.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, reexaminef, set_style(&apos;Arial&apos;, 220)) # 重考二 reexamines = tds[8].string print(reexamines.ljust(2) + &apos;\\t\\t&apos;) j += 1 table.write(i, j, reexamines, set_style(&apos;Arial&apos;, 220)) i += 1file.save(&apos;demo.xls&apos;) 最后稍加整合，写成一个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 获取成绩# 这里num代表输入的学号，pagenum代表页数，总共76条数据，一页30条所以总共有三页def getScore(num, pagenum, i, j): score_healders = &#123;&apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User - Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) &apos; &apos;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36&apos;, &apos;Content - Type&apos;: &apos;application / x - www - form - urlencoded&apos;, &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Content - Length&apos;: &apos;69&apos;, &apos;Host&apos;: &apos;jwc.ecjtu.jx.cn&apos;, &apos;Referer&apos;: &apos;http: // jwc.ecjtu.jx.cn / mis_o / main.php&apos;, &apos;Upgrade - Insecure - Requests&apos;: &apos;1&apos;, &apos;Accept - Language&apos;: &apos;zh - CN, zh;q = 0.8&apos; &#125; score_url = &apos;http://jwc.ecjtu.jx.cn/mis_o/query.php?start=&apos; + str( pagenum) + &apos;&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=&apos; + num score_data = &#123;&apos;Name&apos;: &apos;&apos;, &apos;StuID&apos;: num, &apos;Course&apos;: &apos;&apos;, &apos;Term&apos;: &apos;&apos;, &apos;ClassID&apos;: &apos;&apos;, &apos;Submit&apos;: &apos;%B2%E9%D1%AF&apos; &#125; score_response = sessions.post(score_url, data=score_data, headers=score_healders) # 输出到文本 with open(&apos;text.txt&apos;, &apos;wb&apos;) as f: f.write(score_response.content) content = score_response.content soup = BeautifulSoup(content, &apos;html.parser&apos;) target = soup.findAll(&apos;tr&apos;) try: for tag in target[1:]: tds = tag.findAll(&apos;td&apos;) j = 0 # 学期 semester = str(tds[0].string) if semester == &apos;None&apos;: break else: print(semester.ljust(6) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) table.write(i, j, semester, set_style(&apos;Arial&apos;, 220)) # 学号 studentid = tds[1].string print(studentid.ljust(14) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, studentid, set_style(&apos;Arial&apos;, 220)) table.col(i).width = 256 * 16 # 姓名 name = tds[2].string print(name.ljust(3) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, name, set_style(&apos;Arial&apos;, 220)) # 课程 course = tds[3].string print(course.ljust(20, &apos; &apos;) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, course, set_style(&apos;Arial&apos;, 220)) # 课程要求 requirments = tds[4].string print(requirments.ljust(10, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, requirments, set_style(&apos;Arial&apos;, 220)) # 学分 scredit = tds[5].string print(scredit.ljust(2, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, scredit, set_style(&apos;Arial&apos;, 220)) # 成绩 achievement = tds[6].string print(achievement.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, achievement, set_style(&apos;Arial&apos;, 220)) # 重考一 reexaminef = tds[7].string print(reexaminef.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, reexaminef, set_style(&apos;Arial&apos;, 220)) # 重考二 reexamines = tds[8].string print(reexamines.ljust(2) + &apos;\\t\\t&apos;) j += 1 table.write(i, j, reexamines, set_style(&apos;Arial&apos;, 220)) i += 1 except: print(&apos;出了一点小Bug&apos;) file.save(&apos;demo.xls&apos;) 在模拟登陆操作后增加一个判断： 1234567891011# 判断是否登陆def isLogin(num): return_code = response.status_code if return_code == 200: if re.match(r&quot;^\\d&#123;14&#125;$&quot;, num): print(&apos;请稍等&apos;) else: print(&apos;请输入正确的学号&apos;) return True else: return False 最后在__main__中这么调用： 123456if __name__ == &apos;__main__&apos;: num = input(&apos;请输入你的学号：&apos;) if isLogin(num): getScore(num, pagenum=0, i=0, j=0) getScore(num, pagenum=1, i=31, j=0) getScore(num, pagenum=2, i=61, j=0) 在PyCharm下按alt+shift+x快捷键运行程序： 控制台会有如下输出(这里只截取部分，不要吐槽没有对齐，这里我也用了格式化输出还是不太行，不过最起码出来了结果，而且我们的目的是输出到Excel中不是吗) 然后去程序根目录找看看有没有生成一个叫demo.xls的文件，我的程序就放在桌面，所以去桌面找： 点开查看是否成功获取： 至此，大功告成 小结刚开始接触Python一个星期的样子，这次写了这么一个简单的网络爬虫检验一下学习成果，虽然程序还有些许Bug，不过总归得到了一定收获，当然也为下一步学习打下了基础，嗯哼，为了接下来批量获取网络上美女图片并分类保存我会继续自学Python，荆轲刺秦王~ 源码","tags":[{"name":"Python","slug":"Python","permalink":"https:///www.limuyang.cc/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https:///www.limuyang.cc/tags/爬虫/"},{"name":"模拟登陆","slug":"模拟登陆","permalink":"https:///www.limuyang.cc/tags/模拟登陆/"},{"name":"保存数据","slug":"保存数据","permalink":"https:///www.limuyang.cc/tags/保存数据/"}]},{"title":"Python网络编程基础","date":"2016-07-25T11:24:55.000Z","path":"2016/07/25/Python网络编程基础/","text":"原文转自：Python教程 TCP/IP简介虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。 计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。 因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。 通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。 IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334。TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。 许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。 一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。 端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个IP包来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。 一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。 了解了TCP/IP协议的基本概念，IP地址和端口的概念，我们就可以开始进行网络编程了。 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 客户端 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。 所以，我们要创建一个基于TCP连接的Socket，可以这样做： 123456# 导入socket库:import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('www.sina.com.cn', 80)) 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。 客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？ 答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，因为80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。 因此，我们连接新浪服务器的代码如下： 1s.connect(('www.sina.com.cn', 80)) 注意参数是一个tuple，包含地址和端口号。建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容： 12# 发送数据:s.send(b'GET / HTTP/1.1\\r\\nHost: www.sina.com.cn\\r\\nConnection: close\\r\\n\\r\\n') TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。 发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了： 12345678910# 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b''.join(buffer) 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。 当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了： 12# 关闭连接:s.close() 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件： 12345header, html = data.split(b'\\r\\n\\r\\n', 1)print(header.decode('utf-8'))# 把接收的数据写入文件:with open('sina.html', 'wb') as f: f.write(html) 现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。 服务器 和客户端编程相比，服务器编程就要复杂一些。 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。 首先，创建一个基于IPv4和TCP协议的Socket： 1s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。 端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定： 12# 监听端口:s.bind(('127.0.0.1', 9999)) 紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量： 12s.listen(5)print('Waiting for connection...') 接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接: 123456while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接： 1234567891011def tcplink(sock, addr): print('Accept new connection from %s:%s...' % addr) sock.send(b'Welcome!') while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode('utf-8') == 'exit': break sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8')) sock.close() print('Connection from %s:%s closed.' % addr) 连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。 要测试这个服务器程序，我们还需要编写一个客户端程序： 1234567891011s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&apos;127.0.0.1&apos;, 9999))# 接收欢迎消息:print(s.recv(1024).decode(&apos;utf-8&apos;))for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]: # 发送数据: s.send(data) print(s.recv(1024).decode(&apos;utf-8&apos;))s.send(b&apos;exit&apos;)s.close() 我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了： 需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。 小结 用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。 同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。 源码： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python3# -*- coding: utf-8 -*-import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('www.sina.com.cn', 80))# 发送数据:s.send(b'GET / HTTP/1.1\\r\\nHost: www.sina.com.cn\\r\\nConnection: close\\r\\n\\r\\n')# 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b''.join(buffer)# 关闭连接:s.close()header, html = data.split(b'\\r\\n\\r\\n', 1)print(header.decode('utf-8'))# 把接收的数据写入文件:with open('sina.html', 'wb') as f: f.write(html) UDP编程TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口： 123s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind(('127.0.0.1', 9999)) 创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据： 123456print('Bind UDP on 9999...')while True: # 接收数据: data, addr = s.recvfrom(1024) print('Received from %s:%s.' % addr) s.sendto(b'Hello, %s!' % data, addr) recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 注意这里省掉了多线程，因为这个例子很简单。 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： 1234567s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8'))s.close() 从服务器接收数据仍然调用recv()方法。仍然用两个命令行分别启动服务器和客户端测试，结果如下： 小结 UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。 sever.py 123456789101112131415161718#!/usr/bin/env python3# -*- coding: utf-8 -*-import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind(('127.0.0.1', 9999))print('Bind UDP on 9999...')while True: # 接收数据: data, addr = s.recvfrom(1024) print('Received from %s:%s.' % addr) reply = 'Hello, %s!' % data.decode('utf-8') s.sendto(reply.encode('utf-8'), addr) client.py 1234567891011121314#!/usr/bin/env python3# -*- coding: utf-8 -*-import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8'))s.close()","tags":[{"name":"Python","slug":"Python","permalink":"https:///www.limuyang.cc/tags/Python/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https:///www.limuyang.cc/tags/计算机网络/"}]},{"title":"Android Design Support Library--FloatingActionButton及其Behavior的使用","date":"2016-05-30T16:20:19.000Z","path":"2016/05/31/Android-Design-Support-Library-FloatingActionButton及其Behavior的使用/","text":"引言如果说前面提到的TextInputLayout、SnackBar的应用还不是很常见的话，那么今天提到的FloatingActionButton绝对是一个随处可见的Material Design控件了，无论是我们常用的知乎、印象笔记或者是可爱的谷歌全家桶套装都可以见到FloatingActionButton的身影，今天就来说说FloatingActionButton。 关于使用其实我相信很多人都用过了Material Design控件了，但是还是要说一下，毕竟有些人接触的晚一些，一些人接触的早一些，先从最简单的使用看起： 属性值 作用 app:elevation 设置FAB未按下时的景深 app:pressedTranslationZ 设置FAB按下时的景深 app:fabSize 设置FAB的大小，默认只有normal和mini两种选项 app:borderWidth 设置FAB的边框宽度 android:src 设置FAB的drawaber app:rippleColor 设置FAB按下时的背景色 app:backgroundTint 设置FAB未按下时的背景色 app:layout_anchor 设置FAB的锚点 app:layout_anchorGravity 设置FAB相对于锚点的位置 app:layout_behavior 设置FAB的Behavior行为属性 大部分的属性还是很好理解的，这里要提一下几个注意的点 app:borderWidth :这个一般设置为0dp，不然的话在4.1的sdk上FAB会显示为正方形，而且在5.0以后的sdk没有阴影效果 app:rippleColor：当我使用com.android.support:design:23.2.0 的时候这个属性会失效，建议使用最新的 com.android.support:design:23.3.0&#39; 或者适当的降低版本 android:layout_marginBottom :由于FAB 支持库仍然存在一些 bug，在 Kitkat 和 Lollipop 中分别运行示例代码，可以看到如下结果： Lollipop 中的 FAB： Kitkat 中的 FAB： 很容易看出，Lollipop 中存在边缘显示的问题。为了解决此问题，API21+ 的版本统一定义底部与右边缘空白为 16dp，Lollipop 以下版本统一设置为 0dp.解决办法： values/dimens.xml12&lt;dimen name=\"fab_margin_right\"&gt;0dp&lt;/dimen&gt;&lt;dimen name=\"fab_margin_bottom\"&gt;0dp&lt;/dimen&gt; values-v21/dimens.xml 12&lt;dimen name=\"fab_margin_right\"&gt;16dp&lt;/dimen&gt;&lt;dimen name=\"fab_margin_bottom\"&gt;16dp&lt;/dimen&gt; 布局文件的 FAB 中，也设置相应的值： 12345&lt;android.support.design.widget.FloatingActionButton ... ... android:layout_marginBottom=\"@dimen/fab_margin_bottom\" android:layout_marginRight=\"@dimen/fab_margin_right\"/&gt; 以上这段话出处 app:layout_anchor：和app:layout_anchorGravity属性一起搭配使用，可以做出不同的效果： 最简单的使用1234567&lt;android.support.design.widget.FloatingActionButton ... ... app:layout_anchor=\"@id/mRecycleView\" app:layout_anchorGravity=\"bottom|right|end\" ... /&gt; 更酷炫的效果 123456&lt;android.support.design.widget.FloatingActionButton ... app:layout_anchor=&quot;@id/collapsingToolbarLayout&quot; app:layout_anchorGravity=&quot;bottom|center&quot; ... /&gt; 这张图片出处 可以看出我们只要使用app:layout_anchor属性设置一个控件作为FAB的锚，然后通过app:layout_anchorGravity 属性放置FAB在这个相对的锚的位置，就能做出你想要的效果。 app:layout_behavior：这个属性接下来会重点讲，也就是这个属性成就了Material Design的众多动画交互效果，我们熟知的SnackBar配合FAB可以侧滑以及APPBarLayout等动画效果都是通过Behavior做出来的 自定义Behavior如果你还记得这张图的话： 或者说你见过这种交互效果： 其实这些都是通过Behavior这个类做出来的，以上的两种动画都是默认自带的Behavior，在CoordinatorLayout 内部有对Behavior类的描述： 123456789/** * Interaction behavior plugin for child views of &#123;@link CoordinatorLayout&#125;. * * &lt;p&gt;A Behavior implements one or more interactions that a user can take on a child view. * These interactions may include drags, swipes, flings, or any other gestures.&lt;/p&gt; * * @param &lt;V&gt; The View type that this Behavior operates on */ public static abstract class Behavior&lt;V extends View&gt; &#123; 可以看到这是一个抽象类，我们可以在各个Material Design去实现这个类，这里提到FAB，我们可以找一下FAB中的默认Behavior交互的实现： 123456789/** * Behavior designed for use with &#123;@link FloatingActionButton&#125; instances. It's main function * is to move &#123;@link FloatingActionButton&#125; views so that any displayed &#123;@link Snackbar&#125;s do * not cover them. */ public static class Behavior extends CoordinatorLayout.Behavior&lt;FloatingActionButton&gt; &#123; // We only support the FAB &lt;&gt; Snackbar shift movement on Honeycomb and above. This is // because we can use view translation properties which greatly simplifies the code. private static final boolean SNACKBAR_BEHAVIOR_ENABLED = Build.VERSION.SDK_INT &gt;= 11; 这里只贴出一部分，如果英文不差的话看得懂注释的意思：大致就是说我们这里只提供API 11以上的Snackbar和FAB的运动交互效果，也就是我们上面动图中看到的效果：当出现了一个SnackBar时候，FAB会自动向上移动一段距离，当SnackBar消失的时候FAB会回到原来位置，那么如何定义一个属于我们自己的Behavior，先来看看需要用到的知识： 其实细分的话有两种情况：1、当一个View的变化依赖于另一个View的尺寸、位置等变化的时候，我们只需要关注以下两种方法： 123456789* @param parent 第一个参数不用解释吧* @param 你要依赖别的View的那个View* @param dependency 你要依赖的View* @return return 如果找到了你依赖的那个View就返回true * @see #onDependentViewChanged(CoordinatorLayout, android.view.View, android.view.View) */ public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; 12345678* @param parent 同上，不解释* @param child 同上* @param dependency 同上* @return 如果这个Behavior改变了child的位置或者尺寸大小就返回true */ public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; 其实FAB里面就是实现了这两种方法来与SnackBar交互的，看一下标准写法： 1234567891011121314151617181920@Override public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; // We're dependent on all SnackbarLayouts (if enabled) return SNACKBAR_BEHAVIOR_ENABLED &amp;&amp; dependency instanceof Snackbar.SnackbarLayout; &#125; ... ... @Override public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; if (dependency instanceof Snackbar.SnackbarLayout) &#123; updateFabTranslationForSnackbar(parent, child, dependency); &#125; else if (dependency instanceof AppBarLayout) &#123; // If we're depending on an AppBarLayout we will show/hide it automatically // if the FAB is anchored to the AppBarLayout updateFabVisibility(parent, (AppBarLayout) dependency, child); &#125; return false; &#125; 2、另一种情况是当一个View监听CoordinatorLayout内部滑动的View进行交互时，我们需要关注的方法稍微多一点，这些方法都写在了NestedScrollingParent接口里面，而且CoordinatorLayout已经对这个接口有了默认实现： onStartNestedScroll1234567891011121314151617 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param directTargetChild the child view of the CoordinatorLayout that either is or * contains the target of the nested scroll operation * @param target the descendant view of the CoordinatorLayout initiating the nested scroll * @param nestedScrollAxes the axes that this nested scroll applies to. See * &#123;@link ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;, * &#123;@link ViewCompat#SCROLL_AXIS_VERTICAL&#125; 滑动时是横轴和纵轴 * @return true if the Behavior wishes to accept this nested scroll * * @see NestedScrollingParent#onStartNestedScroll(View, View, int) */public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes) &#123; return false;&#125; onNestedPreScroll12345678910111213141516 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param target the descendant view of the CoordinatorLayout performing the nested scroll * @param dx the raw horizontal number of pixels that the user attempted to scroll * @param dy the raw vertical number of pixels that the user attempted to scroll * @param consumed out parameter. consumed[0] should be set to the distance of dx that * was consumed, consumed[1] should be set to the distance of dy that * was consumed * * @see NestedScrollingParent#onNestedPreScroll(View, int, int, int[]) */public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dx, int dy, int[] consumed) &#123; // Do nothing&#125; onNestedFling123456789101112131415 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param target the descendant view of the CoordinatorLayout performing the nested scroll * @param velocityX horizontal velocity of the attempted fling * @param velocityY vertical velocity of the attempted fling * @param consumed true if the nested child view consumed the fling * @return true if the Behavior consumed the fling * * @see NestedScrollingParent#onNestedFling(View, float, float, boolean) */public boolean onNestedFling(CoordinatorLayout coordinatorLayout, V child, View target, float velocityX, float velocityY, boolean consumed) &#123; return false;&#125; onNestedScroll1234567891011121314151617 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param target the descendant view of the CoordinatorLayout performing the nested scroll * @param dxConsumed horizontal pixels consumed by the target's own scrolling operation * @param dyConsumed vertical pixels consumed by the target's own scrolling operation * @param dxUnconsumed horizontal pixels not consumed by the target's own scrolling * operation, but requested by the user * @param dyUnconsumed vertical pixels not consumed by the target's own scrolling operation, * but requested by the user * * @see NestedScrollingParent#onNestedScroll(View, int, int, int, int) */public void onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; // Do nothing&#125; 如果是码农的话上面的英文注释应该不难吧，这四个方法的区别如下： onStartNestedScroll ：当你想要初始化一个滑动的时候调用 onNestedPreScroll 和onNestedScroll：存在着两个方法的原因是一些Behaviors（比如和AppBarLayout使用的）可能会消费掉部分滚动事件，我们可以在onNestedPreScroll方法内部计算需要滚动的距离，具体的话请看这里 onNestedScroll：当target正尝试滑动或者已经滑动时候调用这个方法 onNestedFling：看到Fling就明白是这是Fling情况下调用的方法，Fling最直观的体现是你滑动一个ListView时松手的时候ListView还会因为惯性自动滑动一小段距离 这么看可能太笼统了，看一下这一类Behavior的实际体现，我们自己自定义一个Behavior： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class FadeBehavior extends FloatingActionButton.Behavior &#123; /** * 因为是在XML中使用app:layout_behavior定义静态的这种行为, * 必须实现一个构造函数使布局的效果能够正常工作。 * 否则 Could not inflate Behavior subclass error messages. * @param context * @param attrs */ public FadeBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; /** * 处理垂直方向上的滚动事件 * * @param coordinatorLayout * @param child * @param directTargetChild * @param target * @param nestedScrollAxes * @return */ @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123; // Ensure we react to vertical scrolling return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); &#125; /** * 检查Y的位置，并决定按钮是否动画进入或退出 * @param coordinatorLayout * @param child * @param target * @param dxConsumed * @param dyConsumed * @param dxUnconsumed * @param dyUnconsumed */ @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB child.hide(); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB child.show(); &#125; &#125;&#125; 这里继承了FAB的Behavior写了一个我们自己的实现，注意实现自己的Behavior的时候一定要重写两个参数的构造方法，因为CoordinatorLayout会从我们在XML中定义的app:layout_behavior属性去找这个Behavior，了解自定义View的对这个应该不会陌生，一般的写法是： 1app:layout_behavior=\".FadeBehavior \" 在查资料的过程中发现很多人把自定义Behavior类所在的包名也写进去了，其实亲测没必要这样做，而且CoordinatorLayout里面也有专门的方法去解析： 1234567891011121314151617181920212223242526272829303132333435363738static Behavior parseBehavior(Context context, AttributeSet attrs, String name) &#123; if (TextUtils.isEmpty(name)) &#123; return null; &#125; final String fullName; if (name.startsWith(\".\")) &#123; // Relative to the app package. Prepend the app package name. fullName = context.getPackageName() + name; &#125; else if (name.indexOf('.') &gt;= 0) &#123; // Fully qualified package name. fullName = name; &#125; else &#123; // Assume stock behavior in this package (if we have one) fullName = !TextUtils.isEmpty(WIDGET_PACKAGE_NAME) ? (WIDGET_PACKAGE_NAME + '.' + name) : name; &#125; try &#123; Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get(); if (constructors == null) &#123; constructors = new HashMap&lt;&gt;(); sConstructors.set(constructors); &#125; Constructor&lt;Behavior&gt; c = constructors.get(fullName); if (c == null) &#123; final Class&lt;Behavior&gt; clazz = (Class&lt;Behavior&gt;) Class.forName(fullName, true, context.getClassLoader()); c = clazz.getConstructor(CONSTRUCTOR_PARAMS); c.setAccessible(true); constructors.put(fullName, c); &#125; return c.newInstance(context, attrs); &#125; catch (Exception e) &#123; throw new RuntimeException(\"Could not inflate Behavior subclass \" + fullName, e); &#125; &#125; 可以看到用这种方式的系统会自动给我们加上包名，写太多反而显的累赘，这个自定义Behavior应该很好理解，效果就是随着RecycleView的滑动FAB会隐藏/显示，是一个很常见的效果： 只要向上滚动FAB就会消失，向下滚动FAB就是显示，这里要注意的是FAB可以与RecycleView形成这种效果，但是暂时并不支持ListView，没关系，反正RecycleView当成ListView来用就好，接下来仿照实现知乎的FAB效果的实现，先看一下知乎的效果： 可以很清楚的看到FAB随着RecycleView的滑动呈现出滚动推出的效果，并且点击FAB会出现旋转效果并且弹出一个蒙版，我们可以先自定义一个用于执行FAB旋转的Behavior，可以看到这里FAB是逆时针旋转135度，那么代码就可以这么写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class RotateBehavior extends CoordinatorLayout.Behavior&lt;FloatingActionButton&gt; &#123; private static final String TAG = RotateBehavior.class.getSimpleName(); public RotateBehavior() &#123; &#125; public RotateBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; return dependency instanceof Snackbar.SnackbarLayout; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; float translationY = getFabTranslationYForSnackBar(parent, child); float percentComplete = -translationY / dependency.getHeight(); child.setRotation(-135 * percentComplete); child.setTranslationY(translationY); return true; &#125; private float getFabTranslationYForSnackBar(CoordinatorLayout parent, FloatingActionButton fab) &#123; float minOffset = 0; final List&lt;View&gt; dependencies = parent.getDependencies(fab); for (int i = 0, z = dependencies.size(); i &lt; z; i++) &#123; final View view = dependencies.get(i); if (view instanceof Snackbar.SnackbarLayout &amp;&amp; parent.doViewsOverlap(fab, view)) &#123; //view.getHeight()固定为144 //ViewCompat.getTranslationY(view)从144-0，再从0-144 minOffset = Math.min(minOffset, ViewCompat.getTranslationY(view) - view.getHeight()); Log.d(\"TranslationY\",ViewCompat.getTranslationY(view)+\"\"); Log.d(\"Height\",view.getHeight()+\"\"); &#125; &#125; return minOffset; &#125;&#125; 这里可能就这段代码比较难理解： 12minOffset = Math.min(minOffset, ViewCompat.getTranslationY(view) - view.getHeight()); 我在上面打了两个Log，分别得出了ViewCompat.getTranslationY(view) 和view.getHeight() ，这样看代码就比较容易看懂，但是为什么ViewCompat.getTranslationY(view) 是正数呢，这里的的View我们都知道指的是SnackBar，我们都知道向上移动的话getTranslationY 应该是负数啊，其实SnackBar的源代码中有一个这样的动作： 12345ViewCompat.setTranslationY(mView, mView.getHeight()); ViewCompat.animate(mView) .translationY(0f) .setInterpolator(FAST_OUT_SLOW_IN_INTERPOLATOR) .setDuration(ANIMATION_DURATION) 也就是说SnackBar一开始就向下移动了mView.getHeight()的长度，当SnackBar出现的时候只是向着它原来的位置移动，本质上还是相当于从它原来的位置移动了一段距离，只是这个距离随着SnackBar向上浮动的越来越多而变得越来越小，直至回到原来的位置，这么说应该可以理解了，接下来我们在XML文件中加入一个TextView作为蒙版： 123456&lt;TextView android:id=&quot;@+id/hide&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffff&quot; android:visibility=&quot;gone&quot; /&gt; 因为CoordinatorLayout相当于帧布局是一层一层叠加的所以这个蒙版放在RecycleView和FAB中间，整个布局代码： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/coor&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/mRecycleView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;TextView android:id=&quot;@+id/hide&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffff&quot; android:visibility=&quot;gone&quot; /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;@dimen/fab_margin_bottom&quot; android:layout_marginEnd=&quot;@dimen/fab_margin_right&quot; android:src=&quot;@mipmap/plus&quot; app:backgroundTint=&quot;#0767C8&quot; app:borderWidth=&quot;0dp&quot; app:elevation=&quot;6dp&quot; app:fabSize=&quot;normal&quot; app:layout_anchor=&quot;@id/mRecycleView&quot; app:layout_anchorGravity=&quot;bottom|right|end&quot; app:layout_behavior=&quot;.FadeBehavior&quot; app:pressedTranslationZ=&quot;12dp&quot; app:rippleColor=&quot;#0767C8&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 看看效果： 是不是有一个很奇怪的地方，知乎的FAB并没有SnackBar弹出啊，那就说明一开始的思路错了，但是一个FAB只能设置一个app:layout_behavior ，如果我们把这个Behavior用作FAB的旋转效果那么FAB的滚动移出视图的效果就没了，所以换一种思路，用Object动画来做FAB的旋转效果： 123456789101112131415161718192021222324252627282930 //开始旋转 public void turnLeft(View v) &#123; ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(v, \"rotation\", 0, -155, -135); objectAnimator.setDuration(300); objectAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); objectAnimator.start(); hide.setVisibility(View.VISIBLE); AlphaAnimation alphaAnimation = new AlphaAnimation(0, 0.75f); alphaAnimation.setDuration(300); alphaAnimation.setFillAfter(true); hide.startAnimation(alphaAnimation); hide.setClickable(true); isOpen = true; &#125; //回到起始位置 public void turnRight(View v) &#123; ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(v, \"rotation\", -135, 20, 0); objectAnimator.setDuration(300); objectAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); objectAnimator.start(); hide.setVisibility(View.GONE); AlphaAnimation alphaAnimation = new AlphaAnimation(0.75f, 0); alphaAnimation.setDuration(300); alphaAnimation.setFillAfter(true); hide.startAnimation(alphaAnimation); hide.setClickable(false); isOpen = false; &#125;//注:hide就是TextView控件(蒙版) 然后实现FAB的滚动移出视图效果的Behavior： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ScrollAwareFABBehavior extends FloatingActionButton.Behavior &#123; //先慢后快再慢 private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator(); private boolean mIsAnimatingOut = false; public ScrollAwareFABBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; //初始条件 @Override public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) &#123; //垂直滚动 return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); &#125; @Override public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; !this.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB animateOut(child); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB animateIn(child); &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits private void animateOut(final FloatingActionButton button) &#123; if (Build.VERSION.SDK_INT &gt;= 14) &#123; //withLayer()使动画中的某些操作变得更顺畅,加速渲染,API 14以后 ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer() .setListener(new ViewPropertyAnimatorListener() &#123; public void onAnimationStart(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = true; &#125; public void onAnimationCancel(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = false; &#125; public void onAnimationEnd(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = false; view.setVisibility(View.GONE); &#125; &#125;).start(); &#125; else &#123; &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters private void animateIn(FloatingActionButton button) &#123; button.setVisibility(View.VISIBLE); if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(0) .setInterpolator(INTERPOLATOR).withLayer().setListener(null) .start(); &#125; else &#123; &#125; &#125; private int getMarginBottom(View v) &#123; int marginBottom = 0; final ViewGroup.LayoutParams layoutParams = v.getLayoutParams(); if (layoutParams instanceof ViewGroup.MarginLayoutParams) &#123; marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin; &#125; return marginBottom; &#125; 最后实现的效果： 这里部分参考了仿知乎FloatingActionButton浮动按钮动画效果实现 至于FAB弹出的InBox这里就不去实现了，比较麻烦，可以参考第三方的实现： FloatingActionButtonPlus 写在末尾主要参考：浮动操作按钮的选择FloatingActionButton.Behaviorcodepath教程：浮动操作按钮详解Design Support Library (II): Floating Action ButtonCoordinatorLayout高级用法-自定义Behavior 项目源代码GitHub地址 写文章不容易，如果可以的话请给个赞","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https:///www.limuyang.cc/tags/Material-Design/"},{"name":"Google","slug":"Google","permalink":"https:///www.limuyang.cc/tags/Google/"},{"name":"FloatingActionButton","slug":"FloatingActionButton","permalink":"https:///www.limuyang.cc/tags/FloatingActionButton/"}]},{"title":"Android Design Support Library--简约而不简单的SnackBar","date":"2016-05-07T12:15:16.000Z","path":"2016/05/07/Android-Design-Support-Library-简约而不简单的SnackBar/","text":"引言在之前我有提到这一篇Android Design Support Library系列文章是关于SnackBar的，但是由于要用到CoordinatorLayout所以先翻译了一篇相关文章，如果还不了解的可以先看一下Android Design Support Library–使用CoordinatorLayout来处理滚动 ，这一篇我们讲SnackBar，SnackBar其实就是Toast的升级版，他们之间最大的不同就是：SnackBar会对我们的操作提供一个轻量级的反馈，并且可以对点击事件做出响应，如果是在手机上使用一个SnackBar的话，我们会看到在屏幕底部出现一条简短的信息，如果是在更大的屏幕上这条信息应该会显示在左下角，并且当一个SnackBar显示的时候它是凌驾于当前所有屏幕元素之上的，我们在屏幕上一次只能显示一个SnackBar，如果这么讲不是很清楚的话，我们先来看一个小Demo，通过代码驱动理解是比较好的方式。 示例根据SnackBar的特点，在屏幕上显示出不同的SnackBar，效果如下： 先看一下相关的API文档： 方法类型 方法 作用 void dismiss() 使SnackBar消失 int getDuration() 返回SnackBar的持续时间 View getView() 返回当前SnackBar的View boolean isShown() 判断该SnackBar是否正在显示 boolean isShownOrQueued() 判断该SnackBar是否正在显示或者排队等待即将要显示 static Snackbar make(View view, int resId, int duration) 新建一个用来显示信息的SnackBar static Snackbar make(View view, CharSequence text, int duration) 同上 Snackbar setAction(int resId, View.OnClickListener listener) 设置这个即将显示的SnackBar的动作 Snackbar setAction(CharSequence text, View.OnClickListener listener) 同上 Snackbar setActionTextColor(ColorStateList colors) 设置action的文字颜色(右边的) Snackbar setActionTextColor(int color) 同上 Snackbar setCallback(Snackbar.Callback callback) 设置一个回调，当SnackBar的可见性改变的时候调用 Snackbar setDuration(int duration) 设置SnackBar信息的显示时间 Snackbar setText(int resId) 更新SnackBar上显示的文字 Snackbar setText(CharSequence message) 同上 void show() 显示SnackBar，最后一定要调用这个方法，不然SnackBar不显示，联想Toast 可以看到Demo上显示了三种不同的SnackBar，我们都知道SnackBar是Toast的升级版，但也说明了一个问题那就是SnackBar是用来显示消息的，同时根据你的需求不同可以对这些消息做出一定的响应动作，下面分析三种显示消息方式的不同： 普通的SnackBar 也许有的人并没有过多的需求，只是单纯地想把SnackBar当作一个显示消息的控件而已，那么可以很简单的在代码中这么使用： 1Snackbar.make(mCoor, R.string.normal, Snackbar.LENGTH_SHORT).show(); 对比一下我们的Toast方式： 1Toast.makeText(MainActivity.this,R.string.normal,Toast.LENGTH_SHORT).show(); 是不是很像，没错简单的使用的话SnackBar跟Toast并没有多大区别，但是动画效果上是有差异的，如果你注意到了这一点： 看，这个侧边滑动消失的效果只有当你使用CoordinatorLayout作为根布局才有，这就是为什么在写SnackBar之前我要先说明一下CoordinatorLayout的原因，如果你使用普通的LinearLayout或者RelativeLayout是不会有这种动画交互效果的，另外，注意SnackBar的make方法有两种重载方法，分别是： 1make(View view, int resId, int duration) 和 1make(View view, CharSequence text, int duration) 这里有三个参数，第一个参数View表示的意思是我们传入一个View，然后SnackBar会遍历整个View Tree来找到一个合适的View承载SnackBar的View，如果你想要实现上面的动画交互效果的话最好是传入CoordinatorLayout对象，第二个参数的话是两个重载方法不同的地方，有一种是我们熟知的： 1Snackbar.make(mCoor, \"普通的SnackBar\", Snackbar.LENGTH_SHORT).show(); 还有一种要求传入一个ID，注意这个ID并不是指其他的什么，就是你在string.xml文件中定义的字符串资源的ID，比如这样： 1Snackbar.make(mCoor, R.string.normal, Snackbar.LENGTH_SHORT).show(); 然后第三个参数是SnackBar的持续时间，只有三种： 1231、Snackbar.LENGTH_INDEFINITE 一直显示直到另一个SnackBar出现或者主动调用了dismiss()方法2、Snackbar.LENGTH_SHORT 显示较短的时间3、Snackbar.LENGTH_LONG 显示较长的时间 但是官方文档是这么描述的： 1either be one of the predefined lengths: LENGTH_SHORT, LENGTH_LONG, or a custom duration in milliseconds. 说是可以自定义显示时间，但是我自己试了确实不可以，应该是API文档的一个小bug，如果谁试成功了赶紧告诉我~~如果使用过Toast的话上面的应该很好理解，好了，如果你的业务中对SnackBar并没有更多的要求，那么最普通的SnackBar应该满足了，接下来看稍微高级一点的： 带回调的SnackBar： 如果还不太清楚回调的话可以看看这个Android回调函数机制那点事 ，讲这个之前先提一点，如果我们想更加灵活的使用Snackbar的话最好是先持有它的引用，也就是： 1private Snackbar mSnackBar 原因很简单，你会发现上面提供的常用API中很多方法都是非静态方法并不是静态方法，你要调用的话只能通过SnackBar对象去调用。 然后说SnackBar回调之前先说一下Action，SnackBar提供了一个setAction方法： 121、setAction(int resId, View.OnClickListener listener)2、setAction(CharSequence text, View.OnClickListener listener) 同样是两个重载方法，第一个参数跟前面解释的一样，第二个参数是我们熟知的对点击事件的监听，使用方法如下： 1234567Snackbar.make(mCoor,R.string.callback,Snackbar.LENGTH_SHORT) .setAction(R.string.UNDO, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // do something &#125; &#125;).show(); 看一下效果： 当我们调用了setAction方法并且传入一个字符串之后，SnackBar的右下角就会呈现出我们传入的字符串，并且这个字符串是可点击的，我们可以在点击事件里面做出响应，比如说跳转Activity或者弹出一个Toast等等，这里默认你点击了这个Action这个SnackBar是会消失的。也就是无论你的duration参数设置的是一直显示还是显示多长时间都会消失。 有些人可能对右下角这个文字的颜色不满足想要改变，没问题，你想到的Google都给你想好了，SnackBar专门提供了方法来更改Action的文字颜色: 121、setActionTextColor(ColorStateList colors)2、setActionTextColor(int color) 这里第一种方式不建议用，太复杂，你要想这么用也行： 123Resources resource = (Resources) getBaseContext().getResources(); ColorStateList csl = (ColorStateList) resource.getColorStateList(R.color.PeachPuff); mSnackBar.setActionTextColor(csl); 这是网上找到的一种方式，但是我还是推荐使用第二种方式来更改Action的文字颜色，可以看到是我们熟悉的传入一个int型的值，我提供如下几种方式更改： 1231、mSnackBar.setActionTextColor(Color.rgb(232,44,123))2、mSnackBar.setActionTextColor(Color.BLUE)3、mSnackBar.setActionTextColor(Color.parseColor(&quot;#FFDAB9&quot;)); 对了，我还发现一种额外的方式，我们现在使用Android Studio创建新的Project时候系统都会默认在style.xml文件夹下面生成这个： 123456&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; 这里的 1&lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; 其实也可以更改Action文字颜色，而且默认的Action文字颜色就是这里设置的颜色，但是有一个缺点就是如果你改动了这里，那么很多Material Design控件的相关颜色都会改变，如果你看过我之前写的Android Design Support Library–TextInputLayout的使用你会知道TextInputLayout下划线的颜色也是通过这个属性来更改的，所以为了稳定起见还是使用官方提供的方法去更改吧，我这纯属抖个机灵。 那么回到正题，讲讲SnackBar的回调，眼尖的朋友可能发现了，我的Demo里面带回调的SnackBar在弹出和消失的时候都会有Toast通知出现，其实就是使用了SnackBar自带的 1setCallback(Snackbar.Callback callback) 方法，这里需要传入一个Snackbar.Callback callback 参数，其实这个，这个Callback 是SnackBar内部的一个抽象类，它内部有两个空实现的方法： 123onDismissed(Snackbar snackbar, int event)onShown(Snackbar snackbar) 顾名思义，我们可以可以分别在这两个方法中定义出当SnackBar消失和产生时我们需要做的事，这两个方法会在SnackBar消失和产生时被回调，打个比方： 12345678910111213mSnackBar.setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this,\"SnackBar Dismiss\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Toast.makeText(MainActivity.this,\"SnackBar Show\",Toast.LENGTH_SHORT).show(); &#125; &#125;); 这样就实现了在SnackBar消失和产生时弹出Toast通知的动作，其他具体的逻辑可以自己去实现。 完全自定义你自己的SnackBar如果你对上述使用还是不甚满意，那么接下来我教你怎么自定义你自己的SnackBar，说实话用到的场景并不多，但是学了就学个透彻，这一部分知识的灵感来自于没时间解释了，快使用Snackbar! ，SnackBar并没有提供更改背景或者其他样式的方法，但是我们可以通过查看源码来试试可不可以自定义自己样式，我们找到这么一段代码： 12345678910private Snackbar(ViewGroup parent) &#123; mTargetParent = parent; mContext = parent.getContext(); ThemeUtils.checkAppCompatTheme(mContext); LayoutInflater inflater = LayoutInflater.from(mContext); mView = (SnackbarLayout) inflater.inflate( R.layout.design_layout_snackbar, mTargetParent, false);&#125; 最后一行的inflate是不是很熟悉，我们可不可以认为Snackbar的布局就是这么加载的，这个SnackBarLayout是在SnackBar内部定义的一个继承自LinearLayout的内部类： 123456public static class SnackbarLayout extends LinearLayout &#123; private TextView mMessageView; private Button mActionView; private int mMaxWidth; private int mMaxInlineActionWidth; 看到这几个变量的定义，我已经确定了上面的想法，接下来我们找到上面代码加载的那段布局： 12345678910111213141516171819202122232425262728293031&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;&lt;TextView android:id=\"@+id/snackbar_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:paddingTop=\"14dp\" android:paddingBottom=\"14dp\" android:paddingLeft=\"12dp\" android:paddingRight=\"12dp\" android:textAppearance=\"@style/TextAppearance.Design.Snackbar.Message\" android:maxLines=\"2\" android:layout_gravity=\"center_vertical|left|start\" android:ellipsize=\"end\" android:textAlignment=\"viewStart\"/&gt;&lt;Button android:id=\"@+id/snackbar_action\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"0dp\" android:layout_marginStart=\"0dp\" android:layout_gravity=\"center_vertical|right|end\" android:paddingTop=\"14dp\" android:paddingBottom=\"14dp\" android:paddingLeft=\"12dp\" android:paddingRight=\"12dp\" android:visibility=\"gone\" android:textColor=\"?attr/colorAccent\" style=\"?attr/borderlessButtonStyle\"/&gt;&lt;/merge&gt; 看到这两个控件的ID了么 12android:id=\"@+id/snackbar_text\"android:id=\"@+id/snackbar_action\" 那么第一个就是SnackBar左边显示的message，第二个就是我们设置了action时候显示的Button咯，这就简单了，如果你仔细看了上面提供的API文档你会发现有这么一个方法： 123public View getView ()Returns the Snackbar's view. 这个方法可以返回我们SnackBar的View，那么这个View是什么，看源码： 1234567/** * Returns the &#123;@link Snackbar&#125;'s view. */@NonNullpublic View getView() &#123; return mView;&#125; 找一下mView在哪里定义的： 123private final SnackbarLayout mView;mView = (SnackbarLayout) inflater.inflate( R.layout.design_layout_snackbar, mTargetParent, false); 好了，这下一切都清楚了，接下里示范一下怎么自定义你自己的SnackBar： 12345678910111213141516171819private View view; ....省略中间代码 view = mCustomSnackBar.getView(); if (view != null) &#123; view.setBackgroundColor(Color.parseColor(\"#7B68EE\")); //获取Snackbar的message控件，修改字体颜色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(Color.parseColor(\"#FFDAB9\")); //添加图标 Snackbar.SnackbarLayout snackbarLayout = (Snackbar.SnackbarLayout) view; //添加自定义布局，这里布局就包含了一个ImageView //custom_layout是你自定义的布局 View add_view = LayoutInflater.from(view.getContext()).inflate(R.layout.custom_layout, null); LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); p.gravity = Gravity.CENTER_VERTICAL; //数字表示新加的布局在SnackBar中的位置，从0开始,取决于你SnackBar里面有多少个子View snackbarLayout.addView(add_view, 0, p); &#125; 最后一行，addView方法第二个参数表示新加的布局在SnackBar中的位置，注意不要超过总的View的个数不然会报错，message和Action text分别算一个View，其他的话注释已经写得很清楚就不一一解释了，这个代码呈现的效果如下： 为了方便自定义样式，发现这一特性的作者还给我们封装了成为一个工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/** * Created by 赵晨璞 on 2016/5/1. */public class SnackbarUtil &#123;public static final int Info = 1;public static final int Confirm = 2;public static final int Warning = 3;public static final int Alert = 4;public static int red = 0xfff44336;public static int green = 0xff4caf50;public static int blue = 0xff2195f3;public static int orange = 0xffffc107;/** * 短显示Snackbar，自定义颜色 * @param view * @param message * @param messageColor * @param backgroundColor * @return */public static Snackbar ShortSnackbar(View view, String message, int messageColor, int backgroundColor)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_SHORT); setSnackbarColor(snackbar,messageColor,backgroundColor); return snackbar;&#125;/** * 长显示Snackbar，自定义颜色 * @param view * @param message * @param messageColor * @param backgroundColor * @return */public static Snackbar LongSnackbar(View view, String message, int messageColor, int backgroundColor)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_LONG); setSnackbarColor(snackbar,messageColor,backgroundColor); return snackbar;&#125;/** * 自定义时常显示Snackbar，自定义颜色 * @param view * @param message * @param messageColor * @param backgroundColor * @return */public static Snackbar IndefiniteSnackbar(View view, String message,int duration,int messageColor, int backgroundColor)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_INDEFINITE).setDuration(duration); setSnackbarColor(snackbar,messageColor,backgroundColor); return snackbar;&#125;/** * 短显示Snackbar，可选预设类型 * @param view * @param message * @param type * @return */public static Snackbar ShortSnackbar(View view, String message, int type)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_SHORT); switchType(snackbar,type); return snackbar;&#125;/** * 长显示Snackbar，可选预设类型 * @param view * @param message * @param type * @return */public static Snackbar LongSnackbar(View view, String message,int type)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_LONG); switchType(snackbar,type); return snackbar;&#125;/** * 自定义时常显示Snackbar，可选预设类型 * @param view * @param message * @param type * @return */public static Snackbar IndefiniteSnackbar(View view, String message,int duration,int type)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_INDEFINITE).setDuration(duration); switchType(snackbar,type); return snackbar;&#125;//选择预设类型private static void switchType(Snackbar snackbar,int type)&#123; switch (type)&#123; case Info: setSnackbarColor(snackbar,blue); break; case Confirm: setSnackbarColor(snackbar,green); break; case Warning: setSnackbarColor(snackbar,orange); break; case Alert: setSnackbarColor(snackbar,Color.YELLOW,red); break; &#125;&#125;/** * 设置Snackbar背景颜色 * @param snackbar * @param backgroundColor */public static void setSnackbarColor(Snackbar snackbar, int backgroundColor) &#123; View view = snackbar.getView(); if(view!=null)&#123; view.setBackgroundColor(backgroundColor); &#125;&#125;/** * 设置Snackbar文字和背景颜色 * @param snackbar * @param messageColor * @param backgroundColor */public static void setSnackbarColor(Snackbar snackbar, int messageColor, int backgroundColor) &#123; View view = snackbar.getView(); if(view!=null)&#123; view.setBackgroundColor(backgroundColor); ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(messageColor); &#125;&#125;/** * 向Snackbar中添加view * @param snackbar * @param layoutId * @param index 新加布局在Snackbar中的位置 */public static void SnackbarAddView( Snackbar snackbar,int layoutId,int index) &#123; View snackbarview = snackbar.getView(); Snackbar.SnackbarLayout snackbarLayout=(Snackbar.SnackbarLayout)snackbarview; View add_view = LayoutInflater.from(snackbarview.getContext()).inflate(layoutId,null); LinearLayout.LayoutParams p = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT); p.gravity= Gravity.CENTER_VERTICAL; snackbarLayout.addView(add_view,index,p);&#125;&#125; 使用示例如下： 1SnackbarUtil.ShortSnackbar(coordinator,\"妹子向你发来一条消息\",SnackbarUtil.Info).show(); 在此要非常感谢简名 给我们提供这么好的工具类，那么还有什么不懂得可以留言探讨，下面上整个项目的代码： MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.muyang.snackbardemo;import android.graphics.Color;import android.os.Bundle;import android.support.design.widget.CoordinatorLayout;import android.support.design.widget.Snackbar;import android.support.v7.app.AppCompatActivity;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button btn_normal, btn_callback, btn_custom; private CoordinatorLayout mCoor; private Snackbar mSnackBar, mCustomSnackBar; private View view; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initWidget(); mSnackBar = Snackbar.make(mCoor, R.string.callback, Snackbar.LENGTH_SHORT) .setAction(R.string.UNDO, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); //SnackBar回调方法 mSnackBar.setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this,\"SnackBar Dismiss\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Toast.makeText(MainActivity.this,\"SnackBar Show\",Toast.LENGTH_SHORT).show(); &#125; &#125;);// 1、Resources resource = (Resources) getBaseContext().getResources();// ColorStateList csl = (ColorStateList) resource.getColorStateList(R.color.PeachPuff);// mSnackBar.setActionTextColor(csl);// 2、mSnackBar.setActionTextColor(Color.rgb(232,44,123))// 3、mSnackBar.setActionTextColor(Color.BLUE) mSnackBar.setActionTextColor(Color.parseColor(\"#FFDAB9\")); //自定义SnackBar样式 mCustomSnackBar = Snackbar.make(mCoor, R.string.custom, Snackbar.LENGTH_SHORT) .setAction(R.string.UNDO, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); mCustomSnackBar.setActionTextColor(Color.parseColor(\"#FFDAB9\")); //获得SnackBar这个View view = mCustomSnackBar.getView(); if (view != null) &#123; view.setBackgroundColor(Color.parseColor(\"#7B68EE\")); //获取Snackbar的message控件，修改字体颜色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(Color.parseColor(\"#FFDAB9\")); //添加图标 Snackbar.SnackbarLayout snackbarLayout = (Snackbar.SnackbarLayout) view; //custom_layout是你自定义的布局 View add_view = LayoutInflater.from(view.getContext()).inflate(R.layout.custom_layout, null); LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); p.gravity = Gravity.CENTER_VERTICAL; //数字表示新加的布局在SnackBar中的位置，从0开始,取决于你SnackBar里面有多少个子View snackbarLayout.addView(add_view, 0, p); &#125; &#125; private void initWidget() &#123; btn_normal = (Button) findViewById(R.id.btn_normal); btn_normal.setOnClickListener(this); btn_callback = (Button) findViewById(R.id.btn_callback); btn_callback.setOnClickListener(this); btn_custom = (Button) findViewById(R.id.btn_custom); btn_custom.setOnClickListener(this); mCoor = (CoordinatorLayout) findViewById(R.id.coordinatorLayout); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_normal: Snackbar.make(mCoor, R.string.normal, Snackbar.LENGTH_SHORT).show(); break; case R.id.btn_callback:// Snackbar.make(mCoor,R.string.callback,Snackbar.LENGTH_SHORT)// .setAction(R.string.UNDO, new View.OnClickListener() &#123;// @Override// public void onClick(View v) &#123;//// &#125;// &#125;).show(); mSnackBar.show(); break; case R.id.btn_custom: mCustomSnackBar.show();// if (mSnackBar.isShown()) &#123;// mSnackBar.dismiss();// &#125; break; &#125; &#125;&#125; activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/coordinatorLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/btn_normal\" android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"80dp\" android:background=\"@drawable/btn_bg\" android:text=\"@string/normal\" android:textSize=\"15sp\" /&gt; &lt;Button android:id=\"@+id/btn_callback\" android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" android:layout_alignStart=\"@+id/btn_normal\" android:layout_below=\"@+id/btn_normal\" android:layout_marginTop=\"38dp\" android:background=\"@drawable/btn_bg\" android:text=\"@string/callback\" android:textSize=\"15sp\" /&gt; &lt;Button android:id=\"@+id/btn_custom\" android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" android:layout_alignStart=\"@+id/btn_callback\" android:layout_below=\"@+id/btn_callback\" android:layout_marginTop=\"45dp\" android:background=\"@drawable/btn_bg\" android:text=\"@string/custom\" android:textSize=\"15sp\" /&gt; &lt;/RelativeLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; custom_layout.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; &gt; &lt;ImageView android:layout_width=&quot;35dp&quot; android:layout_height=&quot;35dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:src=&quot;@drawable/header&quot;/&gt;&lt;/LinearLayout&gt; 彩蛋SnackBar源码 项目源码项目GitHub地址 参考没时间解释了，快使用Snackbar!Android Material Design Snackbar Example 喜欢Android Design Support Library系列的朋友欢迎关注我的微信公众号未央进化论，第一时间通知博客更新，荆轲刺秦王(＾－＾)","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https:///www.limuyang.cc/tags/Material-Design/"},{"name":"Google","slug":"Google","permalink":"https:///www.limuyang.cc/tags/Google/"},{"name":"Android","slug":"Android","permalink":"https:///www.limuyang.cc/tags/Android/"}]},{"title":"译Android Design Support Library--使用CoordinatorLayout来处理滚动","date":"2016-05-03T12:32:58.000Z","path":"2016/05/03/译Android-Design-Support-Library-使用CoordinatorLayout来处理滚动/","text":"引言本来这一次想写关于SnackBar的，但是因为官方都推荐使用Material Design控件最好使用CoordinatorLayout 来作为它们的父布局，所以就先讲解一下CoordinatorLayout 的知识，本来想自己去理解的，但是发现网上已经有一份很好的材料了就给搬过来了，原文是CodePath的，我给翻译了一遍，如果有出入的话欢迎指正—英文原文地址概述CoordinatorLayout 可以实现在Google Material Design中提到的滚动特效 ，目前，这个框架提供了好几种让你不用去写自定义动画效果代码就能实现的特效，这些特效包括如下几个方面： 可以自动的让浮动按钮上下滑动，来为SnackBar预留出一定的空间 扩大或者缩小ToolBar或者头部来为主要内容布局预留出一定的空间 控制哪一个View需要展开或者折叠以及展开或者折叠的速率，包括视察滚动的动画效果 代码示例 来自Google的Chris Banes已经把CoordinatorLayout和其他Design Support Library 控件结合在一起写了一个Demo。 你可以在GitHub上找到这个Demo的源码，通过这个源码你可以很好的理解CoordinatorLayout的相关知识。 配置首先你得保证你遵循了Design Support Library 规范。 浮动操作按钮和SnackBar CoordinatorLayout可以结合layout_anchor 和layout_gravity 属性来做出浮动特效，想了解更多的话可以查看浮动操作按钮指南 。 当显示一个SnackBar的时候，它通常出现在我们屏幕的底部，为了预留出足够的空间，我们的浮动操作按钮不得不向上移动一段距离： 只要你把CoordinatorLayout作为你的根布局，这个动画效果会自动产生，浮动操作按钮有一个预设的行为属性 ，那就是自动检测SnackBar是否被添加到屏幕上，如果是则浮动操作按钮会产生一个向上移动一个等于SnackBar高度的距离的动画效果。 123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayout android:id=\"@+id/main_content\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rvToDoList\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|right\" android:layout_margin=\"16dp\" android:src=\"@mipmap/ic_launcher\" app:layout_anchor=\"@id/rvToDoList\" app:layout_anchorGravity=\"bottom|right|end\"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 展开或折叠ToolBar 首先要注意的一点是你不是使用已经过时的ActionBar，确保遵守了用ToolBar代替ActionBar 的指南，同样，你也得确保使用CoordinatorLayout作为主布局容器。 1234567891011121314&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 对滚动事件作出响应 接下来，我们需要使用一个叫AppBarLayout的容器布局来为ToolBar添加对滚动事件的响应： 1234567891011121314&lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/detail_backdrop_height\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; 注意：根据Google官方文档 ，AppBarLayout目前被指定为第一个嵌套在CoordinatorLayout里面的子布局。 接下来，我们需要定义出AppBarLayout和滚动视图之间的联系，给RecyclerView 或者任意其他一个可以实现嵌套滚动的View比如说NestedScrollView 添加一个app:layout_behavior 属性，support library包含了一个特殊的同AppBarLayout.ScrollingViewBehavior 一一对应的字符串资源文件@string/appbar_scrolling_view_behavior ，用来通知AppBarLayout 这个特殊的View何时发生了滚动事件，这个behavior 需要建立在触发了这个滚动事件的View上。 12345&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rvToDoList\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; 当一个CoordinatorLayout 发现在RecyclerView中定义了这个属性之后，它会在自己所包含的组件中逐个搜索看是否有与这个behavior相关联的View，在此个别情况中，AppBarLayout.ScrollingViewBehavior 描述了RecyclerView和AppBarLayout中的一种依赖关系，RecyclerView 的任何滚动事件都将会触发AppBarLayout布局或它包含的子View 的改变。要想让RecyclerView 的滚动事件触发AppBarLayout内部声明的View的改变只需要用到app:layout_scrollFlags 这个属性： 12345678910111213&lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_scrollFlags=\"scroll|enterAlways\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; 在app:layout_scrollFlags 属性中我们必须要设定scroll 这个滑动标志来使任何滑动事件生效，这个标志可以配合enterAlways、enterAlwaysCollapsed、exitUntilCollapsed、或者 snap 这几种标志来一起使用。 enterAlways：当向上滑动的时候View就会变为可见，这个标志在你从一个列表的底部向上滚动并且想要立刻显示ToolBar的时候会很有用： 一般情况下，ToolBar只有当你滚动到列表顶部的时候才会显示： enterAlwaysCollapsed：正常情况下，只有当你用了enterAlways这个标志位，你的ToolBar才会随着你的向下滚动继续扩展： 假定你已经声明了enterAlways 标志位，并且你已经制定了一个最小高度minHeight，你还可以指定enterAlwaysCollapsed，这样的话你的View将在达到这个最小高度minHeight时候开始显示，并且随着你的滚动你的View会慢慢的展开直到你滑动到了View的顶部： exitUntilCollapsed：当你已经设置了scroll 标志位，向下滚动会导致整个内容视图产生滚动： 通过指定最小高度minHeight和exitUntilCollapsed标志，ToolBar会隐藏到minHeight的高度： 注意：如果滚动结束View视图尺寸减小少于最开始部分的50%，那么这个View会回到原始大小，但是如果大于原始尺寸的50%的话，那么这个View会完全消失： 记住你所有的View都需要把scroll 标志放在第一位，这样需要折叠的View会先行退出然而固定的元素会留在顶部，此时你应该已经注意到了我们的ToolBar响应滚动事件。 制造出折叠效果 如果我们想做出ToolBar的折叠效果，我们必须使用CollapsingToolbarLayout布局来包裹ToolBar： 1234567891011121314151617&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_scrollFlags=\"scroll|enterAlways\"&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt; 结果显示如下： 通常我们都是设置ToolBar的Title，但是现在我们需要把Title设置在CollapsingToolBarLayout 上： 123CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar);collapsingToolbar.setTitle(\"Title\"); 注意当我们使用CollapsingToolbarLayout的时候，我们的状态栏需要设置为半透明(API 19)或者透明(API 21),就好像这个文件展示的，特别的，我们还需要在res/values-xx/styles.xml 设置如下的style： 12345678910&lt;!-- res/values-v19/styles.xml --&gt;&lt;style name=\"AppTheme\" parent=\"Base.AppTheme\"&gt; &lt;item name=\"android:windowTranslucentStatus\"&gt;true&lt;/item&gt;&lt;/style&gt;&lt;!-- res/values-v21/styles.xml --&gt;&lt;style name=\"AppTheme\" parent=\"Base.AppTheme\"&gt; &lt;item name=\"android:windowDrawsSystemBarBackgrounds\"&gt;true&lt;/item&gt; &lt;item name=\"android:statusBarColor\"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 如果你照着上面来设置，你的布局有一部分会隐藏在system bar后面，这个时候你需要设置android:fitsSystemWindow 属性，详情查看 制造视差滚动动画效果 CollapsingToolbarLayout 布局还允许让我们做出更多更高级的动画效果，譬如在它内部加入一个ImageView，当它折叠的时候这个ImageView会产生一个淡出的效果，当用户滚动的时候title的高度也能随之改变： 为了生成这种效果，我们加入了一个ImageView并且声明了app:layout_collapseMode=&quot;parallax&quot; 属性： 12345678910111213141516171819202122232425&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_scrollFlags=\"scroll|enterAlways\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;ImageView android:src=\"@drawable/cheese_1\" app:layout_scrollFlags=\"scroll|enterAlways|enterAlwaysCollapsed\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" app:layout_collapseMode=\"parallax\" android:minHeight=\"100dp\"/&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt; 自定义Behaviors 一个关于自定义behavior的例子在我们讨论CoordinatorLayou和浮动操作按钮的时候，CoordinatorLayout是通过搜索任意一个包含了 CoordinatorLayout Behavior 的子View来工作的，无论是通过在XML文件中使用app:layout_behavior 属性来定义还是以编码的方式对View类使用@DefaultBehavior 注释，当滚动事件发生的时候，CoordinatorLayout 将会尝试去触发那些声明了依赖的子View。 想要定义你自己的CoordinatorLayout Behavior，你需要实现layoutDependsOn()和onDependentViewChanged() 这两个方法，比如，AppBarLayout.Behavior就定义了这两个关键的方法，这个behavior 用来触发AppBarLayout 的变化当滚动事件发生的时候： 1234567891011public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return dependency instanceof AppBarLayout; &#125; public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; // check the behavior triggered android.support.design.widget.CoordinatorLayout.Behavior behavior = ((android.support.design.widget.CoordinatorLayout.LayoutParams)dependency.getLayoutParams()).getBehavior(); if(behavior instanceof AppBarLayout.Behavior) &#123; // do stuff here &#125; &#125; 理解如何实现这些自定义behavior的最好途径是研究AppBarLayout.Behavior 和 FloatingActionButtion.Behavior。虽然这些源代码还没有放出来，但是你可以使用Android Studio 1.2集成的反编译器来查看。","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https:///www.limuyang.cc/tags/Material-Design/"},{"name":"CoordinatorLayout","slug":"CoordinatorLayout","permalink":"https:///www.limuyang.cc/tags/CoordinatorLayout/"}]},{"title":"Android Design Support Library--TextInputLayout的使用","date":"2016-04-29T16:20:19.000Z","path":"2016/04/30/Android-Design-Support-Library-TextInputLayout的使用/","text":"引言Google在2015的IO大会上，给我们带来了更加详细的Material Design设计规范，同时，也给我们带来了全新的Android Design Support Library，Android Design Support Library的兼容性更广，直接可以向下兼容到Android 2.2，我准备从最简单的控件开始，逐渐延伸，把新控件都给熟悉一遍。先从看起来最简单的控件开始，也就是TextInputLayout，说实话TextInputLayout 我所见到的平常用的并不多，它的大体作用是在我们正常的EditText左上角显示出一个浮动标签，这个标签的内容就是我们设置的android:hint 属性的值。先来看一下它的继承结构： 可以很清晰的看到我们的TextInputLayout 继承于LinearLayout ，那么很明显这是一个布局，需要配合它的子控件来显示出想要的效果，这里谷歌把它专门设计用来包裹EditText(或者EditText的子类)，然后当用户进行输入动作的时候我们设置的android:hint 提示就会以动画的形式运动到左上角，谷歌官方提供的最简单的使用示例如下： 12345678910&lt;android.support.design.widget.TextInputLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.design.widget.TextInputEditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/form_username\"/&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 有些人可能会奇怪，之前说好的TextInputLayout 是用来包裹EditText 的，为什么这里出现了TextInputEditText ，先别急，我们看一下谷歌官方对这个控件的描述： 123A special sub-class of EditText designed for use as a child of TextInputLayout.Using this class allows us to display a hint in the IME when in 'extract' mode. 大意是说，这只是一种特殊的EditText 的子类，用来在&#39;extract&#39; mode 下在输入法编辑器中显示我们的hint提示信息，这里的&#39;extract&#39; mode 其实就是全屏模式，谷歌官方对它的解释是有时候你的输入框的UI界面很大，大的不能与你自己的应用程序的UI结合起来，这时候就可以切换到全屏模式来输入，这么说可能不太明白，上图：比如说，下面这种情况使用的是EditText： 我们看到下面那里输入框已经很大了，然后你点击输入框进行输入，会发现这个现象： 你进入到了全屏模式输入，但是界面上空空如也，对比一下使用TextInputEditText 的情况： 看到左上角的文字了嘛，这是我们在之前设置的android:hint 属性的值，这么一看这两者的区别的就一目了然了，但是说实话TextInputEditText 用到的地方还是很有限的，所以日常开发我们还是使用TextInputLayout 去包裹EditText 来实现浮动标签的功能。 以上图片出处 感谢万能的stackoverflow 常用方法因为它是继承自LinearLayout的所以理论上LinearLayout 有的属性它全都有，这里我们只看有关它本身的属性： 属性名 相关方法 描述 app:counterEnabled setCounterEnabled(boolean) 设置是否显示一个计数器，布尔值 app:counterMaxLength setCounterMaxLength(int) 设置计数器的最大计数数值，整型 app:errorEnabled setErrorEnabled(boolean) 设置是否显示一个错误信息，布尔值 app:hintAnimationEnabled setHintAnimationEnabled(boolean) 设置是否要显示输入状态时候的动画效果，布尔值 app:hintEnabled setHintEnabled(boolean) 设置是否要用这个浮动标签的功能，布尔值 app:hintTextAppearance setHintTextAppearance(int) 设置提示文字的样式(注意这里是运行了动画效果之后的样式) 这里我们通过一个简单的Demo来了解以上这些属性，简单起见我们就做一个登录界面，这个界面长这样： 先上布局文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" tools:context=\"com.test.textinputlayoutdemo.MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginTop=\"65dp\" android:orientation=\"vertical\"&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/layout_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterEnabled=\"true\" app:counterMaxLength=\"5\" app:counterOverflowTextAppearance=\"@style/MyOverflowText\" app:errorTextAppearance=\"@style/MyErrorStyle\"&gt; &lt;EditText android:id=\"@+id/input_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/EnterName\" android:singleLine=\"true\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/layout_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterEnabled=\"true\" app:counterMaxLength=\"11\" app:counterOverflowTextAppearance=\"@style/MyOverflowText\" app:errorTextAppearance=\"@style/MyErrorStyle\"&gt; &lt;EditText android:id=\"@+id/input_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/EnterPassWord\" android:inputType=\"textPassword\" android:singleLine=\"true\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/layout_email\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterOverflowTextAppearance=\"@style/MyOverflowText\" app:errorTextAppearance=\"@style/MyErrorStyle\"&gt; &lt;EditText android:id=\"@+id/input_email\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/EnterEmail\" android:inputType=\"textEmailAddress\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;Button android:id=\"@+id/login\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"50dp\" android:background=\"@color/colorPrimary\" android:text=\"@string/login\" android:textColor=\"#ffffff\" android:textSize=\"20sp\" android:textStyle=\"bold\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText input_name, input_password, input_email; private TextInputLayout layout_name, layout_password, layout_email; private Button btn_login; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initWidget(); &#125; private void initWidget() &#123; input_name = (EditText) findViewById(R.id.input_name); input_password = (EditText) findViewById(R.id.input_password); input_email = (EditText) findViewById(R.id.input_email); layout_name = (TextInputLayout) findViewById(R.id.layout_name); layout_password = (TextInputLayout) findViewById(R.id.layout_password); layout_email = (TextInputLayout) findViewById(R.id.layout_email); btn_login = (Button) findViewById(R.id.login); btn_login.setOnClickListener(this); //添加监听 input_name.addTextChangedListener(new MyTextWatcher(input_name)); input_password.addTextChangedListener(new MyTextWatcher(input_password)); input_email.addTextChangedListener(new MyTextWatcher(input_email)); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.login: canLogin(); break; default: break; &#125; &#125; /** * 判断是否可以登录的方法 */ private void canLogin() &#123; if (!isNameValid()) &#123; Toast.makeText(this, getString(R.string.check), Toast.LENGTH_SHORT).show(); return; &#125; if (!isPasswordValid()) &#123; Toast.makeText(this, getString(R.string.check), Toast.LENGTH_SHORT).show(); return; &#125; if (!isEmailValid()) &#123; Toast.makeText(this, getString(R.string.check), Toast.LENGTH_SHORT).show(); return; &#125; Toast.makeText(this, getString(R.string.login_success), Toast.LENGTH_SHORT).show(); &#125; public boolean isNameValid() &#123; if (input_name.getText().toString().trim().equals(\"\") || input_name.getText().toString().trim().isEmpty()) &#123; layout_name.setError(getString(R.string.error_name)); input_name.requestFocus(); return false; &#125; layout_name.setErrorEnabled(false); return true; &#125; public boolean isPasswordValid() &#123; if (input_password.getText().toString().trim().equals(\"\") || input_password.getText().toString().trim().isEmpty()) &#123; layout_password.setErrorEnabled(true); layout_password.setError(getResources().getString(R.string.error_password)); input_password.requestFocus(); return false; &#125; layout_password.setErrorEnabled(false); return true; &#125; public boolean isEmailValid() &#123; String email = input_email.getText().toString().trim(); if (TextUtils.isEmpty(email) || !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) &#123; layout_email.setErrorEnabled(true); layout_email.setError(getString(R.string.error_email)); layout_email.requestFocus(); return false; &#125; layout_email.setErrorEnabled(false); return true; &#125; //动态监听输入过程 private class MyTextWatcher implements TextWatcher &#123; private View view; private MyTextWatcher(View view) &#123; this.view = view; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; switch (view.getId()) &#123; case R.id.input_name: isNameValid(); break; case R.id.input_password: isPasswordValid(); break; case R.id.input_email: isEmailValid(); break; &#125; &#125; &#125;&#125; 先来看一下最终的实现效果： 可以很明显的看到，当我们同时设置了app:counterEnabled 和app:counterMaxLength 属性时，我们输入的EditText 右下角会出现一个计数器还有一个最大输入字符数的数字显示，我们在输入名字这一栏设置最大输入为5个字符，所以当超过了5个字符的时候，EditText 的整个样式的颜色都会改变以示警告，如果我们只设置了app:counterEnabled 属性的话EditText 右下角一开始会出现一个0，随着输入字符的增多而逐步进行计数，注意如果设置了整个属性我们EditText 布局的高度会有一定的增大，具体的可以自己实践一下。 另外，我们在代码中设置了不同的饿输入类型，如果输入类型错误，我们就可以通过设置app:errorEnabled 来开启错误显示，此时需要通过在代码中调用 setError(string) 方法来设置显示的错误提示文字，当不需要的时候记得设置app:errorEnabled(false) 来取消错误提示，不然错误提示会一直存在。 注意： 当我们使用app:counterMaxLength 这个属性的时候，一定要设置 app:counterOverflowTextAppearance 属性，不然的话程序运行会报错，这个属性是设置当我们输入字符超过限定的个数时候EditText控件整体显示的样式，需要在style.xml文件里面定义一个自己的style，注意我们自定义的style的parent是TextAppearance.AppCompat.Small ，拿我上面的程序举例： 123&lt;style name=\"MyOverflowText\" parent=\"TextAppearance.AppCompat.Small\"&gt; &lt;item name=\"android:textColor\"&gt;#f3672b&lt;/item&gt;&lt;/style&gt; 这样定义好后再在app:counterOverflowTextAppearance 里面设置这个style就行 关于自定义样式有些人可能不喜欢官方提供的默认样式想要自己定义，下面说一下自定义几种样式的方法： 如果你想更改下划线的颜色，只要在style.xml文件里面找到AppTheme： 123456&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; 更改里面的colorAccent属性就行了 如果你想更改错误提示的样式的话，也是在style.xml文件里面，自定义一个style，同样拿上面的程序举例： 123&lt;style name=\"MyErrorStyle\"&gt; &lt;item name=\"android:textColor\"&gt;#ec4722&lt;/item&gt; &lt;/style&gt; 然后在xml文件TextInputLayout控件里面这么设置一下就行了： 1app:errorTextAppearance=&quot;@style/MyErrorStyle&quot; 包括前面提到的设置当输入字符大于我们限定个数字符时的样式，基本上我们可以很好地自定义出自己想要的style了，以上两种不提供演示，都很简单，可以自己去尝试。 最后下一次准备分析SnackBar控件，很多东西说简单也简单，说不简单也不简单，就像做这个Demo我之前光看官方文档根本没有告诉有app:counterOverflowTextAppearance 这个属性的存在，也是一直查资料，还是要亲自去尝试一下才好，下面上源码(注意是AS文件) 参考：Android Material Design Floating Labels for EditText 项目GitHub地址 最后来个小提示，当我们在Android Studio中导入support design开发包的时候，版本号最好和v7包的版本号一致，不然有些时候会出现莫名其妙的错误： 123compile fileTree(dir: 'libs', include: ['*.jar'])compile 'com.android.support:appcompat-v7:23.0.1'compile 'com.android.support:design:23.0.1' 有任何问题欢迎留言探讨~","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https:///www.limuyang.cc/tags/Material-Design/"},{"name":"Google","slug":"Google","permalink":"https:///www.limuyang.cc/tags/Google/"},{"name":"TextInputLayout","slug":"TextInputLayout","permalink":"https:///www.limuyang.cc/tags/TextInputLayout/"}]},{"title":"使用ViewPager动画来做出不一样的引导页","date":"2016-04-16T12:29:26.000Z","path":"2016/04/16/使用ViewPager动画来做出不一样的引导页/","text":"就算Google从很早开始就自带了设置引导页动画的接口，但是就我目前看来市面上使用引导页动画的还是很少的，也不知道是为什么，一想到Material Design的使用率也这么少表示很心塞。首先来看看市面上千篇一律的引导页效果，诺： 很单调对不对，你们没看吐我都看吐了，再看一份加了引导页动画效果的： 有没有瞬间耳目一新的感觉，下面就谈谈如何做出这样的引导页动画。 其实从Android 3.0也就是API 11开始Android就自带了一个PageTransformer接口用来实现ViewPager动画效果并为之加入了setPageTransformer方法来自定义我们自己的动画效果，用的时候很简单： 123456viewpager.setPageTransformer(false, new ViewPager.PageTransformer() &#123; @Override public void transformPage(View page, float position) &#123; // do transformation here &#125;&#125;); 这里setPageTransformer传入了两个参数，第一个布尔型参数表示的意思就是在两个页面切换产生动画效果时候是否要反转一下让下一个页面在上一个页面底下，因为ViewPager默认下一个页面是绘制在上一个页面的上面，这里一般传入true，第二次参数才是重点，这里实现了PageTransformer接口，然后我们所有需要的动画效果都在transformPage这个接口方法里面实现，现在我们来看看这个方法。 我们发现transformPage方法也有两个参数，第一个参数就表示当前显示在屏幕上的Activity或者Fragment，这个不管，后一个参数是重点，这个position并不是我们引导页页面的position，下面借用一张图来说明这个position参数： 图片出处 谷歌官方对这个参数的解释是，这个参数表明了一个给定的页面相对于屏幕中心的位置，并且这个参数随着我们的滑动会动态的变化，最重要的一点是这个position参数是相对于我们的屏幕左边缘来说的，如果当前的页面刚好占满了整个屏幕，就如上图所示的1界面，那么这个页面的position参数就是0，如果一个页面刚从屏幕右边缘划出来，可以理解为上图中页面1和页面2的交界线刚冒头的情况，那么这个页面的position值就是1，如果某个时刻我们把页面1向左滑动一半，导致屏幕中央既有一半页面1显示又有一半页面2显示的时候，这时候页面1的position值就是-0.5，页面2的position值就是0.5，都是相对于左边缘来说的，而且左边缘的值固定是0，就是下面这种情况： 那么知道这个值有什么用呢，其实多亏了这个值我们才能做出更好的动画效果，要知道这个值是动态变化的，有了一个动态变化的值就可以做出动态变化的效果，我们可以看看谷歌是怎么用它的： 1234567891011121314151617181920212223242526272829303132333435363738public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 这份代码的实际效果如下：可以看到很明显的缩放以及透明度的变换，我们看看代码是怎么利用这个position参数的： 123if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); 首先这里判断如果position参数是负无穷到-1的时候，也就是此时这个page划出了屏幕左边缘之外不可见得情况，直接设置为透明的 1234567&#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); 接下里判断如果这个页面的position处于-1到1之间，也就是最极端的情况是这个页面即将向左边滑出屏幕之外，或者说这个页面还在屏幕右边缘即将滑入我们的视线，这时就用到了我们的position参数，这里谷歌把它当成了一个缩放系数来用; 1float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); 这里1 - Math.abs(position)) 的值在0~1之间，并且代码判断了MIN_SCALE和1 - Math.abs(position)) 的大小并取其中的最大值，MIN_SCALE是最上面定义的最小缩放系数，可以看到这一行代码得出来的缩放系数是处于MIN_SCALE和1之间的，然后下面的代码就是根据position位置参数的变化来进行page的水平移动效果，其实ViewPager提供了相当多的方法共给我们去操作，诸如:setScale设置缩放啦，setRotation设置旋转效果，还有这里的setTranslationX设置水平移动效果等等，结合position这个动态变化的参数可以做出很多意想不到的动画，比如下面这个旋转动画：代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RotateDownPageTransformer implements ViewPager.PageTransformer&#123; private static final float ROT_MAX = 20.0f; private float mRot; public void transformPage(View view, float position) &#123; Log.e(\"TAG\", view + \" , \" + position + \"\"); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. ViewHelper.setRotation(view, 0); &#125; else if (position &lt;= 1) // a页滑动至b页 ； a页从 0.0 ~ -1 ；b页从1 ~ 0.0 &#123; // [-1,1] // Modify the default slide transition to shrink the page as well if (position &lt; 0) &#123; mRot = (ROT_MAX * position); ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f); ViewHelper.setPivotY(view, view.getMeasuredHeight()); ViewHelper.setRotation(view, mRot); &#125; else &#123; mRot = (ROT_MAX * position); ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f); ViewHelper.setPivotY(view, view.getMeasuredHeight()); ViewHelper.setRotation(view, mRot); &#125; // Scale the page down (between MIN_SCALE and 1) // Fade the page relative to its size. &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. ViewHelper.setRotation(view, 0); &#125; &#125;&#125; 注意：这里的ViewHelper类需要引用nineoldandroids第三方动画库来实现，具体的东西我都打包好了在最下面有下载链接，需要的自行取用。 更酷炫的效果其实除了对position这个参数进行处理，我们还可以对view进行动画处理，前面提到transformPage这个接口方法第一个参数view就是当前可见的Activity或Fragment，那么我们还可以对这个Activity或Fragment内部的元素进行处理来达到视察动画的效果，一个很好地例子： 12345678910111213141516171819202122232425262728293031323334353637public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] mBlur.setTranslationX((float) (-(1 - position) * 0.5 * pageWidth)); mBlurLabel.setTranslationX((float) (-(1 - position) * 0.5 * pageWidth)); mDim.setTranslationX((float) (-(1 - position) * pageWidth)); mDimLabel.setTranslationX((float) (-(1 - position) * pageWidth)); mCheck.setTranslationX((float) (-(1 - position) * 1.5 * pageWidth)); mDoneButton.setTranslationX((float) (-(1 - position) * 1.7 * pageWidth)); // The 0.5, 1.5, 1.7 values you see here are what makes the view move in a different speed. // The bigger the number, the faster the view will translate. // The result float is preceded by a minus because the views travel in the opposite direction of the movement. mFirstColor.setTranslationX((position) * (pageWidth / 4)); mSecondColor.setTranslationX((position) * (pageWidth / 1)); mTint.setTranslationX((position) * (pageWidth / 2)); mDesaturate.setTranslationX((position) * (pageWidth / 1)); // This is another way to do it &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125;&#125; 工程地址 最后，附上整个项目的地址：项目地址有任何问题可以留言探讨","tags":[{"name":"引导页","slug":"引导页","permalink":"https:///www.limuyang.cc/tags/引导页/"},{"name":"ViewPager","slug":"ViewPager","permalink":"https:///www.limuyang.cc/tags/ViewPager/"},{"name":"动画","slug":"动画","permalink":"https:///www.limuyang.cc/tags/动画/"}]},{"title":"ViewGroup的事件分发机制","date":"2016-04-04T13:08:19.000Z","path":"2016/04/04/ViewGroup的事件分发机制/","text":"引言上一次我在View的事件分发机制里完整的分析了View对于触屏点击事件的分发过程，接下来继续探索之旅，紧接着分析ViewGroup的事件分发机制，ViewGroup其实就是一组View的集合，它也是继承于View的，它本身也可以包含View和ViewGroup，方便起见我们还是延用上一次的布局，不过这一次我们给根布局也设置了点击事件和触摸事件： 1234567891011121314151617181920212223242526public class MainActivity extends Activity implements OnClickListener,OnTouchListener&#123; private RelativeLayout re_Layout; private Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn=(Button) findViewById(R.id.btn); re_Layout=(RelativeLayout) findViewById(R.id.re_layout); btn.setOnClickListener(this); btn.setOnTouchListener(this); re_Layout.setOnClickListener(this); re_Layout.setOnTouchListener(this); &#125; @Override public void onClick(View v) &#123; Log.d(&quot;TAG&quot;, &quot;OnClick--&quot;+v); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(&quot;TAG&quot;, &quot;onTouch--&quot;+event.getAction()+&quot;--&quot;+v); return false; &#125;&#125; 效果图也依旧没有变，现在我们先点击一下Button,查看Log输出： 可以很清楚的看到这里和上一节分析得情况一样：当点击事件发生时onTouch()方法是优先于onClick()方法执行的，并且如果onTouch()返回False既不消耗点击事件那么如果控件设置了setOnClickListener最终是会执行到onClick()方法的，可是我很好奇ViewGroup的点击事件和View的到底有什么区别，点击事件事件的分发到底是从ViewGroup开始还是从View开始的呢，于是我点击了Button以外的空白区域，捕捉到如下信息(注:我的根布局就是RelativeLayout)： 说明根布局也就是Viewroup也是可以响应点击事件的，但是我们点击View的时候为什么没有ViewGroup的Log输出，这是不是说明android事件分发是先传到View的，当View消耗的这个事件它的ViewGroup就无法接收这个事件了呢，为了彻底的谈清楚原因，我们先重写一个ViewGroup，然后重写这个ViewGroup里面的onInterceptTouchEvent(MotionEvent ev)、dispatchTouchEvent(MotionEvent event)还有onTouchEvent(MotionEvent event)这三个方法通过Log输出信息来判断： 123456789101112131415161718192021public class MyLayout extends RelativeLayout&#123; public MyLayout(Context context,AttributeSet attrs) &#123; super(context,attrs); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.d(&quot;TAG&quot;, ev.getAction()+&quot; action&quot;+&quot;MyLayout onInterceptTouchEvent&quot;); return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.d(&quot;TAG&quot;, event.getAction()+&quot; action&quot;+&quot;MyLayout onTouchEvent&quot;); return super.onTouchEvent(event); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;TAG&quot;, ev.getAction()+&quot; action&quot;+&quot;MyLayout dispatchTouchEvent&quot;); return super.dispatchTouchEvent(ev); &#125; 同理我们还需要重写一个Button： 123456789101112131415public class MyButton extends Button&#123; public MyButton(Context context,AttributeSet attrs)&#123; super(context,attrs); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.d(&quot;TAG&quot;, event.getAction()+&quot; action&quot;+&quot;MyButton onTouchEvent&quot;); return super.onTouchEvent(event); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;TAG&quot;, ev.getAction()+&quot; action&quot;+&quot;MyButton dispatchTouchEvent&quot;); return super.dispatchTouchEvent(ev); &#125; //这里注意View是没有onInterceptTouchEvent方法的 效果图是一样的这里就不再贴了，为了验证刚才的想法我们直接点击一下界面上的Button，Log输出如下： 发现了什么，我们点击的是Button,然而这个事件最开始是传到了我们的根布局MyLayout，并且还按照：dispatchTouchEvent、onInterceptTouchEvent、dispatchTouchEvent的顺序执行，紧接着执行View的onTouch()和onTouchEvent()方法，还有一点很奇怪的事只有最开始ACTION_DOWN的时候调用了ViewGroup的onInterceptTouchEvent方法，在后面的ACTION_UP事件派发过程中却没有调用，这里给出一个合理的猜想：一旦一个View开始处理这个触摸事件，那么接下来的ACTION_MOVE和ACTION_UP事件都会交给它去处理，就好比你在公司里面做事，分到你做的事你已经做了一些，那么接下来的事你的完完整整的做好，那么如果做到一半不做了会怎么样(即View不消耗ACTIONDOWN事件)？我们可以大胆的假设如果上级交给你做的事没有做好，那么上级在短期内肯定不敢交代事情给你做了(后续的ACTION_MOVE、ACTION_DOWN事件这个View都接收不到了)，那么究竟如何我们还是从源码看起。 对源码的分析我们已经知道当一个点击操作发生时事件是先传给ViewGroup处理的并且首先执行的是ViewGroup的dispatchTouchEvent,那么我们就先来看看它的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218/** * &#123;@inheritDoc&#125; */ @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 相当长，还是一点点来看，源码这种东西看不懂肯定会觉得很枯燥，所以能弄懂的尽量弄懂，最开始只是一些对View是否可以获得焦点的判断、设置标志位以及初始化一些布尔值，并且在ACTION_DOWN事件产生的时候清楚以外的状态并且准备开始新一轮的手势操作，不重要： 1234567891011121314151617181920212223if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; 先看这一段： 12345678910111213141516// Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 这里首先设立了一个布尔值interception去判断当前ViewGroup是否要拦截View的点击事件，if条件语句中的内容是当产生ACTION_DOWN按下事件或者mFirstTouchTarget != null的时候去判断是否要拦截当前事件，这里主要关注mFirstTouchTarget != null这个点，我们找一找哪个方法跟这个mFirstTouchTarget变量有关，还真给我找到了，看下面：1234567891011private void clearTouchTargets() &#123; TouchTarget target = mFirstTouchTarget; if (target != null) &#123; do &#123; TouchTarget next = target.next; target.recycle(); target = next; &#125; while (target != null); mFirstTouchTarget = null; &#125; &#125; 12345678910111213141516171819202122232425/** * Cancels and clears all touch targets. */ private void cancelAndClearTouchTargets(MotionEvent event) &#123; if (mFirstTouchTarget != null) &#123; boolean syntheticEvent = false; if (event == null) &#123; final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; &#125; for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; resetCancelNextUpFlag(target.child); dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); &#125; clearTouchTargets(); if (syntheticEvent) &#123; event.recycle(); &#125; &#125; &#125; 这两段代码结合起来，在加上在ACTION_DOWN初始时候是调用了cancelAndClearTouchTargets(MotionEvent event)这个方法的，所以我们可以推荐起初这个mFirstTouchTarget 的值是null的，那么mFirstTouchTarget是在哪里赋值的呢，我们在dispatchTouchEvent(MotionEvent ev)接着往下看： 1newTouchTarget = addTouchTarget(child, idBitsToAssign); 我们看到newTouchTarget是在这里赋值的，看一下addTouchTarget方法： 12345678910/** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */ private TouchTarget addTouchTarget(View child, int pointerIdBits) &#123; TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; &#125; 从该方法的内部结构可以看出，mFirstTouchTarget其实是一中单链表结构，如果找到了处理该点击事件的子View那么mFirstTouchTarget就会被赋值并且会指向子元素。这一下弄清楚了回到刚才的那段代码： 123456789101112131415final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 1final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; 这个布尔值是判断子元素是否调用了requestDisallowInterceptTouchEvent这个方法，如果调用了这个布尔值就为True，这里看一眼这个方法的代码： 123456789101112131415161718192021/** * &#123;@inheritDoc&#125; */ public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123; // We&apos;re already in this state, assume our ancestors are too return; &#125; if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125; &#125; 你可以在子View中调用这个方法来让ViewGroup不拦截除了ACTION_DOWN以外的点击事件，这里为什么说是ACTION_DOWN以外呢，因为ViewGroup在分发事件的时候最开始是会重置FLAG_DISALLOW_INTERCEPT这个标志位的，所以无论你有没有在子View中设置requestDisallowInterceptTouchEvent方法都不会影响到ViewGroup去拦截ACTION_DOWN事件的，接着往下看： 1234567891011if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 如果子View没有设置requestDisallowInterceptTouchEvent方法那么就调用ViewGroup的onInterceptTouchEvent(ev)方法，我们找到这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Implement this method to intercept all touch screen motion events. This * allows you to watch events as they are dispatched to your children, and * take ownership of the current gesture at any point. * * &lt;p&gt;Using this function takes some care, as it has a fairly complicated * interaction with &#123;@link View#onTouchEvent(MotionEvent) * View.onTouchEvent(MotionEvent)&#125;, and using it requires implementing * that method as well as this one in the correct way. Events will be * received in the following order: * * &lt;ol&gt; * &lt;li&gt; You will receive the down event here. * &lt;li&gt; The down event will be handled either by a child of this view * group, or given to your own onTouchEvent() method to handle; this means * you should implement onTouchEvent() to return true, so you will * continue to see the rest of the gesture (instead of looking for * a parent view to handle it). Also, by returning true from * onTouchEvent(), you will not receive any following * events in onInterceptTouchEvent() and all touch processing must * happen in onTouchEvent() like normal. * &lt;li&gt; For as long as you return false from this function, each following * event (up to and including the final up) will be delivered first here * and then to the target&apos;s onTouchEvent(). * &lt;li&gt; If you return true from here, you will not receive any * following events: the target view will receive the same event but * with the action &#123;@link MotionEvent#ACTION_CANCEL&#125;, and all further * events will be delivered to your onTouchEvent() method and no longer * appear here. * &lt;/ol&gt; * * @param ev The motion event being dispatched down the hierarchy. * @return Return true to steal motion events from the children and have * them dispatched to this ViewGroup through onTouchEvent(). * The current target will receive an ACTION_CANCEL event, and no further * messages will be delivered here. */ public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; 唔，注释相当长，但是有用的就一个返回值，这里返回False，说明ViewGrup不拦截点击事件，事件可以继续往下传递，这个方法的最后，如果当前界面除了一个ViewGroup没有任何子View，那么此时ViewGroup也会拦截点击事件，就好比一个公司人手不够，公司领导需要亲力亲为一样。接着： 12345// If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; 如果确定拦截或者已经有子View着手处理这个点击事件，那么就开始正常的事件分发流程。 12final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; 这里是通过标志位和ACTION_CANCLE来检查是否cancle，再下去： 1final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; 首先可以看见获取一个boolean变量标记split来标记，默认是true，作用是是否把事件分发给多个子View，这个同样在ViewGroup中提供了public的方法设置，如下： 12345678910public void setMotionEventSplittingEnabled(boolean split) &#123; // TODO Applications really shouldn&apos;t change this setting mid-touch event, // but perhaps this should handle that case and send ACTION_CANCELs to any child views // with gestures in progress when this is changed. if (split) &#123; mGroupFlags |= FLAG_SPLIT_MOTION_EVENTS; &#125; else &#123; mGroupFlags &amp;= ~FLAG_SPLIT_MOTION_EVENTS; &#125; &#125; 这一段摘自：Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇) 1if (!canceled &amp;&amp; !intercepted) &#123; 如果没有取消当前动作并且ViewGroup未拦截事件那么事件就传递到接收了该点击事件的View，接下来是一大段代码预警： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; 嗯，这段代码的逻辑比较清晰，大体上就是遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件，接收的依据有两种：第一种是判断子元素是否在播放动画，第二种是判断点击事件的坐标是否落在子元素的区域内，从这里可以看出来： 12345678910111213if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; 如果子元素满足了这两个条件，点击事件就会交给它处理，接下来这段代码里面有一个很重要的方法： 1234567891011121314151617181920if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; 这里if判断里面这个dispatchTransformedTouchEvent是将Touch事件传递给特定的子View，它实际上在内部是调用了子元素的disPatchTouchEvent方法，找一下它的源码： 1234567891011121314151617181920212223242526272829303132/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don&apos;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; 看这一段内容： 12345if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; 如果传递的child为null就调用父类的dispatchTouchEvent否则就调用子类的dispatchTouchEvent，而上面的代码中child不为null，所以执行子元素的dispatchTouchEvent，如果子元素的dispatchTouchEvent返回的是True，那么含有dispatchTransformedTouchEvent这个方法内部的for循环就不会继续下去，直接跳到这里： 12345mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; 这个地方前面说过是给mFirstTouchTarget赋值的地方，如果情况改变，前面那个dispatchTransformedTouchEvent方法中child返回的是False，那么如果当前ViewGroup会把点击事件传递给下一个子元素进行处理，执行for循环查找下一个子元素，此时mFirstTouchTarget依然未被赋值为null，那么这时候继续查看接下来的代码： 123456789if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; 这一段代码表示当前没有找到可以接收点击事件的View并且我们的mFirstTouchTarget!=null那么就把最开始的TouchTarget赋值给newTouchTarget，最后： 12345// Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); 执行到这里的话有两种情况，一种是ViewGroup里面没有找到子View，另一种就是找到了处理这次点击事件的子View但是这个子View的disPatchTouchEvent返回了False，我们通过前面的分析知道disPatchTouchEvent中是先执行onTouch()方法的，而一般onTouch()方法返回的是False，此时disPatchTouchEvent方法的返回值由onTouchEvent方法决定，出现这种情况说明onTouchEvent返回了False，在以上两种情况下，ViewGroup会自己处理这个点击事件，注意这里这个方法里的child传入的是null，我们前面就知道了传入null会执行handled = super.dispatchTouchEvent(event);也就是说此时交由ViewGroup处理这个事件。而ViewGroup也是View的子类，它里面是没有重写View的onTouchEvent方法的，所以它自身处理点击事件的流程和我们在View的事件分发机制解析里面分析得是一样的，至此ViewGroup的分发事件分析完毕。 总结这次我们只分析了点击Button时的Log输出，下面给出点击空白处的Log输出，可以自己检验一下分析成果： 一些结论 ViewGroup默认不拦截任何事件，Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false View的onTouchEvent默认都会消耗事件(返回true)，除非是不可点击的(clickable和longClicjable同时为false)，View的longClickable属性默认是false的 View的enable属性不会影响onTouchEvent的返回值，哪怕该View为disable的，只要它的clickable和longClickable其中一个为true，那么它的onTouchEvent就返回true 事件传递过程是由外向内的，即事件总是先传给父元素，然后再由父元素分发给子VIew,子View可以通过requestDisallowInterceptTouchEvent来干预父元素的分发过程，但是影响不到ACTION_DOWN事件 参考：Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇) Android事件分发机制完全解析，带你从源码的角度彻底理解(下)","tags":[{"name":"事件分发","slug":"事件分发","permalink":"https:///www.limuyang.cc/tags/事件分发/"},{"name":"回调","slug":"回调","permalink":"https:///www.limuyang.cc/tags/回调/"},{"name":"ViewGroup","slug":"ViewGroup","permalink":"https:///www.limuyang.cc/tags/ViewGroup/"}]},{"title":"View的事件分发机制解析","date":"2016-04-03T14:41:55.000Z","path":"2016/04/03/View的事件分发机制解析/","text":"引言 Android事件构成在Android中，事件主要包括点按、长按、拖拽、滑动等，点按又包括单击和双击，另外还包括单指操作和多指操作。所有这些都构成了Android中的事件响应。总的来说，所有的事件都由如下三个部分作为基础： 按下(ACTION_DOWN) 移动(ACTION_MOVE) 抬起(ACTION_UP) 所有的操作事件首先必须执行的是按下操作（ACTION_DOWN），之后所有的操作都是以按下操作作为前提，当按下操作完成后，接下来可能是一段移动（ACTION_MOVE）然后抬起（ACTION_UP），或者是按下操作执行完成后没有移动就直接抬起。这一系列的动作在Android中都可以进行控制。 这些操作事件都发生在我们手机的触摸屏上面，而我们手机上响应我们各种操作事件的就是各种各样的视图组件也就是View，在Android中，所有的视图都继承于View，另外通过各种布局组件（ViewGroup）来对View进行布局，ViewGroup也继承于View。所有的UI控件例如Button、TextView都是继承于View，而所有的布局控件例如RelativeLayout、容器控件例如ListView都是继承于ViewGroup。所以，我们的事件操作主要就是发生在View和ViewGroup之间。 事件分发的概念所谓点击事件的事件分发，就是当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View(ViewGroup也继承于View),这个传递的过程就叫做分发过程，这个点击事件的分发过程需要三个很重要的方法来共同完成：disPatchTouchEvent、onInterceptTouchEvent、和onTouchEvent。 public boolean disPatchTouchEvent(MotionEvent ev) 用来进行事件的分发，如果事件能够传递给当前的View,那么此方法一定会被调用，Android中所有的点击事件都必须经过这个方法的分发，然后决定是自身消费当前事件还是继续往下分发给子控件处理。返回true表示不继续分发，事件已被消费,返回false则继续往下分发，如果是ViewGroup则分发给onInterceptTouchEvent进行判断是否拦截该事件，这个方法的返回结果受到当前View的onTouchEvent和下级View的disPatchTouchEvent方法的影响，返回结果表示是否消耗当前事件。 public boolean onTouchEvent(MotionEvent ev) 在diaPatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列当中，当前View无法再次接收到事件。 public boolean onInterceptTouchEvent(MotionEvent ev) 是ViewGroup中才有的方法，View中没有，它的作用是负责事件的拦截，返回true的时候表示拦截当前事件，不继续往下分发，交给自身的onTouchEvent进行处理。返回false则不拦截，继续往下传。这是ViewGroup特有的方法，因为ViewGroup中可能还有子View，而在Android中View中是不能再包含子View的(IOS可以)，在上述方法内部被调用，如果当前View拦截了某个事件，那么同一个事件序列中(指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，中间含有不定的ACTION_MOVE事件，最终以ACTION_UP事件结束)此方法不会被再次调用，返回结果表示是否拦截当前事件。 这三个方法可以用如下伪代码表示： 123456789101112public boolean disPathchTouchEvent(MotionEvent ev)&#123;//consume指代点击事件是否被消耗 boolean consume=false; //表示当前父布局要拦截该事件 if(onInterceptTouchEvent(MotionEvent ev))&#123; consume=onTouchEvent(ev); &#125;else&#123; //传递给子元素去处理 child.disPatchTouchEvent(ev); &#125; return consume;&#125; 分析View的事件分发机制 为了简单起见我们先从View的事件分发机制开始分析，然后在分析ViewGroup的，首先我们建一个简单的项目，这个项目里只有一个Button，并且我们给这个Button设置点击事件： 12345678910111213141516&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;Button android:id=\"@+id/btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"100dp\" android:text=\"Click me\" /&gt;&lt;/RelativeLayout&gt; 123456789101112131415161718192021222324252627282930313233343536package com.example.testbtn;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.MotionEvent;import android.view.View;import android.view.View.OnClickListener;import android.view.View.OnTouchListener;import android.widget.Button;public class MainActivity extends Activity implements OnClickListener,OnTouchListener&#123; private Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn=(Button) findViewById(R.id.btn); btn.setOnClickListener(this); btn.setOnTouchListener(this); &#125; @Override public void onClick(View v) &#123; Log.d(\"TAG\", \"OnClick\"); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(\"TAG\", \"onTouch\"+event.getAction()); return false; &#125;&#125; 界面是这样的： 运行这个程序，点击Button，查看Log打印输出的信息： (这里onTouch0代表的是ACTION_DOWN，onTouch1代表的是ACTION_UP，onTouch2表示ACTION_MOVE，因为我们只是稳稳的点击了一下Button所以不会有ACTION_MOVE的Log信息出现) 这样我们可以得到一个初步的结论：onTouch()方法是优先于onClick()执行的，然后我们会发现onTouch()方法有一个很明显的和onClick()方法不同的地方的，那就是它有一个Boolean类型的返回值，如果我们把这个默认为False的返回值改为True会怎么样呢： 发现了什么：onClick()方法没有被执行，这里我们把这种现象叫做点击事件被onTouch()消费掉了，事件不会在继续向onClick()方法传递了，那么事件分发机制最基本的几条我们已经了解了，下面我们来分析产生这种机制的根本原因。 View对点击事件的处理过程首先我们给出一个结论：Android中所有的事件都必须经过disPatchTouchEvent(MotionEvent ev)这个方法的分发，然后决定是自身消费当前事件还是继续往下分发给子控件处理，那么我们就来看看这个disPatchTouchEvent(MotionEvent ev)到底干了什么。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 代码有点多，我们一步步来看： 123456789// If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; 最前面这一段就是判断当前事件是否能获得焦点，如果不能获得焦点或者不存在一个View那我们就直接返回False跳出循环，接下来： 123456789if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; 设置一些标记和处理input与手势等传递，不用管，到这里： 12345678910111213if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; 这里if (onFilterTouchEventForSecurity(event))是用来判断View是否被遮住等，ListenerInfo是View的静态内部类，专门用来定义一些XXXListener等方法的，到了重点： 12345if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; 很长的一个判断，一个个来解释：第一个li肯定不为空，因为在这个If判断语句之前就new了一个li，第二个条件li.mOnTouchListener != null，怎么确定这个mOnTouchListener不为空呢？我们在View类里面发现了如下方法： 1234567/** * Register a callback to be invoked when a touch event is sent to this view. * @param l the touch listener to attach to this view */ public void setOnTouchListener(OnTouchListener l) &#123; getListenerInfo().mOnTouchListener = l; &#125; 意味着只要给控件注册了onTouch事件这个mOnTouchListener就一定会被赋值,接下来(mViewFlags &amp; ENABLED_MASK) == ENABLED是通过位与运算来判断这个View是否是ENABLED的，我们默认控件都是ENABLED的所以这一条也成立，最后一条li.mOnTouchListener.onTouch(this, event)是判断onTouch()的返回值是否为True，我们后面把默认为False的返回值改成了True，所以这一整系列的判断都是True，那么这个disPatchTouchEvent(MotionEvent ev)方法直接就返回了True,那么接下来的代码都不会被执行，我们下面有这么一段代码： 123if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; 最开始我们onTouch()方法的返回值是False的，那么 12345if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; 这里面的判断就不成立，result最开始的默认值也是false，那么此时如果 1onTouchEvent(event) 返回值也是True，那么if (!result &amp;&amp; onTouchEvent(event))这个方法判断条件成立，disPatchTouchEvent(MotionEvent ev)返回True，否则返回False。 这里我们得到两个结论： OnTouchListener的优先级比onTouchEvent要高，联想到刚才的小Demo也可以得出onTouch方法优先于onClick()方法执行(onClick()是在onTouchEvent(event)方法中被执行的这个待会会说到) 如果控件（View）的onTouch返回False或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是ENABLE的情况下会调用onTouchEvent方法，此时dispatchTouchEvent方法的返回值与onTouchEvent的返回值一样。 那么接下来我们就分析dispatchTouchEvent方法里面onTouchEvent的实现,给出onTouchEvent的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 代码还是很多，我们依然一段一段来分析，最前面的一段代码： 12345678910if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; 根据前面的分析我们知道这一段代码是对当前View处于不可用状态的情况下的分析，通过注释我们知道即使是一个不可用状态下的View依然会消耗点击事件，只是不会对这个点击事件作出响应罢了，另外通过观察这个return返回值，只要这个View的CLICKABLE和LONG_CLICKABLE或者CONTEXT_CLICKABLE有一个为True，那么返回值就是True，onTouchEvent方法会消耗当前事件。 看下一段代码： 12345if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; 这段代码的意思是如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent(event)方法，这个onTouchEvent(event)的工作机制看起来和OnTouchListener类似，这里不深入研究。 –《Android开发艺术探索》 下面看一下onTouchEvent中对点击事件的具体处理流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 我们还是一行行来分解： 12345678if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; //省略 &#125; return false; &#125; 这个判断之前描述过不再赘述，如果这个判断不成立直接跳到方法尾部返回False，如果判断成立则继续进入方法内部进行一个switch(event)的判断，这里ACTION_DOWN和ACTION_MOVE都只是进行一些必要的设置与置位，我们主要看ACTION_UP： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; 首先判断了是否被按下 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;接下来判断是不是可以获得焦点，同时尝试去获取焦点： 1234boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; 经过种种判断后我们看到这一行： 123if (!post(mPerformClick)) &#123; performClick(); &#125; 这是判断如果不是longPressed则通过post在UI Thread中执行一个PerformClick的Runnable，也就是performClick方法，这个方法的源码如下： 12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; &#125; 我们发现了什么，那就是当ACTION_UP事件发生时，会触发performClick()方法，如果这个View设置了OnClickListener那么最终会执行到OnClickListener的回调方法onClick(),这也就验证了刚才所说的：onClick()方法是在onTouchEvent内部被调用的。 同我们前面找到mOnTouchListener在哪里赋值的一样，我们也可以找到mOnClickListener在哪里赋值的： 1234567891011121314/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; 我们知道View的LONG_CLICKABLE属性默认是False的，需要的话我们可以自己在xml或者java文件中去设置，但是CLICKABLE的False与True是和具体的View有关的，比如我们知道Button是可点击的，但是TextView默认是不可点击的，但是如果给TextView设置了点击事件，那么根据 123if (!isClickable()) &#123; setClickable(true); &#125; 这几行代码TextView也会被设置为可点击的，同理还有setOnLongClickListener也有这种作用： 1234567891011121314/** * Register a callback to be invoked when this view is clicked and held. If this view is not * long clickable, it becomes long clickable. * * @param l The callback that will run * * @see #setLongClickable(boolean) */ public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l; &#125; 总结到此，View的事件分发机制已经分析完了，整个过程查了许多资料，最主要的是跟着任玉刚老师的《Android开发艺术探索》学习，最后把这个学习的过程记录下来就是这篇博客了，等有时间的时候把ViewGroup的事件分发机制也分析一遍。 主要参考 Android触摸屏事件派发机制详解与源码分析一(View篇) Android事件传递机制 请看后续 ViewGroup的事件分发机制","tags":[{"name":"事件分发","slug":"事件分发","permalink":"https:///www.limuyang.cc/tags/事件分发/"},{"name":"回调","slug":"回调","permalink":"https:///www.limuyang.cc/tags/回调/"}]},{"title":"回调函数机制","date":"2016-04-01T15:12:01.000Z","path":"2016/04/01/回调函数机制/","text":"引言 在Android的学习过程中经常会听到或者见到“回调”这个词，那么什么是回调呢？所谓的回调函数就是：在A类中定义了一个方法，这个方法中用到了一个接口和该接口中的抽象方法，但是抽象方法没有具体的实现，需要B类去实现，B类实现该方法后，它本身不会去调用该方法，而是传递给A类，供A类去调用，这种机制就称为回调。 这么说可能还是有些模模糊糊，接下来我们用类比的方法一步步来看到底该怎么写一个回调函数，因为android回调中最常见的是Button的点击事件的回调，这里以此为参照： 1、在A类中定义一个接口：需要我们在类中定义出一个接口，并且给这个接口定义出一个抽象方法，就像下面这样： 123public interface CallBack&#123; public abstract void work() &#125; 以下是View.java类中定义的响应点击事件的接口： 1234567891011/** * Interface definition for a callback to be invoked when a view is clicked. */ public interface OnClickListener &#123; /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); &#125; 2、在A类中定义出该接口的一个成员变量： 1public CallBack mCallBack 以下是View.java类中获取点击事件接口成员变量的源码：123456/** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ public OnClickListener mOnClickListener; 3、在A类中定义出一个公共方法，可以用来设置这个接口的对象，调用该方法可以给接口对象变量赋值： 123public void setCallBack(CallBack callBack) &#123; this.mCallBack = callBack; &#125; 这里看英文注释也看得出来是什么意思，是不是想到了我们平常使用setOnClickListener(OnClickListener l)的时候呢:1234567891011121314/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; 最后一步，如果说前面的都没问题，但这一步可能更不好理解了，不过没关系，我们先看一下 4、在A类中调用接口对象中的方法： 123public void doWork()&#123; mCallBack.work();&#125; 在View.java中的体现： 123456789101112131415161718/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this);//就是这里 result = true; &#125; else &#123; result = false; &#125; 这里附上整个项目的代码，这里A类映射到实际中使用Employee 这个类来代表： 123456789101112131415161718192021222324public class Employee &#123; /* * 定义回调接口的成员变量 */ private CallBack mCallBack; /* * 声明回调接口 */ public interface CallBack&#123; public abstract void work(); &#125; /* * 设置回调接口对象成员变量 */ public void setCallBack(CallBack callBack) &#123; this.mCallBack = callBack; &#125; /* * 调用回调接口对象中的方法 */ public void doWork() &#123; mCallback.work(); &#125; &#125; 我们在定义出一个B类，就用Boss类吧： 123456789101112public class Boss &#123; private Employee employee; /* * 为Employee设置回调函数, 在这里定义具体的回调方法 */ employee.setCallback(new Employee.Callback() &#123; @Override public void work() &#123; System.out.println(\"work\"); &#125; &#125;); &#125; 如果第一眼看不明白，我们附上我们最常用的Button点击事件的处理的代码，这里Employee 类类比一下就是View类： 123456789101112public class TestCallBack&#123; private Button button; button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //做一些操作 doWork(); &#125; &#125;); &#125; 这时候我们在再回头关于回调的定义： 在A类中定义了一个方法，这个方法中用到了一个接口和该接口中的抽象方法，但是抽象方法没有具体的实现，需要B类去实现，B类实现该方法后，它本身不会去调用该方法，而是传递给A类，供A类去调用 这里回到我们的代码中就是：我们在Employee(View)类中定义了一个接口，接口当中还含有一个抽象方法，这个抽象方法没有具体的实现，当我们需要时候自己去实现这个方法，比如这里的Boss (Button)类，这句话可能难以理解：B类实现该方法后，它本身不会去调用该方法，而是传递给A类，供A类去调用，有些人会想，诶，在onClick()方法中我不是写了具体的实现嘛，其实真的是这样吗，我们接着往下看，我们就来好好的分析一下这个Button点击事件。分析首先，在View类中我们能找到setOnClickListener(OnClickListener l)方法： 123456public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; 这里将OnClickListener赋值给了mOnClickListener，我们想要找到onClick()方法是由View回调而不是Button自己回调的证据，就在这里： 12345678910public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); return true; &#125; return false; &#125; 对此我们的解释是：在父类中我们要用到onClick()方法，但是父类却没有去实现该方法，而是定义了一个方法setOnClickListener(OnClickListener l)，如果子类想要自己能够响应点击事件，则它就必须重写父类的该方法，实现OnClickListener接口和它的onClick()方法。在子类实现该接口和方法后，将其通过参数传递给父类，在父类中执行onClick()方法。那么我们是如何运行到这个OnClick()函数的呢，这里由于涉及到View的事件分发机制不细说，想了解的话网上有很多资料，这里只给出结论，因为我们在TestCallBack这个类中没有实现OnTouchListener这个接口，那么当点击事件发的时候必然会运行到onTouchEvent()这个方法，我们来看一下这个方法： 12345678910111213141516171819202122232425262728293031public boolean onTouchEvent(MotionEvent event) &#123; // 略去无用代码... if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: // 略去无用代码... if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); //重点在这 &#125; &#125; &#125; //略去无用代码.. break; &#125; return true; &#125; return false; &#125; 还记得前面我们在performClick();类里面找到的关于View.java类中对于回调方法onClick的调用么 1li.mOnClickListener.onClick(this);//就是这里 这样我们就完整的了解了整个OnClickListener()接口中体现出来的回调机制总结一下为了实现一个回调方法，首先要先定义一个包含了接口的类，并且这个接口中要有一个抽象方法，这个抽象方法的具体实现由其他类来完成(比如我们响应Button的点击事件，onClick()方法里写上当点击事件产生并且该方法被调用时候需要做的操作，比如显示一些文本信息等等)，最后该方法的回调是之前的包含有抽象方法的那个接口所在的类去调用的，比如说onClick()方法是当点击事件产生之后经过一系列的事件分发在View类中被调用的。这其中的奥秘就是： 回调其实是一种双向调用模式，也就说调用方在接口被调用时也会调用对方的接口，实现方法交还给提供接口的父类处理！ 为什么要用回调 我们都知道Java是一门面向对象的语言，有一句很著名的话就是”万事万物皆为对象”，我们把普通事物的共性抽取出来，而这些共性之中又充斥着特性，每个不同的特性就需要交给特定的情况处理，通过暴露接口方法可以减少很多重复，代码更加优雅。 打个比方，Button、ImageButton等都具有可被点击的共性，但是被点击之后相关事件的处理是不同的，比如说我想我要点击的这个Button弹出一个消息提示，然而我希望我的ImageButton点击之后可以弹出一个Notifaction通知，这个时候回调方法的好处就体现出来了，因为android对外暴露的OnClickListener()接口中含有一个OnClick()方法，你需要怎样的具体实现都由你自己定义，而这个回调方法的所在类View不会管你怎么实现的，它只负责调用这个回调方法，这就是使用回调的好处。主要参考 android中的回调Android中回调函数机制解析","tags":[{"name":"回调","slug":"回调","permalink":"https:///www.limuyang.cc/tags/回调/"},{"name":"分析","slug":"分析","permalink":"https:///www.limuyang.cc/tags/分析/"}]},{"title":"APP启动页的正确配置方式","date":"2016-03-01T12:23:31.000Z","path":"2016/03/01/APP启动页的正确配置方式/","text":"在APP的启动页面(Splash Screen)好多都是等待3秒，好一点的还可以跳过，但是有的跳过也是假的按钮。当然像一些大厂的APP，像网易新闻等启动页面都是广告，人家要收广告费的。但是，对于一些普通的APP，有的也出现等待三秒的启动画面，出现一个大大的logo,好像告诉用户他打开的是什么应用，加深用户的映像，这完全是浪费用户的时间，给用户很差的体验！其实我只想快点进入APP啊！！！而且有些APP启动时候都会出现一个短暂的空白界面，现在我们就来避免这些已知的问题。 你看到在这个APP的启动页面所花费的时间正是APP所初始化配置自己的时间，第一次启动也是这样的，所以第一次是最慢的，但是如果有缓存了，那么每次再打开应该是立即打开了吧 实现一个启动页面(Splash Screen) 实现一个启动页面可能和你想象的有点不一样。这个启动的页面必须是立即准备好的页面，即使是在Activity中加载一个xml页面也要是立刻加载好的。 所以，一般不会用layout来当启动页面。取而代之的是用一个颜色作为你的Activity的主题背景，接下来，在你的res/drawable文件夹下创建一个XML的drawable。 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@color/gray\"/&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 这里，我设置了背景颜色和一张居中的图片。 然后，在主题中，将这个设置为Activity的背景。打开你的styles.xml然后为你的Activity添加一个新的主题。 12345678910 &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt; &lt;style name=\"SplashTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/background_splash&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在你新的SplashTheme中，设置窗口背景属性为我们之前写的XML的drawable，就是layer-list的xml。然后在你的AndroidManifest.xml中配置一下就好了。 123456789&lt;activity android:name=\".SplashActivity\" android:theme=\"@style/SplashTheme\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 最后，在你的SplashActivity.class文件中，编码直接进入主页面就行了。 1234567891011public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = new Intent(this, MainActivity.class); startActivity(intent); finish(); &#125;&#125; 这里发现你并没有为Activity设置layout视图，视图来自于主题！所以，这应该是最快的方法启动页面了（相比较加载layout视图）。如果你一定要通过加载layout来显示页面，可能你初始化完了才跳出页面，这时已经有点迟了，所以，你应该考虑用极短的时间来显示加载layout视图. 正确的打开它 当你完成这些步骤，你就正确的完成了启动页面。","tags":[{"name":"冷热启动","slug":"冷热启动","permalink":"https:///www.limuyang.cc/tags/冷热启动/"},{"name":"app","slug":"app","permalink":"https:///www.limuyang.cc/tags/app/"}]},{"title":"AsyncTask初步解析","date":"2015-12-18T12:26:43.000Z","path":"2015/12/18/AsyncTask初步解析/","text":"AsyncTask – 直接继承与Object类 在API-3中开始就被定义 一、AsyncTask初步介绍 在Android程序开始运行的时候会单独启动一个进程，默认情况下所有这个程序操作都在这个进程中进行。一个Android程序默认情况下只有一个进程，但是一个进程却是可以有许线程的。 在这些线程中，有一个线程叫做UI线程，也叫做Main Thread，除了Main Thread之外的线程都可称为Worker Thread。Main Thread主要负责控制UI页面的显示、更新、交互等。 因此所有在UI线程中的操作要求越短越好，只有这样用户才会觉得操作比较流畅。一个比较好的做法是把一些比较耗时的操作，例如网络请求、数据库操作、 复杂计算等逻辑都封装到单独的线程，这样就可以避免阻塞主线程，这个时候就用到了异步任务类AsyncTask。 AsyncTask 是一个综合Thread 和 Handler的辅助类，并不是通用线程框架的一部分。AsyncTask 是短期后台操作的理想选择（最多几秒钟），如果你需要线程长时间的保持运行，强烈建议你使用 java.util.concurrent 包提供的各种API以满足你的需求，比如：Executor, ThreadPoolExecutor and FutureTask.这里我们只讨论AsyncTask的初步使用。 二、AsyncTask的内部机制 首先我们来看一下AsyncTask的方法定义： 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; 我们可以很明显的看到这里有三个泛型参数，当我们要利用AsyncTask类的时候必须传入如下三个参数： Parms：启动该异步任务的时候传入的参数类型 Progress：当异步任务在后台执行时返回的进度单位，也可以简单的理解为后台任务执行的进度 Result：后台任务执行结束时返回的结果类型Android Developer还告知我们：在某些情况有些泛型不需要被指定，这时我们为了简便可以传入一个空类型的参数： 1private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; ... &#125; 接下来，为了执行一个异步任务我们还需要执行如下几个步骤： onPreExecute()：在UI线程中被执行，通常是用来做任务执行前的准备工作，例如加载一个进度条或者在UI界面上显示一个文本等 doInBackground(Params…)：在onPreExecute()方法完成之后立即被后台进程调用，用于执行一些耗时操作，启动异步任务时执行的Parms参数也会被传递到该方法，在这一方法中我们可以使用publishProgress(Progress…)方法来更新进度信息，并且在该方法内不可以更新UI信息 onProgressUpdate(Progress…)：在UI线程中执行，如果我们在doInBackground(Params…)方法中使用了publishProgress(Progress…)那么进度信息将可以以进度条或者Log的形式显示在UI组件上 onPostExecute(Result)：在UI线程中执行，当后台任务操作结束之后该方法会被执行，doInBackground(Params…)方法计算得到的结果将作为该方法的输入参数来进行一些UI更新的操作 取消AsyncTask任务操作 我们可以在异步任务执行的任何时候通过调用cancel(boolean )方法来取消；我们在cancel(boolean)方法中传入true参数则表明取消正在执行的任务，如果调用成功，那么之后我们使用isCancelled()方法来判断任务是否被取消的时候都会返回true，取消之后在执行完doInBackground(Object[])后onCancelled(Object)方法会代替onPostExecute(Object)方法被执行。为了确保能够尽快的取消一个任务，我们应该在doInBackground(Object[])里面周期性的检查isCancelled()的返回值(例如在一个循环里面) 注意事项 AsyncTask 类必须在UI主线程中被加载,从Android4.1开始系统上已经帮我们自动完成这一点 AsyncTask类的实例必须在UI线程中进行创建 execute(Params…) 必须在UI主线程中被调用 不要手动的去调用 onPreExecute(), onPostExecute(Result), doInBackground(Params…), onProgressUpdate(Progress…)这些方法 任务只能被执行一次(如果执行第二次则抛出一个异常) 三、AsyncTask的使用 下面给出一个关于AsyncTask的使用的Demo，布局只有两个Button、一个TextView和一个ProgressBar，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ProgressBar android:id=\"@+id/progressBar\" android:layout_width=\"match_parent\" android:layout_height=\"25dp\" android:layout_centerInParent=\"true\" android:layout_margin=\"5dip\" android:layout_marginTop=\"60dp\" android:background=\"@drawable/btn_style\" android:indeterminate=\"false\" android:indeterminateOnly=\"false\" android:max=\"100\" android:progress=\"0\" android:progressDrawable=\"@drawable/bakground_progress\" /&gt; &lt;Button android:id=\"@+id/Cancle\" android:layout_width=\"100dp\" android:layout_height=\"wrap_content\" android:layout_alignRight=\"@+id/progressBar\" android:layout_below=\"@+id/progressBar\" android:layout_marginRight=\"24dp\" android:background=\"@drawable/btn_style\" android:text=\"Cancle\" android:textColor=\"#ffffff\" android:textStyle=\"bold\" /&gt; &lt;Button android:id=\"@+id/Execute\" android:layout_width=\"100dp\" android:layout_height=\"wrap_content\" android:layout_alignLeft=\"@+id/progressBar\" android:layout_below=\"@+id/progressBar\" android:layout_marginLeft=\"42dp\" android:background=\"@drawable/btn_style\" android:text=\"Excuse\" android:textColor=\"#ffffff\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/tv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/progressBar\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"31dp\" android:text=\"AsyncTask测试\" android:textSize=\"20sp\" android:textColor=\"#000000\" android:textStyle=\"bold\" /&gt;&lt;/RelativeLayout&gt; 结构相对简单，接下里让我们看看TestAsyncTask.java的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.example.testasynctask;import android.app.Activity;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;public class TestAsyncTask extends Activity &#123; private Button execute, cancle; private ProgressBar progressBar; private TextView tv; private TestAsyncTaskProgressBar testAsyncTaskProgressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); execute = (Button) findViewById(R.id.Execute); tv = (TextView) findViewById(R.id.tv); progressBar = (ProgressBar) findViewById(R.id.progressBar); execute.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /** * 这里注意新建的任务只能执行一次，否则会出现异常 */ testAsyncTaskProgressBar = new TestAsyncTaskProgressBar(); testAsyncTaskProgressBar.execute(); execute.setEnabled(false); cancle.setEnabled(true); &#125; &#125;); cancle = (Button) findViewById(R.id.Cancle); cancle.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /** * 使用该方法可以尝试取消正在执行的任务 */ testAsyncTaskProgressBar.cancel(true); &#125; &#125;); &#125; /** * 要使用AsyncTask必须创建它的子类，并且该子类至少需要覆盖doInBackground(Params...)方法 */ class TestAsyncTaskProgressBar extends AsyncTask&lt;Void, Integer, Void&gt; &#123; /** * 当onPreExecute()方法结束执行时该方法立即在后台执行，用于进行一些耗时的操作，并且在执行后台操作的同时 * 还可以通过publishProgress * (Progress...)将执行进度实时传送到UI线程，利用onProgressUpdate(Progress...)方法 * 可以进行动态展示，而且在该方法内不允许修改UI */ @Override protected Void doInBackground(Void... params) &#123; while (!isCancelled() &amp;&amp; progressBar.getProgress() &lt; 100) &#123; publishProgress(new Integer(5)); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; /** * 该方法在UI线程中被执行，主要用在执行后台操作之前做一些UI操作譬如显示一个进度条 */ @Override protected void onPreExecute() &#123; super.onPreExecute(); tv.setText(\"开始执行\"); &#125; /** * 后台任务执行完毕之后该方法立即执行，后台任务执行结果的参数会被传递到该方法中 */ @Override protected void onPostExecute(Void result) &#123; super.onPostExecute(result); tv.setText(\"执行完毕\"); &#125; /** * 当publishProgress(Progress...)方法被执行的时候被调用，并且接受传入第二个参数 */ @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); progressBar.setProgress(progressBar.getProgress() + values[0]); &#125; /** * cancel(boolean)方法被调用并且doInBackground(Object[])方法执行完毕时执行 */ @Override protected void onCancelled() &#123; super.onCancelled(); tv.setText(\"执行中断\"); progressBar.setProgress(0); execute.setEnabled(true); cancle.setEnabled(false); &#125; &#125;&#125; 总体执行效果如下：AsyncTask Demo源码 参考链接： http://blog.csdn.net/ahuier/article/details/16953793 http://blog.csdn.net/liuhe688/article/details/6532519","tags":[{"name":"异步IO","slug":"异步IO","permalink":"https:///www.limuyang.cc/tags/异步IO/"},{"name":"AsyncTask","slug":"AsyncTask","permalink":"https:///www.limuyang.cc/tags/AsyncTask/"}]},{"title":"Android系统架构解析","date":"2015-10-14T12:21:11.000Z","path":"2015/10/14/Android系统架构解析/","text":"Andriod是什么？首先，就像Android开源和兼容性技术负责人Dan Morrill在Android开发手册兼容性部分所解释的，“Android并不是传统的Linux风格的一个规范或分发版本，也不是一系列可重用的组件集成，Android是一个用于连接设备的软件块。” Linux：所有东西的底层是一个稳定的保持更新的Linux内核（我现在用的Nexus手机所用的就是2.6.32版的内核），以及我们精心打造的能源管理组件；当然还有将它们整合至上层Linux代码的扩展和公共组件。 Dalvik：Android另一个重要的部分，包括虚拟机和一组重要的运行环境。它的设计非常巧妙，是个很好的一个手机终端的底层应用。 代码如何生成？Dalvik虚拟机只执行.dex的可执行文件。当Java程序通过编译，最后还需要通过SDK中的工具转化成.dex格式才能在虚拟机上执行。 我需要强调的是，Android应用本身就可视作可在平台上运行并调用APIs的代码，所以对代码如何生成不需特别看重。 特别的Apps：在图中有些基于Dalvik虚拟机的Apps看起来像是Android的一部分，其实是由Google提供，这些应用包括Dialer、Contact、Calendar、Gmail和Chat等。它们中的绝大部分是开源并可复用的。只有少部分例外，比如Google Maps和Android Market. 开源那些事：在下面的图中，绿色的大部分组件是基于Apache许可证开源，其余基于GPL、LGPL和BSD。 Android框架在Android开发者网（developer.android.com）上已有不少篇幅来帮助你使用它，在此就不再累述 App里面是什么一个Android App包含在一个我们称之为APK的压缩文件夹中，APK并没有什么可说的，需要注意的是Android Manifest——介于App和Android System的接口。 标准库在这里“标准”是指“开发者在开源环境中一般可以使用的”。 其他大多数应用是基于Dalvik的，我指的是除了游戏之外的应用。游戏开发者通常希望用C/C++来编写，排斥使用虚拟机，所以他们可以通过Andriod NDK来开发 Android架构详解 显而易见的，根据上图自底向上我们知道Android系统架构包含5大部分:Linux Kernel(Linux内核) 、Libraries(库)、Android Runtime（ART）、Application framework(应用程序框架层)、application(应用程序层) 。 下面将依次了解这5部分： 1、Linux Kernel Android基于Linux 2.6提供核心系统服务，例如：安全、内存管理、进程管理、网络堆栈、驱动模型。Linux Kernel也作为硬件和软件之间的抽象层，它隐藏具体硬件细节而为上层提供统一的服务。 如果你学过计算机网络知道OSI/RM，就会知道分层的好处就是使用下层提供的服务而为上层提供统一的服务，屏蔽本层及以下层的差异，当本层及以下层发生了变化不会影响到上层。也就是说各层各司其职，各层提供固定的SAP（Service Access Point），专业点可以说是高内聚、低耦合。 如果你只是做应用开发，就不需要深入了解Linux Kernel层 2、Android RuntimeAndroid包含一个核心库的集合，提供大部分在Java编程语言核心类库中可用的功能。每一个Android应用程序是Dalvik虚拟机中的实例，运行在他们自己的进程中。Dalvik虚拟机设计成，在一个设备可以高效地运行多个虚拟机。Dalvik虚拟机可执行文件格式是.dex，dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。 大多数虚拟机包括JVM都是基于栈的，而Dalvik虚拟机则是基于寄存器的。两种架构各有优劣，一般而言，基于栈的机器需要更多指令，而基于寄存器的机器指令更大。dx 是一套工具，可以將 Java .class 转换成 .dex 格式。一个dex文件通常会有多个.class。由于dex有時必须进行最佳化，会使文件大小增加1-4倍，以ODEX结尾。 Dalvik虚拟机依赖于Linux 内核提供基本功能，如线程和底层内存管理。 Android给我们提供了一组C/C++库，为平台的不同组件所使用，比如媒体框架；而Android Runtime则由Android核心库集 + Dalvik虚拟机构成，Dalvik虚拟机是针对移动设备的虚拟机，它的特点:不需要很快的CPU计算速度和大量的内存空间;而每个App都单独地运行在单独的Dalvik虚拟机内每个app对于一条Dalvik进程）而他的简单运行流程如： () 3、、LibrariesAndroid包含一个C/C++库的集合，供Android系统的各个组件使用。这些功能通过Android的应用程序框架（application framework）暴露给开发者。下面列出一些核心库： 系统C库——标准C系统库（libc）的BSD衍生，调整为基于嵌入式Linux设备媒体库——基于PacketVideo的OpenCORE。这些库支持播放和录制许多流行的音频和视频格式，以及静态图像文件，包括MPEG4、 H.264、 MP3、 AAC、 AMR、JPG、 PNG界面管理——管理访问显示子系统和无缝组合多个应用程序的二维和三维图形层LibWebCore——新式的Web浏览器引擎,驱动Android 浏览器和内嵌的web视图SGL——基本的2D图形引擎3D库——基于OpenGL ES 1.0 APIs的实现。库使用硬件3D加速或包含高度优化的3D软件光栅FreeType ——位图和矢量字体渲染SQLite ——所有应用程序都可以使用的强大而轻量级的关系数据库引擎 4、Application Framework通过提供开放的开发平台，Android使开发者能够编制极其丰富和新颖的应用程序。开发者可以自由地利用设备硬件优势、访问位置信息、运行后台服务、设置闹钟、向状态栏添加通知等等，很多很多。 开发者可以完全使用核心应用程序所使用的框架APIs。应用程序的体系结构旨在简化组件的重用，任何应用程序都能发布他的功能且任何其他应用程序可以使用这些功能（需要服从框架执行的安全限制）。这一机制允许用户替换组件。 所有的应用程序其实是一组服务和系统，包括： 视图——丰富的、可扩展的视图集合，可用于构建一个应用程序。包括包括列表、网格、文本框、按钮，甚至是内嵌的网页浏览器 内容提供者（Content Providers）——使应用程序能访问其他应用程序（如通讯录）的数据，或共享自己的数据 资源管理器（Resource Manager）——提供访问非代码资源，如本地化字符串、图形和布局文件 通知管理器（Notification Manager）——使所有的应用程序能够在状态栏显示自定义警告 活动管理器（Activity Manager）——管理应用程序生命周期,提供通用的导航回退功能 5、Applications Android装配一个核心应用程序集合，包括电子邮件客户端、SMS程序、日历、地图、浏览器、联系人和其他设置。所有应用程序都是用Java编程语言写的。更加丰富的应用程序有待我们去开发！ 总结 从上面我们知道Android的架构是分层的，非常清晰，分工很明确。Android本身是一套软件堆叠(Software Stack)，或称为「软件叠层架构」，叠层主要分成三层：操作系统、中间件、应用程序。从上面我们也看到了开源的力量，一个个熟悉的开源软件在这里贡献了自己的一份力量。","tags":[{"name":"Android","slug":"Android","permalink":"https:///www.limuyang.cc/tags/Android/"},{"name":"架构","slug":"架构","permalink":"https:///www.limuyang.cc/tags/架构/"}]}]