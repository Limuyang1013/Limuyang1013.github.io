[{"title":"阅读分析React-Redux源码","date":"2019-06-19T16:57:44.000Z","path":"2019/06/19/阅读分析React-Redux源码/","text":"redux作为大型应用的状态管理工具，如果想配合react使用，需要借助react-redux。 redux主要完成两件事情： 通过context从root向下传入store，保证数据的单项流动的同时也方便了子组件从store上获取数据 当应用状态发生变化，触发subscribe方法进行监听，实现相关逻辑 在React 16.4.0之前，React官方是不推荐使用context的，原因在于，当context中的值刷新的时候，是从上到下刷新的，如果中间有组件的shouldComponentUpdate返回了false，这个组件下面的组件就收不到更新后的值；而React-Redux实现了订阅发布的模式，保证使用了store的组件在数据更新的时候可以得到通知。在React 16.4.0之后官方将createContext暴露出来了，以上的问题不会出现，但是是不是意味着，可以用context来替代redux呢？理论上是可以的，但是并不推荐这样做，因为在redux的发展中，其生态系统是非常繁荣的，用Redux能避免重复造轮子的窘境。引自：http://cuteshilina.com/2019/01/19/HowReactReduxWorks/#我们为什么需要react-redux看一眼React-Redux的目录结构： 1234567891011121314151617├── components│ ├── Context.js│ ├── Provider.js│ └── connectAdvanced.js├── connect│ ├── connect.js│ ├── mapDispatchToProps.js│ ├── mapStateToProps.js│ ├── mergeProps.js│ ├── selectorFactory.js│ ├── verifySubselectors.js│ └── wrapMapToProps.js├── index.js└── utils ├── isPlainObject.js ├── shallowEqual.js ├── verifyPlainObject.js 入口在index.js： Index123456import Provider from './components/Provider'import connectAdvanced from './components/connectAdvanced'import &#123; ReactReduxContext &#125; from './components/Context'import connect from './connect/connect'export &#123; Provider, connectAdvanced, ReactReduxContext, connect &#125; 可以看到入口只是对外输出了Provider、connenct、connectedAdvanced三个方法，我们常用的是前面两种方法。 先看Provider。 Provider1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import &#123; ReactReduxContext &#125; from './Context'class Provider extends Component &#123; constructor(props) &#123; super(props) // 获取store const &#123; store &#125; = props this.state = &#123; storeState: store.getState(), store &#125; &#125; componentDidMount() &#123; // 判断是否挂载的flag this._isMounted = true this.subscribe() &#125; componentWillUnmount() &#123; if (this.unsubscribe) this.unsubscribe() this._isMounted = false &#125; componentDidUpdate(prevProps) &#123; if (this.props.store !== prevProps.store) &#123; if (this.unsubscribe) this.unsubscribe() this.subscribe() &#125; &#125; subscribe() &#123; const &#123; store &#125; = this.props this.unsubscribe = store.subscribe(() =&gt; &#123; // 获取最新的state const newStoreState = store.getState() if (!this._isMounted) &#123; return &#125; // 更新storeState this.setState(providerState =&gt; &#123; // If the value is the same, skip the unnecessary state update. if (providerState.storeState === newStoreState) &#123; return null &#125; return &#123; storeState: newStoreState &#125; &#125;) &#125;) // Actions might have been dispatched between render and mount - handle those const postMountStoreState = store.getState() if (postMountStoreState !== this.state.storeState) &#123; this.setState(&#123; storeState: postMountStoreState &#125;) &#125; &#125; render() &#123; const Context = this.props.context || ReactReduxContext return ( &lt;Context.Provider value=&#123;this.state&#125;&gt; &#123;this.props.children&#125; &lt;/Context.Provider&gt; ) &#125;&#125;Provider.propTypes = &#123; store: PropTypes.shape(&#123; subscribe: PropTypes.func.isRequired, dispatch: PropTypes.func.isRequired, getState: PropTypes.func.isRequired &#125;), context: PropTypes.object, children: PropTypes.any&#125;export default Provider 我们在使用Provider的时候只需要把Store传入，通过Context这个API来实现全局注入Store，除了使用默认的Context之外我们也可以使用自定义的Context，看一下默认的实现：12345import React from 'react'export const ReactReduxContext = React.createContext(null)export default ReactReduxContext 回到Provider.js，在初始化阶段利用state去存储store及其对应的state信息，在componentDidMount周期调用subscribe方法添加订阅以便于在每次dispatch action的时候可以更新当前state里面的storeState，同时这个方法会返回一个用于取消当前订阅的函数，在componentWillUnmount时候执行。可以看到Provider做的工作其实比较简单，事实上也是如此，主要的工作在connect.js。 Connect123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import connectAdvanced from '../components/connectAdvanced'import shallowEqual from '../utils/shallowEqual'import defaultMapDispatchToPropsFactories from './mapDispatchToProps'import defaultMapStateToPropsFactories from './mapStateToProps'import defaultMergePropsFactories from './mergeProps'import defaultSelectorFactory from './selectorFactory'/* connect is a facade over connectAdvanced. It turns its args into a compatible selectorFactory, which has the signature: (dispatch, options) =&gt; (nextState, nextOwnProps) =&gt; nextFinalProps connect passes its args to connectAdvanced as options, which will in turn pass them to selectorFactory each time a Connect component instance is instantiated or hot reloaded. selectorFactory returns a final props selector from its mapStateToProps, mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps, mergePropsFactories, and pure args. The resulting final props selector is called by the Connect component instance whenever it receives new props or store state. */function match(arg, factories, name) &#123; for (let i = factories.length - 1; i &gt;= 0; i--) &#123; const result = factories[i](arg) if (result) return result &#125; return (dispatch, options) =&gt; &#123; throw new Error( `Invalid value of type $&#123;typeof arg&#125; for $&#123;name&#125; argument when connecting component $&#123; options.wrappedComponentName &#125;.` ) &#125;&#125;function strictEqual(a, b) &#123; return a === b&#125;// createConnect with default args builds the 'official' connect behavior. Calling it with// different options opens up some testing and extensibility scenariosexport function createConnect(&#123; connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, // 根据传入的mapStateToProp参数类型来决定调用什么方法 mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, // 根据传入的mapDispatchToProps参数类型来决定调用什么方法 mergePropsFactories = defaultMergePropsFactories, // 如果不传调用默认的mergeProps方法，否则使用自定义的mergeProps方法 selectorFactory = defaultSelectorFactory // 计算mapStateToProps，mapDispatchToProps, ownProps的结果&#125; = &#123;&#125;) &#123; return function connect( mapStateToProps, mapDispatchToProps, mergeProps, &#123; pure = true, // 设为true表示我们假设这个组件的状态除了从props传入之外不依赖于外界输入以及自身的state，此时connect只会对相关的state/props进行浅比较以避免重新渲染 areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, ...extraOptions &#125; = &#123;&#125; ) &#123; // 根据传入的参数的类型不同Object/Function调用对应的factory方法来返回对应的函数 const initMapStateToProps = match( mapStateToProps, mapStateToPropsFactories, 'mapStateToProps' ) const initMapDispatchToProps = match( mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps' ) const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps') return connectHOC(selectorFactory, &#123; // used in error messages methodName: 'connect', // used to compute Connect's displayName from the wrapped component's displayName. getDisplayName: name =&gt; `Connect($&#123;name&#125;)`, // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes // 如果没有传mapStateToProps将不会监听state的变化 shouldHandleStateChanges: Boolean(mapStateToProps), // passed through to selectorFactory // 传递给selectFactory的参数 initMapStateToProps, initMapDispatchToProps, initMergeProps, pure, areStatesEqual, areOwnPropsEqual, areStatePropsEqual, areMergedPropsEqual, // any extra options args can override defaults of connect or connectAdvanced ...extraOptions &#125;) &#125;&#125;export default createConnect() 要看懂connect.js需要结合connectAdvanced.js一起，因为后者是前者的基础，这个函数会将React组件和Redux Store链接在一起，但是这个方法不会去处理如何将state、ownProps等组合到props里面，决定其行为的还是connect.js。 通过export default createConnect()可以知道connect.js对外输出的是我们平常使用的connect方法，这个方法接受mapStateToProps、mapDispatchToProps、mergeProps等主要参数以及一些可选参数。 紧接着，通过match方法，根据我们传入的参数类型不同，调用不同的xxfactory方法，以mapStateToProps为例，我们可以选择传入一个函数或者不传，会得到不同的调用结果： 12345678910111213import &#123; wrapMapToPropsConstant, wrapMapToPropsFunc &#125; from './wrapMapToProps'export function whenMapStateToPropsIsFunction(mapStateToProps) &#123; return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : undefined&#125;export function whenMapStateToPropsIsMissing(mapStateToProps) &#123; return !mapStateToProps ? wrapMapToPropsConstant(() =&gt; (&#123;&#125;)) : undefined&#125;export default [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing] 如果不传mapStateToProps会调用wrapMapToPropsConstant方法，该方法以一个返回空对象的函数作为参数，最后其实还是返回一个空对象： 1234567891011export function wrapMapToPropsConstant(getConstant) &#123; return function initConstantSelector(dispatch, options) &#123; const constant = getConstant(dispatch, options) function constantSelector() &#123; return constant &#125; constantSelector.dependsOnOwnProps = false return constantSelector &#125;&#125; 否则的话就调用wrapMapToPropsFunc方法： 1234567891011121314151617181920212223242526272829303132333435export function wrapMapToPropsFunc(mapToProps, methodName) &#123; return function initProxySelector(dispatch, &#123; displayName &#125;) &#123; const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) &#123; return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch) &#125; // allow detectFactoryAndVerify to get ownProps proxy.dependsOnOwnProps = true proxy.mapToProps = function detectFactoryAndVerify( stateOrDispatch, ownProps ) &#123; proxy.mapToProps = mapToProps // 检查是否订阅了ownProps proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps) let props = proxy(stateOrDispatch, ownProps) if (typeof props === 'function') &#123; proxy.mapToProps = props proxy.dependsOnOwnProps = getDependsOnOwnProps(props) props = proxy(stateOrDispatch, ownProps) &#125; if (process.env.NODE_ENV !== 'production') verifyPlainObject(props, displayName, methodName) return props &#125; return proxy &#125;&#125; 这里会返回一个名为initProxySelector的接受dispatch作为参数的函数，关于这个函数细节待会回来看，先回到connect.js，接着往下看。 在做完上述工作后，直接将所有参数传入connectHOC，所以我们要看一下connectHOC做了什么： connectAdvanced123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285import hoistStatics from 'hoist-non-react-statics'import invariant from 'invariant'import React, &#123; Component, PureComponent &#125; from 'react'import &#123; isValidElementType, isContextConsumer &#125; from 'react-is'import &#123; ReactReduxContext &#125; from './Context'const stringifyComponent = Comp =&gt; &#123; try &#123; return JSON.stringify(Comp) &#125; catch (err) &#123; return String(Comp) &#125;&#125;export default function connectAdvanced( /* selectorFactory is a func that is responsible for returning the selector function used to compute new props from state, props, and dispatch. For example: export default connectAdvanced((dispatch, options) =&gt; (state, props) =&gt; (&#123; thing: state.things[props.thingId], saveThing: fields =&gt; dispatch(actionCreators.saveThing(props.thingId, fields)), &#125;))(YourComponent) Access to dispatch is provided to the factory so selectorFactories can bind actionCreators outside of their selector as an optimization. Options passed to connectAdvanced are passed to the selectorFactory, along with displayName and WrappedComponent, as the second argument. Note that selectorFactory is responsible for all caching/memoization of inbound and outbound props. Do not use connectAdvanced directly without memoizing results between calls to your selector, otherwise the Connect component will re-render on every state or props change. */ selectorFactory, // options object: &#123; // the func used to compute this HOC's displayName from the wrapped component's displayName. // probably overridden by wrapper functions such as connect() getDisplayName = name =&gt; `ConnectAdvanced($&#123;name&#125;)`, // shown in error messages // probably overridden by wrapper functions such as connect() methodName = 'connectAdvanced', // REMOVED: if defined, the name of the property passed to the wrapped element indicating the number of // calls to render. useful for watching in react devtools for unnecessary re-renders. renderCountProp = undefined, // determines whether this HOC subscribes to store changes shouldHandleStateChanges = true, // REMOVED: the key of props/context to get the store storeKey = 'store', // REMOVED: expose the wrapped component via refs withRef = false, // use React's forwardRef to expose a ref of the wrapped component forwardRef = false, // the context consumer to use context = ReactReduxContext, // additional options are passed through to the selectorFactory ...connectOptions &#125; = &#123;&#125;) &#123; invariant( renderCountProp === undefined, `renderCountProp is removed. render counting is built into the latest React dev tools profiling extension` ) invariant( !withRef, 'withRef is removed. To access the wrapped instance, use a ref on the connected component' ) const customStoreWarningMessage = 'To use a custom Redux store for specific components, create a custom React context with ' + \"React.createContext(), and pass the context object to React Redux's Provider and specific components\" + ' like: &lt;Provider context=&#123;MyContext&#125;&gt;&lt;ConnectedComponent context=&#123;MyContext&#125; /&gt;&lt;/Provider&gt;. ' + 'You may also pass a &#123;context : MyContext&#125; option to connect' invariant( storeKey === 'store', 'storeKey has been removed and does not do anything. ' + customStoreWarningMessage ) // 存储context const Context = context return function wrapWithConnect(WrappedComponent) &#123; if (process.env.NODE_ENV !== 'production') &#123; invariant( isValidElementType(WrappedComponent), `You must pass a component to the function returned by ` + `$&#123;methodName&#125;. Instead received $&#123;stringifyComponent( WrappedComponent )&#125;` ) &#125; const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component' const displayName = getDisplayName(wrappedComponentName) const selectorFactoryOptions = &#123; ...connectOptions, getDisplayName, methodName, renderCountProp, shouldHandleStateChanges, storeKey, displayName, wrappedComponentName, WrappedComponent &#125; const &#123; pure &#125; = connectOptions // pure参数决定是继承Component还是PureComponent let OuterBaseComponent = Component if (pure) &#123; OuterBaseComponent = PureComponent &#125; function makeDerivedPropsSelector() &#123; let lastProps let lastState let lastDerivedProps let lastStore let lastSelectorFactoryOptions let sourceSelector return function selectDerivedProps( state, props, store, selectorFactoryOptions ) &#123; if (pure &amp;&amp; lastProps === props &amp;&amp; lastState === state) &#123; // 直接返回上一次生成的props，避免不必要的渲染工作 return lastDerivedProps &#125; if ( store !== lastStore || lastSelectorFactoryOptions !== selectorFactoryOptions ) &#123; // 更新数据 lastStore = store lastSelectorFactoryOptions = selectorFactoryOptions sourceSelector = selectorFactory( store.dispatch, selectorFactoryOptions ) &#125; lastProps = props lastState = state // 生成新的需要注入的props，这里传入的props是ownProps const nextProps = sourceSelector(state, props) lastDerivedProps = nextProps return lastDerivedProps &#125; &#125; function makeChildElementSelector() &#123; let lastChildProps, lastForwardRef, lastChildElement, lastComponent return function selectChildElement( WrappedComponent, childProps, forwardRef ) &#123; if ( childProps !== lastChildProps || forwardRef !== lastForwardRef || lastComponent !== WrappedComponent ) &#123; lastChildProps = childProps lastForwardRef = forwardRef lastComponent = WrappedComponent lastChildElement = ( &lt;WrappedComponent &#123;...childProps&#125; ref=&#123;forwardRef&#125; /&gt; ) &#125; return lastChildElement &#125; &#125; class Connect extends OuterBaseComponent &#123; constructor(props) &#123; super(props) invariant( forwardRef ? !props.wrapperProps[storeKey] : !props[storeKey], 'Passing redux store in props has been removed and does not do anything. ' + customStoreWarningMessage ) this.selectDerivedProps = makeDerivedPropsSelector() this.selectChildElement = makeChildElementSelector() this.indirectRenderWrappedComponent = this.indirectRenderWrappedComponent.bind( this ) &#125; indirectRenderWrappedComponent(value) &#123; // calling renderWrappedComponent on prototype from indirectRenderWrappedComponent bound to `this` return this.renderWrappedComponent(value) &#125; renderWrappedComponent(value) &#123; // 这里的value就是最开始在Provider里面定义的state invariant( value, `Could not find \"store\" in the context of ` + `\"$&#123;displayName&#125;\". Either wrap the root component in a &lt;Provider&gt;, ` + `or pass a custom React context provider to &lt;Provider&gt; and the corresponding ` + `React context consumer to $&#123;displayName&#125; in connect options.` ) const &#123; storeState, store &#125; = value let wrapperProps = this.props let forwardedRef if (forwardRef) &#123; wrapperProps = this.props.wrapperProps forwardedRef = this.props.forwardedRef &#125; // 生成要将store中哪些数据注入props的方法 let derivedProps = this.selectDerivedProps( storeState, wrapperProps, store, selectorFactoryOptions ) // 拼装最后需要返回给connectAdvanced的组件 return this.selectChildElement( WrappedComponent, derivedProps, forwardedRef ) &#125; render() &#123; // 获取context以便使用context.consumer获取store的变更 const ContextToUse = this.props.context &amp;&amp; this.props.context.Consumer &amp;&amp; isContextConsumer(&lt;this.props.context.Consumer /&gt;) ? this.props.context : Context return ( &lt;ContextToUse.Consumer&gt; &#123;this.indirectRenderWrappedComponent&#125; &lt;/ContextToUse.Consumer&gt; ) &#125; &#125; Connect.WrappedComponent = WrappedComponent Connect.displayName = displayName if (forwardRef) &#123; // 将ref转发给子组件 const forwarded = React.forwardRef(function forwardConnectRef( props, ref ) &#123; return &lt;Connect wrapperProps=&#123;props&#125; forwardedRef=&#123;ref&#125; /&gt; &#125;) forwarded.displayName = displayName forwarded.WrappedComponent = WrappedComponent // hoistStatics用于copy静态方法，避免在使用HOC的时候类的静态方法丢失 return hoistStatics(forwarded, WrappedComponent) &#125; return hoistStatics(Connect, WrappedComponent) &#125;&#125; 略过前面的一堆警告判断不看，直接看返回，connectAdvanced会返回一个叫wrapWithConnect的方法，这个方法以一个React Component作为参数，回想我们平常调用connect的时候： 1connect(mapStateToProps,mapDispatchToProps,mergeProps,options)(App); 就是在这里，这个函数会先获取到wrappedComponentName，然后将除了connect方法前三个参数之外的其他参数都包裹到了selectorFactoryOptions里面，wrapWithConnect这个HOC会返回一个新的组件给我们，至于新组件是继承Component还是PureComponent取决于我们配置的pure参数，这里跳过接下来的两个方法直接看return，因为用到了HOC这里有两个需要注意的问题，一个是ref转发，这里代码里面有相关体现，另一个就是在使用HOC的时候会造成static丢失的问题，这里通过hoist-non-react-statics进行了处理，具体的描述可以看react doc。 render的时候会调用this.indirectRenderWrappedComponent方法，这个方法接收当前的context值，也就是Provider里面提供的state，看一眼这个方法： 1234567891011121314151617181920212223242526272829303132renderWrappedComponent(value) &#123; // 这里的value就是最开始在Provider里面定义的state invariant( value, `Could not find \"store\" in the context of ` + `\"$&#123;displayName&#125;\". Either wrap the root component in a &lt;Provider&gt;, ` + `or pass a custom React context provider to &lt;Provider&gt; and the corresponding ` + `React context consumer to $&#123;displayName&#125; in connect options.` ) const &#123; storeState, store &#125; = value let wrapperProps = this.props let forwardedRef if (forwardRef) &#123; wrapperProps = this.props.wrapperProps forwardedRef = this.props.forwardedRef &#125; // 生成要将store中哪些数据注入props的方法 let derivedProps = this.selectDerivedProps( storeState, wrapperProps, store, selectorFactoryOptions ) // 拼装最后需要返回给connectAdvanced的组件 return this.selectChildElement( WrappedComponent, derivedProps, forwardedRef ) &#125; 前面的不看，直接看selectDerivedProps，其实是调用了makeDerivedPropsSelector： 1234567891011121314151617181920212223242526272829303132333435363738394041function makeDerivedPropsSelector() &#123; let lastProps let lastState let lastDerivedProps let lastStore let lastSelectorFactoryOptions let sourceSelector return function selectDerivedProps( state, props, store, selectorFactoryOptions ) &#123; if (pure &amp;&amp; lastProps === props &amp;&amp; lastState === state) &#123; // 直接返回上一次生成的props，避免不必要的渲染工作 return lastDerivedProps &#125; if ( store !== lastStore || lastSelectorFactoryOptions !== selectorFactoryOptions ) &#123; // 更新数据 lastStore = store lastSelectorFactoryOptions = selectorFactoryOptions sourceSelector = selectorFactory( store.dispatch, selectorFactoryOptions ) &#125; lastProps = props lastState = state // 生成新的需要注入的props，这里传入的props是ownProps const nextProps = sourceSelector(state, props) lastDerivedProps = nextProps return lastDerivedProps &#125; &#125; 首先会对state和props做一次浅比较，如果没有变化直接返回上一次计算得到的结果，否则将dispatch和selectorFactoryOptions传入selectorFactory得到sourceSelector，sourceSelector由connect传入，这个方法用于计算mapStateToProps、mapDispatchToProps、 ownProps的结果： 1234567891011121314151617181920212223242526272829export default function finalPropsSelectorFactory( dispatch, &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options &#125;) &#123; const mapStateToProps = initMapStateToProps(dispatch, options) const mapDispatchToProps = initMapDispatchToProps(dispatch, options) const mergeProps = initMergeProps(dispatch, options) if (process.env.NODE_ENV !== 'production') &#123; verifySubselectors( mapStateToProps, mapDispatchToProps, mergeProps, options.displayName ) &#125; const selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory return selectorFactory( mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options )&#125; 这里的initMapStateToProps之流就是我们之前wrapMapToPropsFunc函数返回的结果，我把代码贴下面方便对照： 1234567891011121314151617181920212223242526272829303132333435export function wrapMapToPropsFunc(mapToProps, methodName) &#123; return function initProxySelector(dispatch, &#123; displayName &#125;) &#123; const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) &#123; return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch) &#125; // allow detectFactoryAndVerify to get ownProps proxy.dependsOnOwnProps = true proxy.mapToProps = function detectFactoryAndVerify( stateOrDispatch, ownProps ) &#123; proxy.mapToProps = mapToProps // 检查是否订阅了ownProps proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps) let props = proxy(stateOrDispatch, ownProps) if (typeof props === 'function') &#123; proxy.mapToProps = props proxy.dependsOnOwnProps = getDependsOnOwnProps(props) props = proxy(stateOrDispatch, ownProps) &#125; if (process.env.NODE_ENV !== 'production') verifyPlainObject(props, displayName, methodName) return props &#125; return proxy &#125;&#125; 还是用mapStateToProps为例，先看finalPropsSelectorFactory，如果我们在参数里面设置了pure，就会调用pureFinalPropsSelectorFactory去构造最后的selectorFactory函数，这个函数定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475export function pureFinalPropsSelectorFactory( mapStateToProps, mapDispatchToProps, mergeProps, dispatch, &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125;) &#123; let hasRunAtLeastOnce = false let state let ownProps let stateProps let dispatchProps let mergedProps // 如果是第一次运行执行该方法 function handleFirstCall(firstState, firstOwnProps) &#123; state = firstState ownProps = firstOwnProps stateProps = mapStateToProps(state, ownProps) dispatchProps = mapDispatchToProps(dispatch, ownProps) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) hasRunAtLeastOnce = true return mergedProps &#125; function handleNewPropsAndNewState() &#123; stateProps = mapStateToProps(state, ownProps) if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) return mergedProps &#125; function handleNewProps() &#123; if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps) if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) return mergedProps &#125; function handleNewState() &#123; const nextStateProps = mapStateToProps(state, ownProps) const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps) stateProps = nextStateProps if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps) return mergedProps &#125; // 处理后续调用 function handleSubsequentCalls(nextState, nextOwnProps) &#123; const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps) const stateChanged = !areStatesEqual(nextState, state) state = nextState ownProps = nextOwnProps // 根据props和state的变动情况执行不同的方法，本质上最后都是调用mergedProps合并props if (propsChanged &amp;&amp; stateChanged) return handleNewPropsAndNewState() if (propsChanged) return handleNewProps() if (stateChanged) return handleNewState() return mergedProps &#125; return function pureFinalPropsSelector(nextState, nextOwnProps) &#123; return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps) &#125;&#125; 整体流程比较简单，如果是第一次运行，调用handleFirstCall方法，它会根据传入的state和ownProps来返回merge后的props，这个方法里面调用了mapStateToProps(state, ownProps)，等同于调用了mapToPropsProxy(state, ownProps)，然后在判断是mapStateToProps还是mapDispatchToProps来返回处理后的props，后续运行也是一样的，大致的流程都没有什么大的区别，最后可以看一下默认的mergeProps是怎么处理的： 1234export function defaultMergeProps(stateProps, dispatchProps, ownProps) &#123; // 简单的使用展开运算符合并对象 return &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;&#125; 可以看到就是直接展开，简明易懂。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.limuyang.cc/tags/源码阅读/"},{"name":"react-redux","slug":"react-redux","permalink":"https://www.limuyang.cc/tags/react-redux/"}]},{"title":"阅读分析Vue-Router源码","date":"2019-05-09T17:05:05.000Z","path":"2019/05/09/阅读分析Vue-Router源码/","text":"路由的概念路由这个概念最开始是在后端出现的，以前使用模板引擎开发页面的时候经常会看到这样的路径：1http://hometown.xxx.edu.cn/bbs/forum.php 有时还会有带.asp或.html的路径，这就是所谓的SSR(Server Side Render)，通过服务端渲染，直接返回页面。其响应过程是这样的 1.浏览器发出请求 2.服务器监听到80端口（或443）有请求过来，并解析url路径 3.根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等） 4.浏览器根据数据包的Content-Type来决定如何解析数据 简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。就像路由器在网络层中扮演的角色一样，肩负着将数据包正确导向目的地址的重任，只不过在这里变成了客户端浏览器的指路人，所谓的前端路由，指的是一种能力，即： 不依赖于服务器，根据不同的URL渲染不同的页面 前端路由与后端路由在Ajax还没有诞生的时候，路由的工作是交给后端来完成的，当进行页面切换的时候，浏览器会发送不同的URL请求，服务器接收到浏览器的请求时，通过解析不同的URL去拼接需要的Html或模板，然后将结果返回到浏览器端进行渲染。 服务器端路由同样是有利亦有弊。它的好处是安全性更高，更严格得控制页面的展现。这在某些场景中是很有用的，譬如下单支付流程，每一步只有在上一步成功执行之后才能抵达。这在服务器端可以为每一步流程添加验证机制，只有验证通过才返回正确的页面。那么前端路由不能实现每一步的验证？自然不是，姑且相信你的代码可以写的很严谨，保证正常情况下流程不会错，但是另一个不得不面对的事实是：前端是毫无安全性可言的。用户可以肆意修改代码来进入不同的流程，你可能会为此添加不少的处理逻辑。相较之下，当然是后端控制页面的进入权限更为安全和简便。 另一方面，后端路由无疑增加了服务器端的负荷，并且需要reload页面，用户体验其实不佳。 前端路由的出现在 90s 年代初，大多数的网页都是通过直接返回HTML的，用户的每次更新操作都需要重新刷新页面。及其影响交互体验，随着网络的发展，迫切需要一种方案来改善这种情况。 1996，微软首先提出 iframe 标签，iframe带来了异步加载和请求元素的概念，随后在 1998 年，微软的 Outloook Web App 团队提出Ajax的基本概念（XMLHttpRequest的前身），并在IE5通过ActiveX来实现了这项技术。在微软实现这个概念后，其他浏览器比如Mozilia，Safari，Opera相继以 XMLHttpRequest来实现Ajax。（😭 兼容问题从此出现，话说微软命名真喜欢用X，MFC源码一大堆。。）不过在 IE7 发布时，微软选择了妥协，兼容了XMLHttpRequest的实现。 有了Ajax后，用户交互就不用每次都刷新页面，体验带来了极大的提升。 但真正让这项技术发扬光大的，(｡･∀･)ﾉﾞ还是后来的 Google Map，它的出现向人们展现了Ajax的真正魅力，释放了众多开发人员的想象力，让其不仅仅局限于简单的数据和页面交互，为后来异步交互体验方式的繁荣发展带来了根基。 而异步交互体验的更高级版本就是我们熟知的SPA，SPA不单单在页面交互上做到了不刷新，而且在页面之间跳转也做到了不刷新，为了做到这一点，就促使了前端路由的诞生。 前端路由的实现方式前端路由其实只要解决两个问题： 在页面不刷新的前提下实现url变化 捕捉到url的变化，以便执行页面替换逻辑在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：1http://www.xxx.com/#/login 这种 #。后面hash值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次hash值的变化，还会触发hashchange这个事件，通过这个事件我们就可以知道hash值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作： 1234function matchAndUpdate () &#123; // todo 匹配 hash 做 dom 更新操作&#125;window.addEventListener('hashchange', matchAndUpdate) 后来，因为HTML5标准发布。多了两个 API，pushState和replaceState，通过这两个API可以改变 url地址且不会发送请求。同时还有popstate事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟hash实现相同的。用了HTML5的实现，单页路由的url就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面： 1234function matchAndUpdate () &#123; // todo 匹配路径 做 dom 更新操作&#125;window.addEventListener('popstate', matchAndUpdate) Vue-Router的实现方式Vue-Router跟Vuex一样都是通过Vue.use这个全局API来注册的，这个方法定义在vue/src/core/global-api/use.js： 1234567891011121314151617181920212223/* @flow */import &#123; toArray &#125; from '../util/index'export function initUse (Vue: GlobalAPI) &#123; Vue.use = function (plugin: Function | Object) &#123; const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) &gt; -1) &#123; return this &#125; // additional parameters const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === 'function') &#123; plugin.install.apply(plugin, args) &#125; else if (typeof plugin === 'function') &#123; plugin.apply(null, args) &#125; installedPlugins.push(plugin) return this &#125;&#125; Vue.use接受一个plugin参数，并且维护了一个_installedPlugins数组，它存储所有注册过的plugin；如果plugin是一个对象，会判断plugin有没有定义install方法，如果有的话则调用该方法，并且该方法执行的第一个参数是Vue；如果plugin是一个函数，它会被作为install方法，最后把plugin存储到installedPlugins数组里面，Vue的这种插件注册的机制有一个好处就是我们不需要额外的去import Vue了。 路由的注册Vue-Router的入口在src/index.js，其中install方法定义在src/install.js，可以看一下src下面的目录结构： 12345678910111213141516171819202122232425├── components│ ├── link.js│ └── view.js├── create-matcher.js├── create-route-map.js├── history│ ├── abstract.js│ ├── base.js│ ├── hash.js│ └── html5.js├── index.js├── install.js└── util ├── async.js ├── dom.js ├── location.js ├── misc.js ├── params.js ├── path.js ├── push-state.js ├── query.js ├── resolve-components.js ├── route.js ├── scroll.js └── warn.js 简单看下install的流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import View from './components/view'import Link from './components/link'export let _Vueexport function install (Vue) &#123; // 确保Vue-Router只被install一次 if (install.installed &amp;&amp; _Vue === Vue) return install.installed = true _Vue = Vue const isDef = v =&gt; v !== undefined const registerInstance = (vm, callVal) =&gt; &#123; let i = vm.$options._parentVnode if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123; i(vm, callVal) &#125; &#125; Vue.mixin(&#123; // 在beforeCreate钩子里面初始化路由 beforeCreate () &#123; // 根组件的$options上才有router对象 if (isDef(this.$options.router)) &#123; // 设置根路由 this._routerRoot = this // 获取到根组件上的router实例 this._router = this.$options.router // 路由初始化 this._router.init(this) // 为_route属性实现双向绑定 Vue.util.defineReactive(this, '_route', this._router.history.current) &#125; else &#123; // 获取父组件的_routerRoot this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this &#125; // 注册&lt;router-view&gt;&lt;/router-view&gt;实例的钩子 registerInstance(this, this) &#125;, destroyed () &#123; registerInstance(this) &#125; &#125;) // 方便全局通过this.$router获取路由实例 Object.defineProperty(Vue.prototype, '$router', &#123; get () &#123; return this._routerRoot._router &#125; &#125;) // 方便全局通过this.$route获取路由对象 Object.defineProperty(Vue.prototype, '$route', &#123; get () &#123; return this._routerRoot._route &#125; &#125;) // 注册全局组件&lt;router-view/&gt;和&lt;router-link/&gt; Vue.component('RouterView', View) Vue.component('RouterLink', Link) // 使用和created相同的合并策略 const strats = Vue.config.optionMergeStrategies // use the same hook merging strategy for route hooks strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created&#125; 首先通过设立一个installed标志位来确保Vue-Router只被安装一次，然后通过变量_Vue承载传入的Vue实例，然后利用Vue.mixin向每一个Vue实例注册beforeCreate和destroyed钩子函数。 在beforeCreate函数里面，如果是根组件，将根组件赋值给this._routerRoot，获取根组件的路由实例之后执行init初始化函数，然后调用Vue的defineReactive将_route变为响应式对象，如果不是根组件则获取父组件的_routerRoot属性。 在beforeCreate函数的最后部分和destroyed函数里面都执行了registerInstance函数，这个函数是注册&lt;router-view&gt;实例的钩子函数，根据传入参数的个数来决定是注册还是取消注册，函数的定义在src/components/view.js里面: 123456789101112// attach instance registration hook // this will be called in the instance's injected lifecycle hooks data.registerRouteInstance = (vm, val) =&gt; &#123; // val could be undefined for unregistration const current = matched.instances[name] if ( (val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm) ) &#123; matched.instances[name] = val &#125; &#125; 回到install.js，紧接着，为了让我们能够全局的使用this.$router和this.$route在Vue原型上定义了对应的get方法，然后通过Vue.component注册了全局组件注册全局组件&lt;router-view/&gt;和和&lt;router-link/&gt;，最后定义了一些钩子函数的使用策略，这就是整个Vue-Router的安装过程。 路由的实例化先看一下Vue-Router的构造函数，当我们new一个Vue-Router的时候都干了些什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254/* @flow */import &#123; install &#125; from './install'import &#123; START &#125; from './util/route'import &#123; assert &#125; from './util/warn'import &#123; inBrowser &#125; from './util/dom'import &#123; cleanPath &#125; from './util/path'import &#123; createMatcher &#125; from './create-matcher'import &#123; normalizeLocation &#125; from './util/location'import &#123; supportsPushState &#125; from './util/push-state'import &#123; HashHistory &#125; from './history/hash'import &#123; HTML5History &#125; from './history/html5'import &#123; AbstractHistory &#125; from './history/abstract'import type &#123; Matcher &#125; from './create-matcher'export default class VueRouter &#123; static install: () =&gt; void; static version: string; app: any; apps: Array&lt;any&gt;; ready: boolean; readyCbs: Array&lt;Function&gt;; options: RouterOptions; mode: string; history: HashHistory | HTML5History | AbstractHistory; matcher: Matcher; fallback: boolean; beforeHooks: Array&lt;?NavigationGuard&gt;; resolveHooks: Array&lt;?NavigationGuard&gt;; afterHooks: Array&lt;?AfterNavigationHook&gt;; constructor (options: RouterOptions = &#123;&#125;) &#123; // 根Vue实例 this.app = null // 存储含有this.$options.router属性的Vue实例 this.apps = [] // 传入路由的配置 this.options = options this.beforeHooks = [] this.resolveHooks = [] this.afterHooks = [] // 创建路由匹配对象 this.matcher = createMatcher(options.routes || [], this) // 默认为hash模式 let mode = options.mode || 'hash' // 当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true this.fallback = mode === 'history' &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false if (this.fallback) &#123; mode = 'hash' &#125; // 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式 if (!inBrowser) &#123; mode = 'abstract' &#125; this.mode = mode // 根据mode采用不同的路由方式 switch (mode) &#123; case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== 'production') &#123; assert(false, `invalid mode: $&#123;mode&#125;`) &#125; &#125; &#125; match ( raw: RawLocation, current?: Route, redirectedFrom?: Location ): Route &#123; return this.matcher.match(raw, current, redirectedFrom) &#125; get currentRoute (): ?Route &#123; return this.history &amp;&amp; this.history.current &#125; init (app: any /* Vue component instance */) &#123; // 在初始化Vue-Router之前必须先通过Vue.use(VueRouter)注册 process.env.NODE_ENV !== 'production' &amp;&amp; assert( install.installed, `not installed. Make sure to call \\`Vue.use(VueRouter)\\` ` + `before creating root instance.` ) this.apps.push(app) // set up app destroyed handler // https://github.com/vuejs/vue-router/issues/2639 app.$once('hook:destroyed', () =&gt; &#123; // clean out app from this.apps array once destroyed const index = this.apps.indexOf(app) if (index &gt; -1) this.apps.splice(index, 1) // ensure we still have a main app or null if no apps // we do not release the router so it can be reused if (this.app === app) this.app = this.apps[0] || null &#125;) // main app previously initialized // return as we don't need to set up new history listener if (this.app) &#123; return &#125; this.app = app const history = this.history if (history instanceof HTML5History) &#123; history.transitionTo(history.getCurrentLocation()) &#125; else if (history instanceof HashHistory) &#123; const setupHashListener = () =&gt; &#123; history.setupListeners() &#125; history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ) &#125; history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; app._route = route &#125;) &#125;) &#125; beforeEach (fn: Function): Function &#123; return registerHook(this.beforeHooks, fn) &#125; beforeResolve (fn: Function): Function &#123; return registerHook(this.resolveHooks, fn) &#125; afterEach (fn: Function): Function &#123; return registerHook(this.afterHooks, fn) &#125; onReady (cb: Function, errorCb?: Function) &#123; this.history.onReady(cb, errorCb) &#125; onError (errorCb: Function) &#123; this.history.onError(errorCb) &#125; push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.push(location, onComplete, onAbort) &#125; replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.replace(location, onComplete, onAbort) &#125; go (n: number) &#123; this.history.go(n) &#125; back () &#123; this.go(-1) &#125; forward () &#123; this.go(1) &#125; getMatchedComponents (to?: RawLocation | Route): Array&lt;any&gt; &#123; const route: any = to ? to.matched ? to : this.resolve(to).route : this.currentRoute if (!route) &#123; return [] &#125; return [].concat.apply([], route.matched.map(m =&gt; &#123; return Object.keys(m.components).map(key =&gt; &#123; return m.components[key] &#125;) &#125;)) &#125; resolve ( to: RawLocation, current?: Route, append?: boolean ): &#123; location: Location, route: Route, href: string, // for backwards compat normalizedTo: Location, resolved: Route &#125; &#123; current = current || this.history.current const location = normalizeLocation( to, current, append, this ) const route = this.match(location, current) const fullPath = route.redirectedFrom || route.fullPath const base = this.history.base const href = createHref(base, fullPath, this.mode) return &#123; location, route, href, // for backwards compat normalizedTo: location, resolved: route &#125; &#125; addRoutes (routes: Array&lt;RouteConfig&gt;) &#123; this.matcher.addRoutes(routes) if (this.history.current !== START) &#123; this.history.transitionTo(this.history.getCurrentLocation()) &#125; &#125;&#125;function registerHook (list: Array&lt;any&gt;, fn: Function): Function &#123; list.push(fn) return () =&gt; &#123; const i = list.indexOf(fn) if (i &gt; -1) list.splice(i, 1) &#125;&#125;function createHref (base: string, fullPath: string, mode) &#123; var path = mode === 'hash' ? '#' + fullPath : fullPath return base ? cleanPath(base + '/' + path) : path&#125;VueRouter.install = installVueRouter.version = '__VERSION__'// 通过link标签引用js的实行自动注册if (inBrowser &amp;&amp; window.Vue) &#123; window.Vue.use(VueRouter)&#125; 构造函数里面定义了一些属性，其中this.app表示根Vue的实例，this.apps存储含有this.$options.router属性的Vue实例，初始化Vue-Router后传入的配置都会存储在this.options，this.beforeHooks、this.resolveHooks、this.afterHooks用来存储钩子函数，this.matcher是路由匹配后返回的对象，this.fallback会根据配置的mode参数以及浏览器支持度来决定给是否回退到hash模式，this.mode就是路由创建的模式，这里提供hash、history、abstract三种模式，this.history表示根据不同的路由模式来创建的路由history的具体实现方式。 实例化Vue-Router之后会返回它的实例router，我们在使用Vue-Router的时候需要在初始化Vue的时候传入这个router属性： 12345new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 这个时候会把router属性配置到this.$options，回想到install.js里面在beforeCreate钩子函数里面执行的方法： 1234567891011beforeCreate () &#123; // 根组件的$options上才有router对象 if (isDef(this.$options.router)) &#123; // 设置根路由 this._routerRoot = this // 获取到根组件上的router实例 this._router = this.$options.router // 路由初始化 this._router.init(this) // .... &#125; 所以这个时候会执行init方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051init (app: any /* Vue component instance */) &#123; // 在初始化Vue-Router之前必须先通过Vue.use(VueRouter)注册 process.env.NODE_ENV !== 'production' &amp;&amp; assert( install.installed, `not installed. Make sure to call \\`Vue.use(VueRouter)\\` ` + `before creating root instance.` ) // 存储app实例 this.apps.push(app) // set up app destroyed handler // https://github.com/vuejs/vue-router/issues/2639 app.$once('hook:destroyed', () =&gt; &#123; // clean out app from this.apps array once destroyed const index = this.apps.indexOf(app) if (index &gt; -1) this.apps.splice(index, 1) // ensure we still have a main app or null if no apps // we do not release the router so it can be reused if (this.app === app) this.app = this.apps[0] || null &#125;) // main app previously initialized // return as we don't need to set up new history listener if (this.app) &#123; return &#125; this.app = app const history = this.history // 根据history实现的方式不同执行不同的逻辑 if (history instanceof HTML5History) &#123; history.transitionTo(history.getCurrentLocation()) &#125; else if (history instanceof HashHistory) &#123; const setupHashListener = () =&gt; &#123; history.setupListeners() &#125; history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ) &#125; // 更新根组件的路由对象 history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; app._route = route &#125;) &#125;)&#125; init其实没干很多事情，首先把传入的Vue实例存储到apps数组中，然后把this.history赋值给一个本地变量，根据this.history实现方式的不同执行不同的逻辑，最后通过history的回调更新路由对象也就是this.$route。 无论this.history是基于history还是hash实现的，最后都会调用transitionTo方法，这个方法定义在src/history/base.js： 12345transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const route = this.router.match(location, this.current) this.confirmTransition(route, () =&gt; &#123; // ... &#125; 实际上就是调用match方法： 12345678match ( raw: RawLocation, current?: Route, redirectedFrom?: Location): Route &#123; return this.matcher.match(raw, current, redirectedFrom)&#125; 那我们可以先把上面的逻辑放一边，先了解一下matchers的构建，相关的源码在src/create-matcher.js: match的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/* @flow */import type VueRouter from './index'import &#123; resolvePath &#125; from './util/path'import &#123; assert, warn &#125; from './util/warn'import &#123; createRoute &#125; from './util/route'import &#123; fillParams &#125; from './util/params'import &#123; createRouteMap &#125; from './create-route-map'import &#123; normalizeLocation &#125; from './util/location'export type Matcher = &#123; match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) =&gt; Route; addRoutes: (routes: Array&lt;RouteConfig&gt;) =&gt; void;&#125;;export function createMatcher ( routes: Array&lt;RouteConfig&gt;, router: VueRouter): Matcher &#123; const &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes) // 添加路由路径关系映射 function addRoutes (routes) &#123; createRouteMap(routes, pathList, pathMap, nameMap) &#125; function match ( raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location ): Route &#123; // 根据raw和currentRoute计算出新的location const location = normalizeLocation(raw, currentRoute, false, router) const &#123; name &#125; = location if (name) &#123; // 如果是命名路由，取出对应的路由record const record = nameMap[name] if (process.env.NODE_ENV !== 'production') &#123; warn(record, `Route with name '$&#123;name&#125;' does not exist`) &#125; // 生成一条新记录 if (!record) return _createRoute(null, location) const paramNames = record.regex.keys .filter(key =&gt; !key.optional) .map(key =&gt; key.name) if (typeof location.params !== 'object') &#123; location.params = &#123;&#125; &#125; // 赋值params if (currentRoute &amp;&amp; typeof currentRoute.params === 'object') &#123; for (const key in currentRoute.params) &#123; if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) &#123; location.params[key] = currentRoute.params[key] &#125; &#125; &#125; if (record) &#123; location.path = fillParams(record.path, location.params, `named route \"$&#123;name&#125;\"`) return _createRoute(record, location, redirectedFrom) &#125; &#125; else if (location.path) &#123; location.params = &#123;&#125; for (let i = 0; i &lt; pathList.length; i++) &#123; const path = pathList[i] const record = pathMap[path] if (matchRoute(record.regex, location.path, location.params)) &#123; return _createRoute(record, location, redirectedFrom) &#125; &#125; &#125; // no match return _createRoute(null, location) &#125; function redirect ( record: RouteRecord, location: Location ): Route &#123; const originalRedirect = record.redirect let redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect if (typeof redirect === 'string') &#123; redirect = &#123; path: redirect &#125; &#125; if (!redirect || typeof redirect !== 'object') &#123; if (process.env.NODE_ENV !== 'production') &#123; warn( false, `invalid redirect option: $&#123;JSON.stringify(redirect)&#125;` ) &#125; return _createRoute(null, location) &#125; const re: Object = redirect const &#123; name, path &#125; = re let &#123; query, hash, params &#125; = location query = re.hasOwnProperty('query') ? re.query : query hash = re.hasOwnProperty('hash') ? re.hash : hash params = re.hasOwnProperty('params') ? re.params : params if (name) &#123; // resolved named direct const targetRecord = nameMap[name] if (process.env.NODE_ENV !== 'production') &#123; assert(targetRecord, `redirect failed: named route \"$&#123;name&#125;\" not found.`) &#125; return match(&#123; _normalized: true, name, query, hash, params &#125;, undefined, location) &#125; else if (path) &#123; // 1. resolve relative redirect const rawPath = resolveRecordPath(path, record) // 2. resolve params const resolvedPath = fillParams(rawPath, params, `redirect route with path \"$&#123;rawPath&#125;\"`) // 3. rematch with existing query and hash return match(&#123; _normalized: true, path: resolvedPath, query, hash &#125;, undefined, location) &#125; else &#123; if (process.env.NODE_ENV !== 'production') &#123; warn(false, `invalid redirect option: $&#123;JSON.stringify(redirect)&#125;`) &#125; return _createRoute(null, location) &#125; &#125; function alias ( record: RouteRecord, location: Location, matchAs: string ): Route &#123; const aliasedPath = fillParams(matchAs, location.params, `aliased route with path \"$&#123;matchAs&#125;\"`) const aliasedMatch = match(&#123; _normalized: true, path: aliasedPath &#125;) if (aliasedMatch) &#123; const matched = aliasedMatch.matched const aliasedRecord = matched[matched.length - 1] location.params = aliasedMatch.params return _createRoute(aliasedRecord, location) &#125; return _createRoute(null, location) &#125; function _createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: Location ): Route &#123; if (record &amp;&amp; record.redirect) &#123; return redirect(record, redirectedFrom || location) &#125; if (record &amp;&amp; record.matchAs) &#123; return alias(record, location, record.matchAs) &#125; return createRoute(record, location, redirectedFrom, router) &#125; return &#123; match, addRoutes &#125;&#125;function matchRoute ( regex: RouteRegExp, path: string, params: Object): boolean &#123; const m = path.match(regex) if (!m) &#123; return false &#125; else if (!params) &#123; return true &#125; for (let i = 1, len = m.length; i &lt; len; ++i) &#123; const key = regex.keys[i - 1] const val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i] if (key) &#123; // Fix #1994: using * with props: true generates a param named 0 params[key.name || 'pathMatch'] = val &#125; &#125; return true&#125;function resolveRecordPath (path: string, record: RouteRecord): string &#123; return resolvePath(path, record.parent ? record.parent.path : '/', true)&#125; createMatcher接受两个参数，第一个是初始化路由的配置对象routes，第二个是我们的路由实例router，首先会跑一个createRouteMap的逻辑，这个方法的作用是创建一个路由映射，这个方法定义在src/create-route-map.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179/* @flow */import Regexp from 'path-to-regexp'import &#123; cleanPath &#125; from './util/path'import &#123; assert, warn &#125; from './util/warn'export function createRouteMap ( routes: Array&lt;RouteConfig&gt;, oldPathList?: Array&lt;string&gt;, oldPathMap?: Dictionary&lt;RouteRecord&gt;, oldNameMap?: Dictionary&lt;RouteRecord&gt;): &#123; pathList: Array&lt;string&gt;; pathMap: Dictionary&lt;RouteRecord&gt;; nameMap: Dictionary&lt;RouteRecord&gt;;&#125; &#123; // the path list is used to control path matching priority const pathList: Array&lt;string&gt; = oldPathList || [] // $flow-disable-line const pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || Object.create(null) // $flow-disable-line const nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || Object.create(null) routes.forEach(route =&gt; &#123; addRouteRecord(pathList, pathMap, nameMap, route) &#125;) // 确保通配符的路径在最后才被匹配 // ensure wildcard routes are always at the end for (let i = 0, l = pathList.length; i &lt; l; i++) &#123; if (pathList[i] === '*') &#123; pathList.push(pathList.splice(i, 1)[0]) l-- i-- &#125; &#125; return &#123; pathList, pathMap, nameMap &#125;&#125;function addRouteRecord ( pathList: Array&lt;string&gt;, pathMap: Dictionary&lt;RouteRecord&gt;, nameMap: Dictionary&lt;RouteRecord&gt;, route: RouteConfig, parent?: RouteRecord, matchAs?: string) &#123; const &#123; path, name &#125; = route if (process.env.NODE_ENV !== 'production') &#123; // path不能为空并且component的值必须用一个组件名而不是一个string字符串 assert(path != null, `\"path\" is required in a route configuration.`) assert( typeof route.component !== 'string', `route config \"component\" for path: $&#123;String(path || name)&#125; cannot be a ` + `string id. Use an actual component instead.` ) &#125; // pathToRegexpOptions是编译正则的选项 const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || &#123;&#125; // normalize path const normalizedPath = normalizePath( path, parent, pathToRegexpOptions.strict ) // caseSensitive匹配规则是否大小写敏感？(默认值：false) if (typeof route.caseSensitive === 'boolean') &#123; pathToRegexpOptions.sensitive = route.caseSensitive &#125; const record: RouteRecord = &#123; path: normalizedPath, regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), components: route.components || &#123; default: route.component &#125;, instances: &#123;&#125;, name, parent, matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || &#123;&#125;, props: route.props == null ? &#123;&#125; : route.components ? route.props : &#123; default: route.props &#125; &#125; // 如果有子路由 if (route.children) &#123; // Warn if route is named, does not redirect and has a default child route. // If users navigate to this route by name, the default child will // not be rendered (GH Issue #629) if (process.env.NODE_ENV !== 'production') &#123; if (route.name &amp;&amp; !route.redirect &amp;&amp; route.children.some(child =&gt; /^\\/?$/.test(child.path))) &#123; warn( false, `Named Route '$&#123;route.name&#125;' has a default child route. ` + `When navigating to this named route (:to=\"&#123;name: '$&#123;route.name&#125;'\"), ` + `the default child route will not be rendered. Remove the name from ` + `this route and use the name of the default child route for named ` + `links instead.` ) &#125; &#125; // 循环添加子路由路径 route.children.forEach(child =&gt; &#123; const childMatchAs = matchAs ? cleanPath(`$&#123;matchAs&#125;/$&#123;child.path&#125;`) : undefined addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs) &#125;) &#125; // 设置了路由别名 if (route.alias !== undefined) &#123; // 统一转换为数组 const aliases = Array.isArray(route.alias) ? route.alias : [route.alias] aliases.forEach(alias =&gt; &#123; const aliasRoute = &#123; path: alias, children: route.children &#125; addRouteRecord( pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs ) &#125;) &#125; // 添加path记录以及建立path和记录的对应关系 if (!pathMap[record.path]) &#123; pathList.push(record.path) pathMap[record.path] = record &#125; // 如果配置了命名路由，给name和record建立映射关系 if (name) &#123; if (!nameMap[name]) &#123; nameMap[name] = record &#125; else if (process.env.NODE_ENV !== 'production' &amp;&amp; !matchAs) &#123; // 已经有这个命名的路由存在并且没有给这个路由设置重定向，说明给了重复命名 warn( false, `Duplicate named routes definition: ` + `&#123; name: \"$&#123;name&#125;\", path: \"$&#123;record.path&#125;\" &#125;` ) &#125; &#125;&#125;function compileRouteRegex (path: string, pathToRegexpOptions: PathToRegexpOptions): RouteRegExp &#123; const regex = Regexp(path, [], pathToRegexpOptions) if (process.env.NODE_ENV !== 'production') &#123; const keys: any = Object.create(null) regex.keys.forEach(key =&gt; &#123; // 有重复的动态路径参数 warn(!keys[key.name], `Duplicate param keys in route with path: \"$&#123;path&#125;\"`) keys[key.name] = true &#125;) &#125; return regex&#125;function normalizePath (path: string, parent?: RouteRecord, strict?: boolean): string &#123; // 替换根路由路径 if (!strict) path = path.replace(/\\/$/, '') if (path[0] === '/') return path if (parent == null) return path // 将//的路径替换成/ return cleanPath(`$&#123;parent.path&#125;/$&#123;path&#125;`)&#125; 这个方法的作用是将路由配置转换成一组组映射关系表，返回一个对象: 12345return &#123; pathList, pathMap, nameMap&#125; 其中pathList存储了所有的path，pathMap表示了path到RouteRecord对象的一一映射关系，nameMap则表示了name到RouteRecord对象的映射关系，RouteRecord对象是对路由配置参数routes每一项进行遍历后调用addRouteRecord方法生成的一条记录，方法定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114function addRouteRecord ( pathList: Array&lt;string&gt;, pathMap: Dictionary&lt;RouteRecord&gt;, nameMap: Dictionary&lt;RouteRecord&gt;, route: RouteConfig, parent?: RouteRecord, matchAs?: string) &#123; const &#123; path, name &#125; = route if (process.env.NODE_ENV !== 'production') &#123; // path不能为空并且component的值必须用一个组件名而不是一个string字符串 assert(path != null, `\"path\" is required in a route configuration.`) assert( typeof route.component !== 'string', `route config \"component\" for path: $&#123;String(path || name)&#125; cannot be a ` + `string id. Use an actual component instead.` ) &#125; // pathToRegexpOptions是编译正则的选项 const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || &#123;&#125; // normalize path const normalizedPath = normalizePath( path, parent, pathToRegexpOptions.strict ) // caseSensitive匹配规则是否大小写敏感？(默认值：false) if (typeof route.caseSensitive === 'boolean') &#123; pathToRegexpOptions.sensitive = route.caseSensitive &#125; const record: RouteRecord = &#123; path: normalizedPath, regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), components: route.components || &#123; default: route.component &#125;, instances: &#123;&#125;, name, parent, matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || &#123;&#125;, props: route.props == null ? &#123;&#125; : route.components ? route.props : &#123; default: route.props &#125; &#125; // 如果有子路由 if (route.children) &#123; // Warn if route is named, does not redirect and has a default child route. // If users navigate to this route by name, the default child will // not be rendered (GH Issue #629) if (process.env.NODE_ENV !== 'production') &#123; if (route.name &amp;&amp; !route.redirect &amp;&amp; route.children.some(child =&gt; /^\\/?$/.test(child.path))) &#123; warn( false, `Named Route '$&#123;route.name&#125;' has a default child route. ` + `When navigating to this named route (:to=\"&#123;name: '$&#123;route.name&#125;'\"), ` + `the default child route will not be rendered. Remove the name from ` + `this route and use the name of the default child route for named ` + `links instead.` ) &#125; &#125; // 循环添加子路由路径 route.children.forEach(child =&gt; &#123; const childMatchAs = matchAs ? cleanPath(`$&#123;matchAs&#125;/$&#123;child.path&#125;`) : undefined addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs) &#125;) &#125; // 设置了路由别名 if (route.alias !== undefined) &#123; // 统一转换为数组 const aliases = Array.isArray(route.alias) ? route.alias : [route.alias] aliases.forEach(alias =&gt; &#123; const aliasRoute = &#123; path: alias, children: route.children &#125; addRouteRecord( pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs ) &#125;) &#125; // 添加path记录以及建立path和记录的对应关系 if (!pathMap[record.path]) &#123; pathList.push(record.path) pathMap[record.path] = record &#125; // 如果配置了命名路由，给name和record建立映射关系 if (name) &#123; if (!nameMap[name]) &#123; nameMap[name] = record &#125; else if (process.env.NODE_ENV !== 'production' &amp;&amp; !matchAs) &#123; // 已经有这个命名的路由存在并且没有给这个路由设置重定向，说明给了重复命名 warn( false, `Duplicate named routes definition: ` + `&#123; name: \"$&#123;name&#125;\", path: \"$&#123;record.path&#125;\" &#125;` ) &#125; &#125;&#125; 这个方法首先会对path使用normalizePath进行规范化处理，我们看一下这个方法： 123456789function normalizePath (path: string, parent?: RouteRecord, strict?: boolean): string &#123; // 替换根路由路径 if (!strict) path = path.replace(/\\/$/, '') // 说明是一级路径，直接返回 if (path[0] === '/') return path if (parent == null) return path // 将//的路径替换成/并且拼接父路由的路径 return cleanPath(`$&#123;parent.path&#125;/$&#123;path&#125;`)&#125; 主要作用就是生成多层路由的具体路径，然后根据已有参数构建RouteRecord： 1234567891011121314151617const record: RouteRecord = &#123; path: normalizedPath, regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), components: route.components || &#123; default: route.component &#125;, instances: &#123;&#125;, name, parent, matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || &#123;&#125;, props: route.props == null ? &#123;&#125; : route.components ? route.props : &#123; default: route.props &#125;&#125; 这里解释下regex这个参数，用到了path-to-regexp这个库，这个库可以把路径转换为正则表达式，举个栗子： 1234const keys = []const regexp = pathToRegexp('/foo/:bar', keys)// regexp = /^\\/foo\\/([^\\/]+?)\\/?$/i// keys = [&#123; name: 'bar', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\\\\/]+?' &#125;] 用这个库作为路径匹配引擎是为了实现可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配。紧接着判断是否配置了子路由，然后循环调用addRouteRecord这个方法，并把当前的record作为parent，如果设置了路由别名，也会给别名添加一份record，最后就是更新映射表，返回一个Array对象以及两个Dictionary对象。 回到create-matcher.js，它对外暴露了两个方法：addRoutes和match，分别用于动态添加路由配置以及返回一个路由的路径，先看addRoutes： 123function addRoutes (routes) &#123; createRouteMap(routes, pathList, pathMap, nameMap) &#125; 其实就是在现有的pathList、pathMap、nameMap上动态添加一条新纪录，这几个都是引用类型，执行addRoutes之后都会被修改。 match函数相对复杂一点，接受三个参数，第一个参数可以为string也可以是一个Location对象，第二个参数表示当前的路由路径，第三个参数也是Location对象，跟重定向有关： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function match ( raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location): Route &#123; // 根据raw和currentRoute计算出新的location const location = normalizeLocation(raw, currentRoute, false, router) const &#123; name &#125; = location if (name) &#123; // 如果是命名路由，取出对应的路由record const record = nameMap[name] if (process.env.NODE_ENV !== 'production') &#123; warn(record, `Route with name '$&#123;name&#125;' does not exist`) &#125; // 生成一条新记录 if (!record) return _createRoute(null, location) const paramNames = record.regex.keys .filter(key =&gt; !key.optional) .map(key =&gt; key.name) if (typeof location.params !== 'object') &#123; location.params = &#123;&#125; &#125; // 赋值params if (currentRoute &amp;&amp; typeof currentRoute.params === 'object') &#123; for (const key in currentRoute.params) &#123; if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) &#123; location.params[key] = currentRoute.params[key] &#125; &#125; &#125; if (record) &#123; location.path = fillParams(record.path, location.params, `named route \"$&#123;name&#125;\"`) return _createRoute(record, location, redirectedFrom) &#125; &#125; else if (location.path) &#123; location.params = &#123;&#125; for (let i = 0; i &lt; pathList.length; i++) &#123; const path = pathList[i] const record = pathMap[path] if (matchRoute(record.regex, location.path, location.params)) &#123; return _createRoute(record, location, redirectedFrom) &#125; &#125; &#125; // no match return _createRoute(null, location)&#125; 一开始会执行normalizeLocation方法，返回一个新的location，看一眼normalizeLocation的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export function normalizeLocation ( raw: RawLocation, current: ?Route, append: ?boolean, router: ?VueRouter): Location &#123; let next: Location = typeof raw === 'string' ? &#123; path: raw &#125; : raw // named target if (next._normalized) &#123; // 已经normalized的直接返回 return next &#125; else if (next.name) &#123; // 如果是命名路由，返回一份备份 return extend(&#123;&#125;, raw) &#125; // relative params // 没有path，但是有params和current if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123; next = extend(&#123;&#125;, next) next._normalized = true // 拿到params const params: any = extend(extend(&#123;&#125;, current.params), next.params) if (current.name) &#123; next.name = current.name next.params = params &#125; else if (current.matched.length) &#123; const rawPath = current.matched[current.matched.length - 1].path // 根据rawPath和params计算出当前path next.path = fillParams(rawPath, params, `path $&#123;current.path&#125;`) &#125; else if (process.env.NODE_ENV !== 'production') &#123; warn(false, `relative params navigation requires a current route.`) &#125; return next &#125; // 将path拆分成path、hash和query const parsedPath = parsePath(next.path || '') const basePath = (current &amp;&amp; current.path) || '/' // 返回最后拼接完成好的路径，append用于判断是否在当前 (相对) 路径前添加基路径 const path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath // 解析query parseQuery是提供自定义查询字符串的解析/反解析函数，用于覆盖默认行为 const query = resolveQuery( parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery ) // 路由的hash值 let hash = next.hash || parsedPath.hash if (hash &amp;&amp; hash.charAt(0) !== '#') &#123; hash = `#$&#123;hash&#125;` &#125; return &#123; _normalized: true, path, query, hash &#125;&#125; 这个方法首先会判断当前的RawLocation是否已经经过_normalized处理，是的话直接返回，否则的话继续判断当前Location是否有name字段，有的话通过extend方法拷贝一份raw对象直接返回，这个extend方法的实现很简单： 123456export function extend (a, b) &#123; for (const key in b) &#123; a[key] = b[key] &#125; return a&#125; 当上面的情况都不满足，接着进入下一个判断条件，如果有当前Route信息，有params但是没有path的情况，首先会设置_normalized标志位，然后对params参数进行合并处理，然后继续分为两种情况处理，分别是current有name与否，前者的话会直接将current的name和拼接后的params赋值给next后直接返回，后者的话会从路由记录里面找到最新的一条记录的path，调用fillParams方法根据rawPath和params计算当前path，看一下fillParams对相对路径的处理： 1234567891011121314151617181920212223242526272829303132333435/* @flow */import &#123; warn &#125; from './warn'import Regexp from 'path-to-regexp'// $flow-disable-lineconst regexpCompileCache: &#123; [key: string]: Function&#125; = Object.create(null)export function fillParams ( path: string, params: ?Object, routeMsg: string): string &#123; params = params || &#123;&#125; try &#123; const filler = regexpCompileCache[path] || (regexpCompileCache[path] = Regexp.compile(path)) // 如果param中有名为pathMatch的key将他设置为&#123;0, params[patchMatch]&#125;的键值对 // Fix #2505 resolving asterisk routes &#123; name: 'not-found', params: &#123; pathMatch: '/not-found' &#125;&#125; if (params.pathMatch) params[0] = params.pathMatch // 将动态路径参数替换成正式参数 return filler(params, &#123; pretty: true &#125;) &#125; catch (e) &#123; if (process.env.NODE_ENV !== 'production') &#123; warn(false, `missing param for $&#123;routeMsg&#125;: $&#123;e.message&#125;`) &#125; return '' &#125; finally &#123; // delete the 0 if it was added delete params[0] &#125;&#125; 其实这里就是把形如{zapId: 1}的params参数通过Regexp.compile生成的方法拼接到path后面，就像这样： 123const toPath = pathToRegexp.compile('/user/:id')toPath(&#123; id: 123 &#125;) //=&gt; \"/user/123\" 回到create-matcher.js，计算出新的location之后对命名路由和非命名路由进行了不同的处理，如果name存在，从nameMap字典里面匹配出对应的record，如果record不存在通过_createRoute生成一条新的record直接返回，否则取出这条record里面的params的key组成的数组，将currentRoute里面的params以key/value的形式不重复地存入名为location.params的一个对象里面，最后依然是通过fillParams拼接params参数到路径尾部，通过_createRoute方法创建一条新路径返回。 反之，如果是非命名路由，会通过pathList返回path对应的record，然后通过createRoute方法判断是否能够匹配到路由信息，是的话也会通过_createRoute生成一条新路径返回。接下来只要搞懂matchRoute和_createRoute干了什么就行了，先看matchRoute： 123456789101112131415161718192021222324function matchRoute ( regex: RouteRegExp, path: string, params: Object): boolean &#123; const m = path.match(regex) if (!m) &#123; return false &#125; else if (!params) &#123; return true &#125; for (let i = 1, len = m.length; i &lt; len; ++i) &#123; const key = regex.keys[i - 1] const val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i] if (key) &#123; // Fix #1994: using * with props: true generates a param named 0 params[key.name || 'pathMatch'] = val &#125; &#125; return true&#125; 其实就是通过match方法做判断，如果没匹配到直接返回false，如果传入了params会将path里面的params以key/value形式存入，这个传入的params在这里是location.params所以和前面做的是一样的操作。 接着看_createRoute方法，这个方法也在create_matcher.js内部： 1234567891011121314function _createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: Location): Route &#123; if (record &amp;&amp; record.redirect) &#123; return redirect(record, redirectedFrom || location) &#125; if (record &amp;&amp; record.matchAs) &#123; return alias(record, location, record.matchAs) &#125; return createRoute(record, location, redirectedFrom, router)&#125; 无论是否设置了redirect还是alias最后都会重新调用_createRoute，所以这里直接看最后的createRoute方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* @flow */import type VueRouter from '../index'import &#123; stringifyQuery &#125; from './query'const trailingSlashRE = /\\/?$/export function createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter): Route &#123; // 提供自定义查询字符串的解析/反解析函数。覆盖默认行为 const stringifyQuery = router &amp;&amp; router.options.stringifyQuery let query: any = location.query || &#123;&#125; try &#123; query = clone(query) &#125; catch (e) &#123;&#125; const route: Route = &#123; name: location.name || (record &amp;&amp; record.name), meta: (record &amp;&amp; record.meta) || &#123;&#125;, path: location.path || '/', hash: location.hash || '', query, params: location.params || &#123;&#125;, fullPath: getFullPath(location, stringifyQuery), // 完整路径 matched: record ? formatMatch(record) : [] &#125; if (redirectedFrom) &#123; route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) &#125; return Object.freeze(route)&#125;function clone (value) &#123; if (Array.isArray(value)) &#123; return value.map(clone) &#125; else if (value &amp;&amp; typeof value === 'object') &#123; const res = &#123;&#125; for (const key in value) &#123; res[key] = clone(value[key]) &#125; return res &#125; else &#123; return value &#125;&#125;// the starting route that represents the initial stateexport const START = createRoute(null, &#123; path: '/'&#125;)function formatMatch (record: ?RouteRecord): Array&lt;RouteRecord&gt; &#123; const res = [] while (record) &#123; res.unshift(record) record = record.parent &#125; return res&#125;function getFullPath ( &#123; path, query = &#123;&#125;, hash = '' &#125;, _stringifyQuery): string &#123; const stringify = _stringifyQuery || stringifyQuery return (path || '/') + stringify(query) + hash&#125;export function isSameRoute (a: Route, b: ?Route): boolean &#123; if (b === START) &#123; return a === b &#125; else if (!b) &#123; return false &#125; else if (a.path &amp;&amp; b.path) &#123; return ( a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &amp;&amp; a.hash === b.hash &amp;&amp; isObjectEqual(a.query, b.query) ) &#125; else if (a.name &amp;&amp; b.name) &#123; return ( a.name === b.name &amp;&amp; a.hash === b.hash &amp;&amp; isObjectEqual(a.query, b.query) &amp;&amp; isObjectEqual(a.params, b.params) ) &#125; else &#123; return false &#125;&#125;function isObjectEqual (a = &#123;&#125;, b = &#123;&#125;): boolean &#123; // handle null value #1566 if (!a || !b) return a === b const aKeys = Object.keys(a) const bKeys = Object.keys(b) if (aKeys.length !== bKeys.length) &#123; return false &#125; return aKeys.every(key =&gt; &#123; const aVal = a[key] const bVal = b[key] // check nested equality if (typeof aVal === 'object' &amp;&amp; typeof bVal === 'object') &#123; return isObjectEqual(aVal, bVal) &#125; return String(aVal) === String(bVal) &#125;)&#125;export function isIncludedRoute (current: Route, target: Route): boolean &#123; return ( current.path.replace(trailingSlashRE, '/').indexOf( target.path.replace(trailingSlashRE, '/') ) === 0 &amp;&amp; (!target.hash || current.hash === target.hash) &amp;&amp; queryIncludes(current.query, target.query) )&#125;function queryIncludes (current: Dictionary&lt;string&gt;, target: Dictionary&lt;string&gt;): boolean &#123; for (const key in target) &#123; if (!(key in current)) &#123; return false &#125; &#125; return true&#125; 通过传入的record和location创建一个不可被修改的Route对象，其中有个matched属性通过formatMatch方法构建： 12345678function formatMatch (record: ?RouteRecord): Array&lt;RouteRecord&gt; &#123; const res = [] while (record) &#123; res.unshift(record) record = record.parent &#125; return res&#125; 通过循环不断地查找当前record的parent，然后返回这条线上所有的record组成的数组。 路由的跳转无论是Hash路由还是History路由，在初始化的时候都会通过transitionTo方法跳转到初始路径，这个方法也是我们切换路由路径时候使用的方法，下面分析一下该方法的实现过程： 12345678910111213141516171819202122232425transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; // 通过location和current返回初始化Route信息 const route = this.router.match(location, this.current) this.confirmTransition(route, () =&gt; &#123; this.updateRoute(route) // 执行onComplete回调 onComplete &amp;&amp; onComplete(route) this.ensureURL() // fire ready cbs once if (!this.ready) &#123; this.ready = true this.readyCbs.forEach(cb =&gt; &#123; cb(route) &#125;) &#125; &#125;, err =&gt; &#123; // 如果跳转被终止 if (onAbort) &#123; onAbort(err) &#125; if (err &amp;&amp; !this.ready) &#123; this.ready = true this.readyErrorCbs.forEach(cb =&gt; &#123; cb(err) &#125;) &#125; &#125;) &#125; 初始化调用的时候，拿到的是初始化的Route，通过confirmTransition方法进行实际的跳转操作，同时对跳转成功和失败两种情况都设置了回调函数，看一下这个函数的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105confirmTransition (route: Route, onComplete: Function, onAbort?: Function) &#123; const current = this.current const abort = err =&gt; &#123; if (isError(err)) &#123; // 将所有的错误信息都存入errorCbs if (this.errorCbs.length) &#123; this.errorCbs.forEach(cb =&gt; &#123; cb(err) &#125;) &#125; else &#123; warn(false, 'uncaught error during route navigation:') console.error(err) &#125; &#125; onAbort &amp;&amp; onAbort(err) &#125; if ( // 如果是同一个路由路径 isSameRoute(route, current) &amp;&amp; // in the case the route map has been dynamically appended to route.matched.length === current.matched.length ) &#123; // ensureURL在不同的路由实现方式里面该方法的实现不一样 this.ensureURL() // 如果设置了abort方法这里直接调用 return abort() &#125; // 拿到路径的变化部分以及遗弃部分和升级部分 const &#123; updated, deactivated, activated &#125; = resolveQueue(this.current.matched, route.matched) // 维持一个对应路径变化的导航守卫的钩子组成的List const queue: Array&lt;?NavigationGuard&gt; = [].concat( // in-component leave guards extractLeaveGuards(deactivated), // global before hooks this.router.beforeHooks, // in-component update hooks extractUpdateHooks(updated), // in-config enter guards activated.map(m =&gt; m.beforeEnter), // async components resolveAsyncComponents(activated) ) this.pending = route // 定义一个迭代器 const iterator = (hook: NavigationGuard, next) =&gt; &#123; if (this.pending !== route) &#123; return abort() &#125; try &#123; hook(route, current, (to: any) =&gt; &#123; if (to === false || isError(to)) &#123; // next(false) -&gt; abort navigation, ensure current URL this.ensureURL(true) abort(to) &#125; else if ( typeof to === 'string' || (typeof to === 'object' &amp;&amp; ( typeof to.path === 'string' || typeof to.name === 'string' )) ) &#123; // next('/') or next(&#123; path: '/' &#125;) -&gt; redirect abort() if (typeof to === 'object' &amp;&amp; to.replace) &#123; this.replace(to) &#125; else &#123; this.push(to) &#125; &#125; else &#123; // 确认跳转，执行回调 // confirm transition and pass on the value next(to) &#125; &#125;) &#125; catch (e) &#123; abort(e) &#125; &#125; runQueue(queue, iterator, () =&gt; &#123; const postEnterCbs = [] const isValid = () =&gt; this.current === route // wait until async components are resolved before // extracting in-component enter guards // 执行beforeRouteEnter钩子函数 const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid) const queue = enterGuards.concat(this.router.resolveHooks) runQueue(queue, iterator, () =&gt; &#123; if (this.pending !== route) &#123; return abort() &#125; this.pending = null onComplete(route) if (this.router.app) &#123; this.router.app.$nextTick(() =&gt; &#123; postEnterCbs.forEach(cb =&gt; &#123; cb() &#125;) &#125;) &#125; &#125;) &#125;)&#125; 首先定义了一个abort函数用于处理路由跳转失败的情况以及执行onAbort回调，然后判断如果要跳转的路由和当前路由是同一个的话，直接调用this.ensureURL()和abort()，这个ensureURL在不同的路由实现方式里面该方法的实现不一样，最终都是做了路由跳转的操作，紧接着通过resolveQueue方法拿到三个数组，分别存储着固定的部分，遗弃的部分以及更新的部分，这个方法的实现如下： 123456789101112131415161718192021function resolveQueue ( current: Array&lt;RouteRecord&gt;, next: Array&lt;RouteRecord&gt;): &#123; updated: Array&lt;RouteRecord&gt;, activated: Array&lt;RouteRecord&gt;, deactivated: Array&lt;RouteRecord&gt;&#125; &#123; let i const max = Math.max(current.length, next.length) for (i = 0; i &lt; max; i++) &#123; if (current[i] !== next[i]) &#123; break &#125; &#125; return &#123; updated: next.slice(0, i), activated: next.slice(i), deactivated: current.slice(i) &#125;&#125; 路由从current变为next，两个路径的公共部分就是next.slice(0, i)，next.slice(0, i)就是路径需要更新的部分，而current.slice(i)就是路径需要变化的部分。 拿到三个数组之后会构造一个queue队列，里面存储了路径变化要执行的钩子函数，也就是官方说的路由守卫，会按次序执行一些诸如beforeRouteLeave、beforeRouteUpdate等方法，下面还会定义一个迭代器，这个迭代器会根据传入的ro参数来决定执行abort还是next方法，最后执行runQueue方法来执行这个队列，这个方法的定义如下： 12345678910111213141516export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function) &#123; const step = index =&gt; &#123; if (index &gt;= queue.length) &#123; cb() &#125; else &#123; if (queue[index]) &#123; fn(queue[index], () =&gt; &#123; step(index + 1) &#125;) &#125; else &#123; step(index + 1) &#125; &#125; &#125; step(0)&#125; 这里的fn其实就是iterator里面的next函数，只有执行了next函数index才会+1，才会进行管道中的下一个钩子，如果全部钩子执行完了，则导航的状态会变成confirmed(确认的)。 最后可以看一下Vue-Router里面对导航的完整解析流程： 导航被触发。在失活的组件里调用离开守卫。调用全局的 beforeEach 守卫。在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。在路由配置里调用 beforeEnter。解析异步路由组件。在被激活的组件里调用 beforeRouteEnter。调用全局的 beforeResolve 守卫 (2.5+)。导航被确认。调用全局的 afterEach 钩子。触发 DOM 更新。用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 总结传统的路由实现是通过对路径的切换做到的，对于Vue-Router而言，路由模块的本质 就是建立起url和页面之间的映射关系。路由始终会维护当前的线路，路由切换的时候会把当前线路切换到目标线路，切换过程中会执行一系列的导航守卫钩子函数，会更改url，同样也会渲染对应的组件，切换完毕后会把目标线路更新替换当前线路，这样就会作为下一次的路径切换的依据. 参考链接：Vue核心解密","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"vue-router","slug":"vue-router","permalink":"https://www.limuyang.cc/tags/vue-router/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.limuyang.cc/tags/源码阅读/"}]},{"title":"实现一个符合Promise/A+规范的Promise","date":"2019-04-23T23:16:48.000Z","path":"2019/04/23/实现一个符合Promise-A-规范的Promise/","text":"概念所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 简易版Promise的实现在实现一个能通过Promise A+规范测试的Promise版本之前，我们先写一个简易版的Promise，结合我们平常使用Promise的姿势： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 对照Promise A+规范开始撸代码。 123451.1 “promise” is an object or function with a then method whose behavior conforms to this specification.1.2 “thenable” is an object or function that defines a then method.1.3 “value” is any legal JavaScript value (including undefined, a thenable, or a promise).1.4 “exception” is a value that is thrown using the throw statement.1.5 “reason” is a value that indicates why a promise was rejected. 先实现一个Promise的构造函数： 12345678function Promise(executor) &#123; let self = this self.status = 'pending' // 一个promise必须处于三种状态之一： 请求态（pending）， 完成态（fulfilled），拒绝态（rejected） self.value = null self.onResolveCallbacks = [] // Promise resolve的时候可能会有多个回调 self.onRejectCallbacks = [] // 同上 executor(resolve, reject) // 执行executor&#125; 在构造函数内部先使用一个常量self，当异步执行的时候可以获取正确的this对象 Promise的初始状态应该是pending value变量用于存储resolve或者reject的值，这里其实同时表示了规范中的value/reason 当执行完Promise之后当前Promise的status可能还是pending，这个时候要把then方法中传入的回调存储到对应的callBackList 我们知道Promise接受一个函数作为参数，这个函数有resolve和reject两个函数作为参数，resolve函数可以将Promise的状态从pending转为fulfilled，并将异步操作的结果作为参数传递出去，reject函数可以将Promise的状态从pending转为rejected，并将异步操作失败报出的错误作为参数传递出去，下面我们来实现这两个函数： 1234567891011121314151617181920212223242526272829function Promise(executor) &#123; let self = this self.status = 'pending' self.value = null self.onResolveCallbacks = [] self.onRejectCallbacks = [] function resolve(value) &#123; if (self.status === 'pending') &#123; self.status = 'fulfilled' self.value = value self.onResolveCallbacks.forEach(cb =&gt; cb(self.value)) &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; self.status = 'rejected' self.value = reason self.onRejectCallbacks.forEach(cb =&gt; cb(self.value)) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125; 这里有一点需要解释的是，执行executor有可能会出错就像下面这样，如果出错了Promise应该reject这个出错的值： 123new Promise(function(resolve, reject) &#123; throw 2&#125;) 下一步，实现逻辑较为复杂的then函数，也是整个Promise的精髓所在： 12345A promise must provide a then method to access its current or eventual value or reason.A promise’s then method accepts two arguments:promise.then(onFulfilled, onRejected) 因为then方法可以链式调用，所以我们把它构造在Promise的原型链上： 123Promise.prototype.then = function(onFulfilled, onRejected) &#123; // 内部实现&#125; 根据标准2.2.1和2.2.7我们可以写出如下代码： 123456789101112131415Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v // 2.2.1.1 onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125; // 2.2.1.2 if (self.status === 'pending') &#123; self.onResolveCallbacks.push(onFulfilled) self.onRejectCallbacks.push(onRejected) &#125; else if (self.status === 'fulfilled') &#123; onFulfilled(self.value) &#125; else if (self.status === 'rejected') &#123; onRejected(self.value) &#125;&#125; 为了透传我们在onFulfilled/onRejected不是一个函数的时候也创造了一个函数返回当前onFulfilled/onRejected的值，当status处于pending状态，我们不能确定调用onFulfilled还是onRejected，只有等状态确定后才可以处理，所以这里把两个callback存入回调数组里面，如果是确定状态则调用对应的方法即可，这就是最简易版本的Promise，来试一下： 1234567new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;)&#125;).then((value) =&gt; &#123; console.log(value) // 打印结果 1&#125;) 实现一个符合Promise/A+规范的Promise以上面的简易版为基础，继续改造then方法，规范中有提到说then需要返回一个Promise，这也是它可以链式操作的关键所在： 123then must return a promise [3.3].promise2 = promise1.then(onFulfilled, onRejected); 虽然说规范里面允许我们返回同一个Promise，但是我们这里遵循大多数Promise的实现给它返回一个新的Promise： 12345678910111213141516171819202122Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v // 2.2.1.1 onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125; // 2.2.1.2 let returnedPromise = null // 2.2.7 if (self.status === 'pending') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; self.onResolveCallbacks.push(onFulfilled) self.onRejectCallbacks.push(onRejected) &#125;) &#125; else if (self.status === 'fulfilled') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; onFulfilled(self.value) &#125;) &#125; else if (self.status === 'rejected') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; onRejected(self.value) &#125;) &#125;&#125; 根据规范的定义，我们这里还需要定义一个[[Resolve]](promise2, x)解析函数，解析onFulfilled或onRejected的返回值，同时对两个方法执行期间抛出的错误进行reject： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v // 2.2.1.1 onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125; // 2.2.1.2 let returnedPromise = null // 2.2.7 if (self.status === 'pending') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; self.onResolveCallbacks.push(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) self.onRejectCallbacks.push(() =&gt; &#123; try &#123; let x = onRejected(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; else if (self.status === 'fulfilled') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; try &#123; let x = onFulfilled(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125; else if (self.status === 'rejected') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; try &#123; let x = onRejected(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;&#125;function ResolutionProcedure(promise, x, resolvePromise, rejectPromise) &#123; // 内部实现&#125; 接下来只需要关注这个ResolutionProcedure函数的内部实现，这里其实规范都给出了所有的详细步骤，按照规范来做就行： 12345678910111213141516171819202122232425262728293031323334353637383940function ResolutionProcedure(promise, x, resolvePromise, rejectPromise) &#123; try &#123; if (promise === x) &#123; return rejectPromise(new TypeError('2.3.1')) &#125; if (x instanceof Promise) //2.3.2 x.then(((value)=&gt;&#123; ResolutionProcedure(promise, value, reslove, reject); &#125;,(reason)=&gt;&#123; reject(reason) &#125;)); let called = false // 2.3.3.3.3 if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; // 2.3.3 try &#123; // 2.3.3.1 let then = x.then if (typeof then === 'function') &#123; // 2.3.3.3 then.call(x, (value) =&gt; &#123; if (called) return called = true return ResolutionProcedure(promise, value, resolvePromise, rejectPromise) &#125;, (reason) =&gt; &#123; if (called) return called = true return rejectPromise(reason) &#125;) &#125; else &#123; return resolvePromise(x) // 2.3.4 &#125; &#125; catch (e) &#123; if (called) return called = true return rejectPromise(e) // 2.3.3.2 &#125; &#125; else &#123; return resolvePromise(x) // 2.3.3.4 &#125; &#125; catch (e) &#123; return rejectPromise(e) &#125;&#125; 然后我们注意到规范2.2.4中说了只有在执行栈包含平台代码的时候才可以调用onFulfilled和onRejected： 1onFulfilled or onRejected must not be called until the execution context stack contains only platform code. 解释文案中也说了其实就是异步执行，我们可以用setTimeout或setImmediate来做到这一点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v // 2.2.1.1 onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125; // 2.2.1.2 let returnedPromise = null // 2.2.7 if (self.status === 'pending') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; self.onResolveCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) self.onRejectCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125;) &#125; else if (self.status === 'fulfilled') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125; else if (self.status === 'rejected') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125;&#125; 测试这里用官方提供的promises-aplus-tests来验证我们写出来的库是否符合规范，为了跑测试我们还需要加上deferred方法： 12345678910Promise.deferred = function() &#123; let defer = &#123;&#125; defer.promise = new Promise((resolve, reject) =&gt; &#123; defer.resolve = resolve defer.reject = reject &#125;) return defer&#125;module.exports = Promise 跑一下测试： 123npm install -g promises-aplus-tests promises-aplus-tests ./promise.js 说明我们写的库是符合的Promise/A+标准的 扩展Promise/A+规范只是定义了then方法，但是Promise本身还有一些其他的方法，我们也可以实现一下： catch 123Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125; race 1234567Promise.prototype.race = function(values) &#123; return new Promise(function(resolve, reject) &#123; for (let i = 0, len = values.length; i &lt; len; i++) &#123; values[i].then(resolve, reject) &#125; &#125;)&#125; all 1234567891011121314151617181920Promise.all = function(promises) &#123; return new Promise(function(resolve, reject) &#123; let resolvedCounter = 0 let promiseNum = promises.length let resolvedValues = new Array(promiseNum) for (let i = 0; i &lt; promiseNum; i++) &#123; (function(i) &#123; Promise.resolve(promises[i]).then(function(value) &#123; resolvedCounter++ resolvedValues[i] = value if (resolvedCounter === promiseNum) &#123; return resolve(resolvedValues) &#125; &#125;, function(reason) &#123; return reject(reason) &#125;) &#125;)(i) &#125; &#125;)&#125; finally 123456789101112131415Promise.prototype.finally = function(callback) &#123; let constructor = this.constructor return this.then( function(value) &#123; return constructor.resolve(callback()).then(function() &#123; return value &#125;) &#125;, function(reason) &#123; return constructor.resolve(callback()).then(function() &#123; return constructor.reject(reason) &#125;) &#125; )&#125; 最后奉上实现后的全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185function Promise(executor) &#123; let self = this self.status = 'pending' self.value = null self.onResolveCallbacks = [] self.onRejectCallbacks = [] function resolve(value) &#123; if (self.status === 'pending') &#123; self.status = 'fulfilled' self.value = value self.onResolveCallbacks.forEach(cb =&gt; cb(self.value)) &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; self.status = 'rejected' self.value = reason self.onRejectCallbacks.forEach(cb =&gt; cb(self.value)) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v // 2.2.1.1 onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125; // 2.2.1.2 let returnedPromise = null // 2.2.7 if (self.status === 'pending') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; self.onResolveCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) self.onRejectCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125;) &#125; else if (self.status === 'fulfilled') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125; else if (self.status === 'rejected') &#123; return returnedPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) ResolutionProcedure(returnedPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125;&#125;Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125;Promise.prototype.race = function(values) &#123; return new Promise(function(resolve, reject) &#123; for (let i = 0, len = values.length; i &lt; len; i++) &#123; values[i].then(resolve, reject) &#125; &#125;)&#125;Promise.all = function(promises) &#123; return new Promise(function(resolve, reject) &#123; let resolvedCounter = 0 let promiseNum = promises.length let resolvedValues = new Array(promiseNum) for (let i = 0; i &lt; promiseNum; i++) &#123; (function(i) &#123; Promise.resolve(promises[i]).then(function(value) &#123; resolvedCounter++ resolvedValues[i] = value if (resolvedCounter === promiseNum) &#123; return resolve(resolvedValues) &#125; &#125;, function(reason) &#123; return reject(reason) &#125;) &#125;)(i) &#125; &#125;)&#125;Promise.prototype.finally = function(callback) &#123; let constructor = this.constructor return this.then( function(value) &#123; return constructor.resolve(callback()).then(function() &#123; return value &#125;) &#125;, function(reason) &#123; return constructor.resolve(callback()).then(function() &#123; return constructor.reject(reason) &#125;) &#125; )&#125;function ResolutionProcedure(promise, x, resolvePromise, rejectPromise) &#123; try &#123; if (promise === x) &#123; return rejectPromise(new TypeError('2.3.1')) &#125; if (x instanceof Promise) //2.3.2 x.then(((value) =&gt; &#123; ResolutionProcedure(promise, value, reslove, reject) &#125;, (reason) =&gt; &#123; reject(reason) &#125;)) let called = false // 2.3.3.3.3 if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; // 2.3.3 try &#123; // 2.3.3.1 let then = x.then if (typeof then === 'function') &#123; // 2.3.3.3 then.call(x, (value) =&gt; &#123; if (called) return called = true return ResolutionProcedure(promise, value, resolvePromise, rejectPromise) &#125;, (reason) =&gt; &#123; if (called) return called = true return rejectPromise(reason) &#125;) &#125; else &#123; return resolvePromise(x) // 2.3.4 &#125; &#125; catch (e) &#123; if (called) return called = true return rejectPromise(e) // 2.3.3.2 &#125; &#125; else &#123; return resolvePromise(x) // 2.3.3.4 &#125; &#125; catch (e) &#123; return rejectPromise(e) &#125;&#125;Promise.deferred = function() &#123; let defer = &#123;&#125; defer.promise = new Promise((resolve, reject) =&gt; &#123; defer.resolve = resolve defer.reject = reject &#125;) return defer&#125;module.exports = Promise","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"Promise","slug":"Promise","permalink":"https://www.limuyang.cc/tags/Promise/"}]},{"title":"阅读分析Vuex源码","date":"2019-03-29T16:28:18.000Z","path":"2019/03/29/阅读分析Vuex源码/","text":"不管是Vue框架还是React框架，在实际开发使用的过程中我们都会有很多情况下都会有状态共享的需求，这些状态共享会发生在父子组件和兄弟组件之间，我们为了维护这些状态经常会写很多非必要性的代码，这些代码一多起来，维护就会变得很困难，正是由于有这种需求，人们开发了许多相关的库，从Flux到Redux再到Vuex，这些库的大致思路都是：将共享的状态抽离出来，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，达到代码结构化和易维护的目的。 简单状态管理起步在说到Vuex之前，我们可以先了解下简单的状态管理，也就是Store模式 当你有一处需要多个实例共享的状态，可以简单地通过维护一份数据来实现共享： 123456789const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 现在当 sourceOfTruth 发生变化，vmA和vmB都将自动的更新引用它们的视图，但是采用这种方式，在任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。为了解决这个问题，我们可以采用一个简单的Store模式: 1234567891011121314var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log('setMessageAction triggered with', newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log('clearMessageAction triggered') this.state.message = '' &#125;&#125; 所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么，此外，每个实例/组件仍然可以拥有和管理自己的私有状态： 12345678910111213var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，这样的话，一个Flux架构就实现了。 目录结构 Vuex 的版本是 3.1.0 1234567891011121314目录结构├── helpers.js 提供action、mutations以及getters的查找API├── index.esm.js├── index.js 是源码主入口文件，提供store的各module构建安装├── mixin.js 提供了store在Vue实例上的装载注入├── module 提供module对象与module对象树的创建功能│ ├── module-collection.js│ └── module.js├── plugins 提供开发辅助插件，如“时光穿梭”功能│ ├── devtool.js│ └── logger.js├── store.js 构建store└── util.js 提供了工具方法如find、deepCopy、forEachValue以及assert等方法。 一般我看源码都是从入口文件开始看，这里是index.js： 12345678910111213import &#123; Store, install &#125; from './store'import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from './helpers'export default &#123; Store, install, version: '__VERSION__', mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers&#125; 入口文件对外暴露了Vuex相关的API，至于为什么这里有一个install，其实是因为Vuex是被当做Vue的插件来使用的，开发一个Vue插件的话就需要对外暴露一个install方法，这个方法第一个参数Vue构造器，第二个参数是一个可选的选项对象。 Store.jsStore.js对外暴露出了Store这个类和install这个方法，在开始分析Store.js之前我们先看一下install： 12345678910111213export function install (_Vue) &#123; if (Vue &amp;&amp; _Vue === Vue) &#123; // 报错，已经使用了 Vue.use(Vuex)方法注册了 if (process.env.NODE_ENV !== 'production') &#123; console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) &#125; return &#125; Vue = _Vue applyMixin(Vue)&#125; 逻辑很简单，只是把传入的_Vue赋值给Vue，然后调用applyMixin(Vue)方法，这个方法定义在src/mixin.js中： 1234567891011121314151617181920212223242526272829303132333435363738394041export default function (Vue) &#123; const version = Number(Vue.version.split('.')[0]) // 在全局beforeCreate钩子里面初始化vuex if (version &gt;= 2) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;) &#125; else &#123; // override init and inject vuex init procedure // for 1.x backwards compatibility. const _init = Vue.prototype._init Vue.prototype._init = function (options = &#123;&#125;) &#123; options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) &#125; &#125; /** * Vuex init hook, injected into each instances init hooks list. */ function vuexInit () &#123; const options = this.$options // store injection if (options.store) &#123; // new Vue(&#123; // el: '#app', // router, // store, // render: h =&gt; h(App) // &#125;) // 这里获取的store就是上面初始化Vue的时候传入的store，所以后面我们可以通过this.$store获取到store实例 this.$store = typeof options.store === 'function' ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; // 如果是子组件，则从根组件获取store this.$store = options.parent.$store &#125; &#125;&#125; applyMixin方法主要是为了在beforeCreate的全局钩子给所有子组件注入$store属性方便后续调用，设置到this上所以后面再全局都可以通过this.$store来访问store对象 Store的实例化当我们引入Vuex之后下一步的操作就是实例化一个Store对象，会返回一个store实例并且传入Vue的构造器： 1234567891011121314151617const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)new Vue(&#123; el: '#app', router, store, render: h =&gt; h(App)&#125;) 在Store的构造函数当中，首先会对执行环境进行断言(是否调用了Vue.use(Vuex)来初始化/是否支持Promise等)： 123456789101112131415161718export class Store &#123; constructor (options = &#123;&#125;) &#123; // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 // 在浏览器环境下，如果插件还未安装则它会自动安装。 // 它允许用户在某些情况下避免自动安装。 if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue) &#125; if (process.env.NODE_ENV !== 'production') &#123; assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `store must be called with the new operator.`) &#125; // 省略无关代码&#125; assert这个方法被定义在utils.js当中： 123export function assert (condition, msg) &#123; if (!condition) throw new Error(`[vuex] $&#123;msg&#125;`)&#125; 其实这个方法的作用就是抛出一些异常信息，紧接着定义了一些Store的内部变量： 1234567891011121314151617181920212223242526272829303132const &#123; // 一个数组，包含应用在 store 上的插件方法 plugins = [], // 使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误 strict = false &#125; = options // store internal state // 判断是否是通过mutation更改的state this._committing = false // 存放action this._actions = Object.create(null) this._actionSubscribers = [] // 存放mutations this._mutations = Object.create(null) // 存放getters this._wrappedGetters = Object.create(null) // 传入的options对象，其实就是初始化时候传入的对象 new Vuex.Store(&#123;options&#125;) // &#123; // modules: &#123; // cart, // products // &#125;, // strict: debug, // plugins: debug ? [createLogger()] : [] // &#125;) // 初始化modules this._modules = new ModuleCollection(options) // 根据namespace来map对应的module this._modulesNamespaceMap = Object.create(null) this._subscribers = [] // 用$watch监测store数据的变化 this._watcherVM = new Vue() 这里有个很有意思的知识点，就是我们发现这里创建空对象的时候用的都是Object.create(null)，这是因为如果直接用一个{}赋值的话等价于Object.create(Object.prototype)，它还会从Object.prototype上继承一些方法如hasOwnProperty、isPrototypeOf等，如果用Object.create(null)则说明这个对象的原型是null也就是没有继承任何对象。除此之外，在Store的初始化过程中还有几个主要的方法，下面进行逐一的分析： 模块的初始化由于Store使用的是单一的状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 1234567891011121314151617181920212223const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;,&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 完成这种树形结构的构建入口就是： 12345678910// 传入的options对象，其实就是初始化时候传入的对象 new Vuex.Store(&#123;options&#125;)// &#123;// modules: &#123;// cart,// products// &#125;,// strict: debug,// plugins: debug ? [createLogger()] : []// &#125;)this._modules = new ModuleCollection(options) ModuleCollection这个类的定义在src/module/module-collection.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import Module from './module'import &#123; assert, forEachValue &#125; from '../util'export default class ModuleCollection &#123; constructor (rawRootModule) &#123; // register root module (Vuex.Store options) this.register([], rawRootModule, false) &#125; // 获取对应于path的Module get (path) &#123; // this.root根Module return path.reduce((module, key) =&gt; &#123; return module.getChild(key) &#125;, this.root) &#125; getNamespace (path) &#123; let module = this.root return path.reduce((namespace, key) =&gt; &#123; module = module.getChild(key) return namespace + (module.namespaced ? key + '/' : '') &#125;, '') &#125; update (rawRootModule) &#123; update([], this.root, rawRootModule) &#125; register (path, rawModule, runtime = true) &#123; if (process.env.NODE_ENV !== 'production') &#123; // 检测module对应的函数的形式是否正确 assertRawModule(path, rawModule) &#125; // 构建Module对象 const newModule = new Module(rawModule, runtime) if (path.length === 0) &#123; this.root = newModule &#125; else &#123; // 获取Parent Module const parent = this.get(path.slice(0, -1)) // 添加子Module parent.addChild(path[path.length - 1], newModule) &#125; // register nested modules if (rawModule.modules) &#123; // 递归注册子Module forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123; this.register(path.concat(key), rawChildModule, runtime) &#125;) &#125; &#125; unregister (path) &#123; const parent = this.get(path.slice(0, -1)) const key = path[path.length - 1] if (!parent.getChild(key).runtime) return parent.removeChild(key) &#125;&#125;function update (path, targetModule, newModule) &#123; if (process.env.NODE_ENV !== 'production') &#123; assertRawModule(path, newModule) &#125; // update target module targetModule.update(newModule) // update nested modules if (newModule.modules) &#123; for (const key in newModule.modules) &#123; if (!targetModule.getChild(key)) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.warn( `[vuex] trying to add a new module '$&#123;key&#125;' on hot reloading, ` + 'manual reload is needed' ) &#125; return &#125; update( path.concat(key), targetModule.getChild(key), newModule.modules[key] ) &#125; &#125;&#125;const functionAssert = &#123; assert: value =&gt; typeof value === 'function', expected: 'function'&#125;const objectAssert = &#123; assert: value =&gt; typeof value === 'function' || (typeof value === 'object' &amp;&amp; typeof value.handler === 'function'), expected: 'function or object with \"handler\" function'&#125;// actions使用objectAssert是因为在带命名空间的模块注册全局action时action的定义会放在函数handler中const assertTypes = &#123; getters: functionAssert, mutations: functionAssert, actions: objectAssert&#125;function assertRawModule (path, rawModule) &#123; Object.keys(assertTypes).forEach(key =&gt; &#123; if (!rawModule[key]) return const assertOptions = assertTypes[key] // 循环getters/mutations/actions // value和type对应函数体和函数名 forEachValue(rawModule[key], (value, type) =&gt; &#123; assert( assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected) ) &#125;) &#125;)&#125;function makeAssertionMessage (path, key, type, value, expected) &#123; let buf = `$&#123;key&#125; should be $&#123;expected&#125; but \"$&#123;key&#125;.$&#123;type&#125;\"` if (path.length &gt; 0) &#123; buf += ` in module \"$&#123;path.join('.')&#125;\"` &#125; buf += ` is $&#123;JSON.stringify(value)&#125;.` return buf&#125; 实例化ModuleCollection其实就是执行register方法，这个方法接受3个参数，其中path参数就是module的路径，这个值是我们拆分module时候module的key组成的一个数组，以上面为例的话，moduleA和moduleB的path分别为[&quot;a&quot;]和[&quot;b&quot;]，如果他们还有子module则子module的path的形式大致如[&quot;a&quot;，&quot;a1&quot;]/[&quot;b&quot;，&quot;b1&quot;]，第二个参数其实是定义module的配置，像rawRootModule就是我们构建一个Store的时候传入的那个对象，第三个参数runtime表示是否是一个运行时创建的module，紧接着在register方法内部通过assertRawModule方法遍历module内部的getters、mutations、actions是否符合要求，紧接着通过const newModule = new Module(rawModule, runtime)构建一个module对象，看一眼module类的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import &#123; forEachValue &#125; from '../util'// Base data struct for store's module, package with some attribute and methodexport default class Module &#123; constructor (rawModule, runtime) &#123; this.runtime = runtime // Store some children item this._children = Object.create(null) // Store the origin module object which passed by programmer this._rawModule = rawModule const rawState = rawModule.state // Store the origin module's state // state() &#123; // return &#123; // // state here instead // &#125; // &#125; this.state = (typeof rawState === 'function' ? rawState() : rawState) || &#123;&#125; &#125; get namespaced () &#123; return !!this._rawModule.namespaced &#125; addChild (key, module) &#123; this._children[key] = module &#125; removeChild (key) &#123; delete this._children[key] &#125; getChild (key) &#123; return this._children[key] &#125; update (rawModule) &#123; this._rawModule.namespaced = rawModule.namespaced if (rawModule.actions) &#123; this._rawModule.actions = rawModule.actions &#125; if (rawModule.mutations) &#123; this._rawModule.mutations = rawModule.mutations &#125; if (rawModule.getters) &#123; this._rawModule.getters = rawModule.getters &#125; &#125; forEachChild (fn) &#123; forEachValue(this._children, fn) &#125; forEachGetter (fn) &#123; if (this._rawModule.getters) &#123; forEachValue(this._rawModule.getters, fn) &#125; &#125; forEachAction (fn) &#123; if (this._rawModule.actions) &#123; forEachValue(this._rawModule.actions, fn) &#125; &#125; forEachMutation (fn) &#123; if (this._rawModule.mutations) &#123; forEachValue(this._rawModule.mutations, fn) &#125; &#125;&#125; 只是简单地描述了构建出来的每个模块的一些属性和方法，回到上面的register函数，构建完Module之后，我们先判断path的长度，如果长度为0说明是根module，将它赋值给this.root，否则的话获取到这个module的parent，然后通过module的addChild方法建立模块之间的父子关系： 1234// 获取Parent Moduleconst parent = this.get(path.slice(0, -1))// 添加子Moduleparent.addChild(path[path.length - 1], newModule) 这里调用了get方法，传入的path是parent模块的path： 123456get (path) &#123; // this.root根Module return path.reduce((module, key) =&gt; &#123; return module.getChild(key) &#125;, this.root) &#125; 因为path是整个模块树的路径，这里通过reduce方法一层层解析去找到对应模块，查找的过程是用的module.getChild(key)方法，返回的是this._children[key]，这些_children就是通过执行parent.addChild(path[path.length - 1], newModule)方法添加的，就这样，每一个模块都通过path去寻找到parent`module，然后通过addChild建立父子关系，逐级递进，构建完成整个module`树。 模块的安装接下来回到Store.js，初始化modules之后会执行一些bind操作： 12345678const store = thisconst &#123; dispatch, commit &#125; = thisthis.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload)&#125;this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options)&#125; 这是为了当我们在组件内部使用this.$store.commit/this.$store.dispatch方法时候的this指向的是当前的store而不是组件本身，这里先略过commit和dispatch方法的实现，先分析Store.js的初始化操作，在初始化module之后会进行module安装的一些操作： 12345const state = this._modules.root.state// init root module.// this also recursively registers all sub-modules// and collects all module getters inside this._wrappedGettersinstallModule(this, state, [], this._modules.root) 看一眼installModule方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142function installModule (store, rootState, path, module, hot) &#123; // 判断是否是根module const isRoot = !path.length // 获取module的命名空间 const namespace = store._modules.getNamespace(path) // 将module的命名空间和module本身一一对应存储在_modulesNamespaceMap对象里面方便后续查找 if (module.namespaced) &#123; store._modulesNamespaceMap[namespace] = module &#125; // set state if (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; Vue.set(parentState, moduleName, module.state) &#125;) &#125; const local = module.context = makeLocalContext(store, namespace, path) module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) &#125;) module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot) &#125;)&#125; 这个方法接受5个参数：store意味着root store、state就是root state、path是当前模块路径、module是当前模块，hot表示是否是热更新。首先用一个变量isRoot判断是否是根module，然后通过ModuleCollection类的getNamespace获取当前路径的命名空间，这里提一下Vuex里面命名空间的概念： 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如： 12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: &#123; ... &#125;, getters: &#123; profile () &#123; ... &#125; // -&gt; getters['account/profile'] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: &#123; ... &#125;, getters: &#123; popular () &#123; ... &#125; // -&gt; getters['account/posts/popular'] &#125; &#125; &#125; &#125; &#125;&#125;) 回到installModule方法，我么可以看一下根据path来获取namespace的方法实现： 1234567getNamespace (path) &#123; let module = this.root return path.reduce((namespace, key) =&gt; &#123; module = module.getChild(key) return namespace + (module.namespaced ? key + '/' : '') &#125;, '') &#125; 从根module开始，通过reduce方法沿着path一层层查找子module，然后如果发现该module配置了namespaced，就把该path拼接到namespace后面，最后返回完整的路径。接下来如果该module配置了namespaced，则把该module的namespace和module本身一一对应存储到_modulesNamespaceMap对象里面方便后续查找： 1234// 将module的命名空间和module本身一一对应存储在_modulesNamespaceMap对象里面方便后续查找if (module.namespaced) &#123; store._modulesNamespaceMap[namespace] = module&#125; 紧接着是非root module下的模块state初始化逻辑： 12345678// set stateif (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; Vue.set(parentState, moduleName, module.state) &#125;)&#125; 先通过getNestedState获取父模块的state，这个方法的实现大同小异，都是通过reduce函数一层层查找到子模块的state： 12345function getNestedState (state, path) &#123; return path.length ? path.reduce((state, key) =&gt; state[key], state) : state&#125; 随后我们拿到子module的名称，调用store对象的_withCommit方法，这个方法里面的函数执行的操作是给父模块的state添加一个名字是module的名称的响应式属性，看一下这个方法的作用： 123456_withCommit (fn) &#123; const committing = this._committing this._committing = true fn() this._committing = committing &#125; _committing的初始值为false，用来判断是否是通过mutation来更改的state，因为在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误，在Store.js的源码中有相关代码体现这一点： 123456789101112if (store.strict) &#123; enableStrictMode(store)&#125;function enableStrictMode (store) &#123; store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123; if (process.env.NODE_ENV !== 'production') &#123; assert(store._committing, `do not mutate vuex store state outside mutation handlers.`) &#125; &#125;, &#123; deep: true, sync: true &#125;)&#125; store._vm是一个在Store.js内置的Vue对象： 123456store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed&#125;) 然后通过Vue的实例方法$watch监听每一次state的变化，通过断言判断当前state的变化是否是通过提交一个mutation来引起的，不是的话就报错do not mutate vuex store state outside mutation handlers。 初始化非root module下的state之后下一步操作是构造一个当前module的上下文环境： 1const local = module.context = makeLocalContext(store, namespace, path) makeLocalContext支持3个参数，分别是root store、当前module的namespace以及当前module的path： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * make localized dispatch, commit, getters and state * if there is no namespace, just use root ones */function makeLocalContext (store, namespace, path) &#123; const noNamespace = namespace === '' const local = &#123; dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._actions[type]) &#123; console.error(`[vuex] unknown local action type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; return store.dispatch(type, payload) &#125;, commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123; const args = unifyObjectStyle(_type, _payload, _options) const &#123; payload, options &#125; = args let &#123; type &#125; = args if (!options || !options.root) &#123; type = namespace + type if (process.env.NODE_ENV !== 'production' &amp;&amp; !store._mutations[type]) &#123; console.error(`[vuex] unknown local mutation type: $&#123;args.type&#125;, global type: $&#123;type&#125;`) return &#125; &#125; store.commit(type, payload, options) &#125; &#125; // getters and state object must be gotten lazily // because they will be changed by vm update Object.defineProperties(local, &#123; getters: &#123; get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) &#125;, state: &#123; get: () =&gt; getNestedState(store.state, path) &#125; &#125;) return local&#125; 通过一个变量noNamespace判断module是否配置了namespaced属性，然后构建一个local对象，这个对象包含了commit和dispatch方法，两个方法定义过程差不多，以commit为例，如果没有namespaced属性，这个commit直接指向了store.commit，否则构建一个函数，这个函数首先会对传入的参数顺序进行格式化，unifyObjectStyle方法兼容了载荷和对象风格的两种提交方式： 12345678910111213function unifyObjectStyle (type, payload, options) &#123; if (isObject(type) &amp;&amp; type.type) &#123; options = payload payload = type type = type.type &#125; if (process.env.NODE_ENV !== 'production') &#123; assert(typeof type === 'string', `expects string as the type, but found $&#123;typeof type&#125;.`) &#125; return &#123; type, payload, options &#125;&#125; 如果是对象风格的提交方式则对参数位置进行调整，然后返回一个调整位置后的对象，如果没有在commit方法里面设置root：true参数，则将type和namespace拼接之后执行commit方法，如果设置了root：true意味着允许在命名空间模块里提交根的mutation。 构建完local对象后会在local对象上定义两个属性getters和state： 123456789101112// getters and state object must be gotten lazily// because they will be changed by vm updateObject.defineProperties(local, &#123; getters: &#123; get: noNamespace ? () =&gt; store.getters : () =&gt; makeLocalGetters(store, namespace) &#125;, state: &#123; get: () =&gt; getNestedState(store.state, path) &#125;&#125;) state的获取比较简单，就是根据root state和当前module的path获取该module的state，我们看getters的实现，如果没有namespace，直接返回root store的getters，否则调用makeLocalGetters获取对应namespace的getters，看一下makeLocalGetters方法的实现： 12345678910111213141516171819202122function makeLocalGetters (store, namespace) &#123; const gettersProxy = &#123;&#125; const splitPos = namespace.length Object.keys(store.getters).forEach(type =&gt; &#123; // skip if the target getter is not match this namespace if (type.slice(0, splitPos) !== namespace) return // extract local getter type const localType = type.slice(splitPos) // Add a port to the getters proxy. // Define as getter property because // we do not want to evaluate the getters in this time. Object.defineProperty(gettersProxy, localType, &#123; get: () =&gt; store.getters[type], enumerable: true &#125;) &#125;) return gettersProxy&#125; 这个方法对this.getters上所有的可玫举属性进行遍历，然后截取type的包含namespace的部分和传入的namespace进行对比，找到后截取type里面的后半部分，也就是不包含namespace的部分，然后定义了gettersProxy的get属性并将其返回。 回到installModule方法，在完成构建local之后，会循环遍历module中定义的mutation、action、getters然后执行注册逻辑，这几个操作都差不多，我们看一个mutation的： 12345678910111213141516171819202122 module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;)forEachMutation (fn) &#123; if (this._rawModule.mutations) &#123; forEachValue(this._rawModule.mutations, fn) &#125; &#125; export function forEachValue (obj, fn) &#123; // 将对象里面的每一项组合成数组 Object.keys(obj).forEach(key =&gt; fn(obj[key], key)) &#125; function registerMutation (store, type, handler, local) &#123; const entry = store._mutations[type] || (store._mutations[type] = []) entry.push(function wrappedMutationHandler (payload) &#123; handler.call(store, local.state, payload) &#125;) &#125; 实际上就是给root store的_mutations对象的对应type`push一个处理函数，这个函数调用时候会将handler的this指向root store。 在installModule的最后会循环遍历子module然后执行子module的installModule`方法： 123module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot) &#125;) 至此，installModule方法分析完毕 初始化store vm这是实例化Store的最后一步，通过resetStoreVM方法初始化vm以及注册_wrappedGetters，其中有些代码上面分析过，这里先贴出全部相关代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function resetStoreVM (store, state, hot) &#123; const oldVm = store._vm // bind store public getters store.getters = &#123;&#125; const wrappedGetters = store._wrappedGetters const computed = &#123;&#125; forEachValue(wrappedGetters, (fn, key) =&gt; &#123; // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters &#125;) &#125;) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent Vue.config.silent = true store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed &#125;) Vue.config.silent = silent // enable strict mode for new vm if (store.strict) &#123; enableStrictMode(store) &#125; if (oldVm) &#123; if (hot) &#123; // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; &#123; oldVm._data.$$state = null &#125;) &#125; Vue.nextTick(() =&gt; oldVm.$destroy()) &#125;&#125; Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。这里首先遍历wrappedGetters得到对应的fn组成的数组，然后将其定义为一个个计算属性computed[key] = () =&gt; fn(store)，fn(store)其实就是执行了下面的方法： 12345678store._wrappedGetters[type] = function wrappedGetter (store) &#123; return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) &#125; _随后给store.getters新增属性，访问这些属性也就是使用this.store.getters的时候拿到的是key对应的计算属性的值: 1234Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters &#125;) 执行这个getter对应的函数等价于执行了computed[key] = () =&gt; fn(store)这个计算属性对应的函数，由于这个函数依赖了store，所以根据计算属性的特性在store变化的时候这个getter也会得到相应的更新。方法的最后，处理了hotUpdate时候的逻辑，即销毁旧的实例： 12345678910111213141516171819hotUpdate (newOptions) &#123; this._modules.update(newOptions) resetStore(this, true) &#125;function resetStoreVM (store, state, hot) &#123; const oldVm = store._vm // ... if (oldVm) &#123; if (hot) &#123; // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; &#123; oldVm._data.$$state = null &#125;) &#125; Vue.nextTick(() =&gt; oldVm.$destroy()) &#125;&#125; 至此，整个Store.js的主题初始化流程已经分析完毕，下面分析一写内置函数以及辅助函数的实现 工具函数更改Vuex的store中的状态的唯一方法是提交mutation。Vuex中的mutation非常类似于事件：每个mutation都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 我们不能直接调用一个mutation handler，需要以相应的type调用store.commit方法： 1store.commit('increment') 看一下commit方法相关的实现： 1234567891011121314151617181920212223242526272829303132333435commit (_type, _payload, _options) &#123; // 将对象风格的commit格式化 const &#123; type, payload, options &#125; = unifyObjectStyle(_type, _payload, _options) const mutation = &#123; type, payload &#125; // 通过mutation type找到对应的回调函数handler并执行 const entry = this._mutations[type] if (!entry) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error(`[vuex] unknown mutation type: $&#123;type&#125;`) &#125; return &#125; this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;) &#125;) // 通知所有的订阅者 this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) &#123; console.warn( `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools' ) &#125; &#125; 首先同样是将载荷方式和对象方式的commit格式化，然后找到type对应的mutation，在确保数据更新方式正确的情况下循环执行mutation里面的方法，然后所有mutation相关的订阅者。 dispatch的逻辑要稍微复杂一些，因为通过dispatch分发action是可以执行异步操作的，然后在action内部执行异步操作后再commit一个mutation： 123456789101112131415161718192021222324252627282930313233343536373839404142434445dispatch (_type, _payload) &#123; // 对象风格的dispatch格式化 const &#123; type, payload &#125; = unifyObjectStyle(_type, _payload) const action = &#123; type, payload &#125; const entry = this._actions[type] if (!entry) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error(`[vuex] unknown action type: $&#123;type&#125;`) &#125; return &#125; // 从 3.1.0 起，subscribeAction 也可以指定订阅处理函数的被调用时机应该在一个 action 分发之前还是之后 (默认行为是之前) try &#123; this._actionSubscribers .filter(sub =&gt; sub.before) .forEach(sub =&gt; sub.before(action, this.state)) &#125; catch (e) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.warn(`[vuex] error in before action subscribers: `) console.error(e) &#125; &#125; const result = entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload) return result.then(res =&gt; &#123; try &#123; this._actionSubscribers .filter(sub =&gt; sub.after) .forEach(sub =&gt; sub.after(action, this.state)) &#125; catch (e) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.warn(`[vuex] error in after action subscribers: `) console.error(e) &#125; &#125; return res &#125;) &#125; 同样是先格式化参数，然后type对应的action，先判断该type是否存在，然后执行_actionSubscribers里面在action分发之前的回调，这是3.1.0开始有的新功能，可以指定订阅处理函数的被调用时机应该在一个 action 分发之前还是之后 (默认行为是之前)，这个功能多用于插件使用，然后分发action，如果同一个type的action有多个就用Promise.all去分发，否则直接传入载荷，在执行分发action完毕之后执行_actionSubscribers里面在action分发之后的回调，至此完成一次dispatch。 辅助函数为了解决重复代码的冗余性，Vuex对外提供了一些工具函数，这些工具函数会自动帮我们生成计算属性减少工作量，这些函数都位于src/helpers.js目录下，这里可以分析一下mapState的实现： 1234567891011121314151617181920212223242526272829/** * Reduce the code which written in Vue.js for getting the state. * @param &#123;String&#125; [namespace] - Module's namespace * @param &#123;Object|Array&#125; states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it. * @param &#123;Object&#125; */export const mapState = normalizeNamespace((namespace, states) =&gt; &#123; const res = &#123;&#125; normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedState () &#123; let state = this.$store.state let getters = this.$store.getters if (namespace) &#123; const module = getModuleByNamespace(this.$store, 'mapState', namespace) if (!module) &#123; return &#125; state = module.context.state getters = module.context.getters &#125; return typeof val === 'function' ? val.call(this, state, getters) : state[val] &#125; // mark vuex getter for devtools res[key].vuex = true &#125;) return res&#125;) mapState函数可以传递两个参数，第一个参数是可选参数，代表命名空间字符串，对象形式的第二个参数的成员可以是一个函数： 1mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object 执行mapState其实就是执行normalizeNamespace返回的函数，这个函数的作用也很简单： 1234567891011121314151617/** * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map. * @param &#123;Function&#125; fn * @return &#123;Function&#125; */function normalizeNamespace (fn) &#123; return (namespace, map) =&gt; &#123; if (typeof namespace !== 'string') &#123; map = namespace namespace = '' &#125; else if (namespace.charAt(namespace.length - 1) !== '/') &#123; namespace += '/' &#125; return fn(namespace, map) &#125;&#125; 判断是否传入了namespace参数，没有的话，将namespace赋值给map参数，如果传了namespace则拼接好路径，最后将处理好的map作为states传入处理函数。这个函数首先会对states执行normalizeMap处理，这个方法的作用是把我们传入mapState的数组/对象统一转换成一个内部元素都是形如{ key: &#39;a&#39;, val: 1 }的数组： 12345function normalizeMap (map) &#123; return Array.isArray(map) ? map.map(key =&gt; (&#123; key, val: key &#125;)) : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))&#125; 然后循环处理数组，结构每一项的key和val，用一个空对象存储，key作为这个空对象res的key，key对应的值是一个名为mappedState的函数，在函数内部获取到了state、getters，然后再判断数组的val是否是一个函数，是的话直接调用，并传入state和getters，否则直接返回state[val]。最后将构建好的res对象返回，通过对象展开运算符将这个res填充到computed中。 总结在Vuex的模式下，我们的组件树构成了一个巨大的视图，无论该组件在树的哪个位置，它都可以获取状态或者触发状态更新的行为，通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.limuyang.cc/tags/源码阅读/"},{"name":"vuex","slug":"vuex","permalink":"https://www.limuyang.cc/tags/vuex/"}]},{"title":"阅读分析snabbdom源码","date":"2019-03-06T22:20:26.000Z","path":"2019/03/06/阅读分析snabbdom源码/","text":"尤大在官宣Vue 2.0的时候这么说过： 渲染层基于一个轻量级的 Virtual DOM 实现进行了重写，该 Virtual DOM 实现 fork 自 snabbdom。新的渲染层相比 v1 带来了巨大的性能提升，也让 Vue 2.0 成为了最快速的框架之一。那么对于想要深入了解Vue源码的人来说先深入了解一下snabbdom的实现是有必要的 什么是Virtual DOM Virtual DOM使用JavaScript对象来描述节点，只保留一些有用的信息，可以更轻量的描述DOM树的结构 将原本需要在真实DOM进行的创建节点,删除节点,添加节点等一系列复杂的DOM操作全部放到Vritual DOM中进行比如在我们的snabbdom中就是用这样的方式来定义一个VNODE： 12345678910111213141516171819202122232425export interface VNode &#123; sel: string | undefined; data: VNodeData | undefined; children: Array&lt;VNode | string&gt; | undefined; elm: Node | undefined; text: string | undefined; key: Key | undefined;&#125;export interface VNodeData &#123; props?: Props; attrs?: Attrs; class?: Classes; style?: VNodeStyle; dataset?: Dataset; on?: On; hero?: Hero; attachData?: AttachData; hook?: Hooks; key?: Key; ns?: string; // for SVGs fn?: () =&gt; VNode; // for thunks args?: Array&lt;any&gt;; // for thunks [key: string]: any; // for any other 3rd party module&#125; 既然DOM树信息可以通过JavaScript对象来表示，反过来我们就可以用这个JavaScript对象还原构建一棵真正的DOM树，当状态变化的时候重新渲染这个 JavaScript 的对象结构，然后将两个JavScript对象进行对比，记录差异，然后把它们应用在真实的DOM树上，这便是diff算法 分析源码从官方给的Demo入手1234567891011121314151617181920212223242526var snabbdom = require('snabbdom');var patch = snabbdom.init([ // Init patch function with chosen modules require('snabbdom/modules/class').default, // makes it easy to toggle classes require('snabbdom/modules/props').default, // for setting properties on DOM elements require('snabbdom/modules/style').default, // handles styling on elements with support for animations require('snabbdom/modules/eventlisteners').default, // attaches event listeners]);var h = require('snabbdom/h').default; // helper function for creating vnodesvar container = document.getElementById('container');var vnode = h('div#container.two.classes', &#123;on: &#123;click: someFn&#125;&#125;, [ h('span', &#123;style: &#123;fontWeight: 'bold'&#125;&#125;, 'This is bold'), ' and this is just normal text', h('a', &#123;props: &#123;href: '/foo'&#125;&#125;, 'I\\'ll take you places!')]);// Patch into empty DOM element – this modifies the DOM as a side effectpatch(container, vnode);var newVnode = h('div#container.two.classes', &#123;on: &#123;click: anotherEventHandler&#125;&#125;, [ h('span', &#123;style: &#123;fontWeight: 'normal', fontStyle: 'italic'&#125;&#125;, 'This is now italic type'), ' and this is still just normal text', h('a', &#123;props: &#123;href: '/bar'&#125;&#125;, 'I\\'ll take you places!')]);// Second `patch` invocationpatch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state 可以看到snabbdom核心模块对外暴露一个init方法，这个方法接收一个数组，数组里面的每一项都是一个module，这些module的作用是扩展snabbdom生成复杂DOM的能力，可以根据自己的需求决定是否要引入对应的module，与此同时你也可以实现自己的module，打个比方，如果你的vnode节点不需要写入listener，你可以不引入snabbdom/modules/eventlisteners，调用init方法之后会返回一个patch函数，这个函数接收两个参数，第一个参数是一个DOM节点或者一个用于表示当前视图的vnode节点，第二个参数是表示即将要更新的视图的vnode节点，patch函数会根据传递的参数不同进行对应的DOM更新操作，接下来我们可以先看一下init函数的核心实现(为了理解方便暂时隐去函数内部的实现细节)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374export interface Module &#123; pre: PreHook; create: CreateHook; update: UpdateHook; destroy: DestroyHook; remove: RemoveHook; post: PostHook;&#125;export function init(modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI) &#123; // cbs 用于收集 module 中的 hook let i: number, j: number, cbs = &#123;&#125; as ModuleHooks; const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi; // 收集 module 中的 hook for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = []; for (j = 0; j &lt; modules.length; ++j) &#123; const hook = modules[j][hooks[i]]; if (hook !== undefined) &#123; (cbs[hooks[i]] as Array&lt;any&gt;).push(hook); &#125; &#125; &#125; function emptyNodeAt(elm: Element) &#123; // ... &#125; function createRmCb(childElm: Node, listeners: number) &#123; // ... &#125; // 创建真正的 dom 节点 function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node &#123; // ... &#125; function addVnodes( parentElm: Node, before: Node | null, vnodes: Array&lt;VNode&gt;, startIdx: number, endIdx: number, insertedVnodeQueue: VNodeQueue ) &#123; // ... &#125; // 调用 destory hook // 如果存在 children 递归调用 function invokeDestroyHook(vnode: VNode) &#123; // ... &#125; function removeVnodes(parentElm: Node, vnodes: Array&lt;VNode&gt;, startIdx: number, endIdx: number): void &#123; // ... &#125; function updateChildren(parentElm: Node, oldCh: Array&lt;VNode&gt;, newCh: Array&lt;VNode&gt;, insertedVnodeQueue: VNodeQueue) &#123; // ... &#125; function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123; // ... &#125; return function patch(oldVnode: VNode | Element, vnode: VNode): VNode &#123; // ... &#125;;&#125; 可以看到首先init方法会接收两个参数，一个由module组成的数组，以及一个可选参数domApi，默认是使用预定义的一些和DOM操作相关的API，接下来会通过循环遍历收集modules中的hook，存储到cbs对象中，以便在恰当的时机对DOM节点进行一些操作，举个例子，我们看一下class这个module的源码：123456789101112131415161718192021222324\"use strict\";Object.defineProperty(exports, \"__esModule\", &#123; value: true &#125;);function updateClass(oldVnode, vnode) &#123; var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class; if (!oldClass &amp;&amp; !klass) return; if (oldClass === klass) return; oldClass = oldClass || &#123;&#125;; klass = klass || &#123;&#125;; for (name in oldClass) &#123; if (!klass[name]) &#123; elm.classList.remove(name); &#125; &#125; for (name in klass) &#123; cur = klass[name]; if (cur !== oldClass[name]) &#123; elm.classList[cur ? 'add' : 'remove'](name); &#125; &#125;&#125;exports.classModule = &#123; create: updateClass, update: updateClass &#125;;exports.default = exports.classModule; 很明显可以看出这个module的作用是对比新旧两个vnode节点，更新classname，执行的时机分别是在调用create和update两种hook的时候，其他module也差不多，这里不展开分析。下面几个都是功能型函数略过不看，直接看返回的patch函数 patch函数12345678910111213141516171819202122232425262728293031// 用于dom相关的更新return function patch(oldVnode: VNode | Element, vnode: VNode): VNode &#123; let i: number, elm: Node, parent: Node; const insertedVnodeQueue: VNodeQueue = []; // 调用 module 中的 pre hook for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i](); if (!isVnode(oldVnode)) &#123; oldVnode = emptyNodeAt(oldVnode); &#125; // 判断两个Vnode节点是否相同 if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode, insertedVnodeQueue); &#125; else &#123; elm = oldVnode.elm as Node; parent = api.parentNode(elm); createElm(vnode, insertedVnodeQueue); if (parent !== null) &#123; api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm)); removeVnodes(parent, [oldVnode], 0, 0); &#125; &#125; for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123; (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]); &#125; for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i](); return vnode;&#125;; 先通过isVnode方法来判断传入的第一个参数是不是vnode，如果不是的话通过emptyNodeAt方法来将其转换成vnode，这两个方法实现都比较简单：12345678910111213// isVnodefunction isVnode(vnode: any): vnode is VNode &#123; // 判断是否具有sel属性 return vnode.sel !== undefined;&#125;// emptyNodeAtfunction emptyNodeAt(elm: Element) &#123; const id = elm.id ? '#' + elm.id : ''; const c = elm.className ? '.' + elm.className.split(' ').join('.') : ''; return vnode(api.tagName(elm).toLowerCase() + id + c, &#123;&#125;, [], undefined, elm); &#125; 看一眼vnode方法的实现：123456789export function vnode(sel: string | undefined, data: any | undefined, children: Array&lt;VNode | string&gt; | undefined, text: string | undefined, elm: Element | Text | undefined): VNode &#123; let key = data === undefined ? undefined : data.key; return &#123;sel: sel, data: data, children: children, text: text, elm: elm, key: key&#125;;&#125; 接着往下看，当两个需要被对比的节点都转化成了vnode之后，通过sameVnode方法判断两个Vnode节点是否相同：123function sameVnode(vnode1: VNode, vnode2: VNode): boolean &#123; return vnode1.key === vnode2.key &amp;&amp; vnode1.sel === vnode2.sel;&#125; 这里通过判断key和sel是否相同来判断是否是相同vnode节点，如果是两个相同的vnode节点，调用patchVnode方法来对比更新，如果不是，则通过createElm方法创建新的DOM节点，如果存在父节点，则通过htmdomapi里面的insertBefore方法插入新的DOM节点到子节点的末尾，然后通过removeVnodes移除旧节点完成更新，这里的关键方法是patchVnode和createElm，简单起见先看第二个。 createElm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 通过vnode创建真正的dom节点function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node &#123; let i: any, data = vnode.data; if (data !== undefined) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.init)) &#123; // 调用init hook i(vnode); data = vnode.data; &#125; &#125; let children = vnode.children, sel = vnode.sel; // 如果是注释节点 if (sel === '!') &#123; if (isUndef(vnode.text)) &#123; vnode.text = ''; &#125; vnode.elm = api.createComment(vnode.text as string); &#125; else if (sel !== undefined) &#123; // 解析sel const hashIdx = sel.indexOf('#'); const dotIdx = sel.indexOf('.', hashIdx); const hash = hashIdx &gt; 0 ? hashIdx : sel.length; const dot = dotIdx &gt; 0 ? dotIdx : sel.length; const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel; // 如果有ns属性说明是svg元素 const elm = vnode.elm = isDef(data) &amp;&amp; isDef(i = (data as VNodeData).ns) ? api.createElementNS(i, tag) : api.createElement(tag); // 设置元素id if (hash &lt; dot) elm.setAttribute('id', sel.slice(hash + 1, dot)); // 设置元素classname if (dotIdx &gt; 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' ')); // 调用create hook for (i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode); // 创建子元素节点 if (is.array(children)) &#123; for (i = 0; i &lt; children.length; ++i) &#123; const ch = children[i]; if (ch != null) &#123; api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue)); &#125; &#125; &#125; else if (is.primitive(vnode.text)) &#123; // 文本节点 api.appendChild(elm, api.createTextNode(vnode.text)); &#125; i = (vnode.data as VNodeData).hook; // Reuse variable if (isDef(i)) &#123; // 调用节点的create hook if (i.create) i.create(emptyNode, vnode); // insert hook要等dom真正挂载的时候才会调用，这里先存储到数组里面 if (i.insert) insertedVnodeQueue.push(vnode); &#125; &#125; else &#123; // 文本节点 vnode.elm = api.createTextNode(vnode.text as string); &#125; return vnode.elm;&#125; 创建DOM的时候首先调用vnode节点的init hook，然后判断该vnode节点是注释节点/文本节点/带选择器节点的其中之一，至于为什么sel === &#39;!&#39;就说明是注释节点这里可以解释一下，snabbdom提供了tovnode方法来将一个DOM节点转换成vnode节点，大致用法如下：12345678910111213141516var snabbdom = require('snabbdom')var patch = snabbdom.init([ // Init patch function with chosen modules require('snabbdom/modules/class').default, // makes it easy to toggle classes require('snabbdom/modules/props').default, // for setting properties on DOM elements require('snabbdom/modules/style').default, // handles styling on elements with support for animations require('snabbdom/modules/eventlisteners').default, // attaches event listeners]);var h = require('snabbdom/h').default; // helper function for creating vnodesvar toVNode = require('snabbdom/tovnode').default;var newVNode = h('div', &#123;style: &#123;color: '#000'&#125;&#125;, [ h('h1', 'Headline'), h('p', 'A paragraph'),]);patch(toVNode(document.querySelector('.container')), newVNode) 这个tovnode的源码里面有这么一段：1234567...&#125; else if (api.isComment(node)) &#123; text = api.getTextContent(node) as string; return vnode('!', &#123;&#125;, [], text, node as any); &#125; else &#123; return vnode('', &#123;&#125;, [], undefined, node as any);... 那么我们再找一下isComment方法做了什么：123function isComment(node: Node): node is Comment &#123; return node.nodeType === 8;&#125; 节点类型常量里面type 8就是Node.COMMENT_NODE也就是注释节点 然后顺着源码我们这里主要看带选择器节点的创建，首先得到tagname、class、id，然后在根据是否有ns属性来决定通过createElement还是createElementNS来创建节点，紧接着如果存在children，循环遍历调用createElm方法创建子节点并挂载到父节点上面，DOM节点创建完毕之后调用相应的hookl即可。 patchVnodepatchVnode方法会对传入的两个vnode节点进行对比，最终对比的结果会体现在DOM上，这便是diff算法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123; let i: any, hook: any; // 调用prepatch hook if (isDef(i = vnode.data) &amp;&amp; isDef(hook = i.hook) &amp;&amp; isDef(i = hook.prepatch)) &#123; i(oldVnode, vnode); &#125; const elm = vnode.elm = (oldVnode.elm as Node); let oldCh = oldVnode.children; let ch = vnode.children; // 如果两个vnode完全相同，直接返回 if (oldVnode === vnode) return; if (vnode.data !== undefined) &#123; // 调用 module 上的 update hook for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode); i = vnode.data.hook; // 调用vnode的update方法 if (isDef(i) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode); &#125; if (isUndef(vnode.text)) &#123; // 新节点存在children if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 新旧节点均存在 children，且不一样时，对 children 进行 diff if (oldCh !== ch) updateChildren(elm, oldCh as Array&lt;VNode&gt;, ch as Array&lt;VNode&gt;, insertedVnodeQueue); &#125; else if (isDef(ch)) &#123; // 旧节点不存在 children 新节点有 children // 旧节点存在 text 置空 if (isDef(oldVnode.text)) api.setTextContent(elm, ''); addVnodes(elm, null, ch as Array&lt;VNode&gt;, 0, (ch as Array&lt;VNode&gt;).length - 1, insertedVnodeQueue); &#125; else if (isDef(oldCh)) &#123; // 新节点不存在 children 旧节点存在 children 移除旧节点的 children removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; else if (isDef(oldVnode.text)) &#123; api.setTextContent(elm, ''); &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; if (isDef(oldCh)) &#123; // 如果旧的vnode有children则移除 removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1); &#125; // 更新text api.setTextContent(elm, vnode.text as string); &#125; // 调用 postpatch hook if (isDef(hook) &amp;&amp; isDef(i = hook.postpatch)) &#123; i(oldVnode, vnode); &#125;&#125; 首先调用vnode上的prepatch hook，然后判断两个vnode节点是否完全相同，如果完全相同则直接返回，紧接着遍历调用module的update hook和vnode的update hook，然后分别处理如下几种情况： 如果新节点不存在children而旧节点存在，那么使用removeVnodes方法移除旧节点的children并且设置文本内容 如果新节点存在children且旧节点没有，然后移除旧节点的文本内容(如果有的话)，最后通过addVnodes方法挂载子节点 如果新旧节点均存在children，调用updateChildren方法对children进行diff 如果新旧节点文本内容不相同，移除旧节点的children(如果有的话)，然后更新文本内容最后当上述步骤都完成之后，调用vnode的postpatch hook钩子，所以接下来我们需要关注updateChildren、addVnodes和removeVnodes都分别干了什么。 addVnodes1234567891011121314function addVnodes(parentElm: Node, before: Node | null, vnodes: Array&lt;VNode&gt;, startIdx: number, endIdx: number, insertedVnodeQueue: VNodeQueue) &#123; for (; startIdx &lt;= endIdx; ++startIdx) &#123; const ch = vnodes[startIdx]; if (ch != null) &#123; // 循环遍历插入dom节点 api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before); &#125; &#125;&#125; 主要就是通过遍历children数组并且调用createElm方法生成DOM插入到父元素子节点末尾来达到添加节点的目的 removeVnodes12345678910111213141516171819202122232425262728293031323334353637function removeVnodes(parentElm: Node, vnodes: Array&lt;VNode&gt;, startIdx: number, endIdx: number): void &#123; for (; startIdx &lt;= endIdx; ++startIdx) &#123; let i: any, listeners: number, rm: () =&gt; void, ch = vnodes[startIdx]; if (ch != null) &#123; // 非文本节点 if (isDef(ch.sel)) &#123; // 调用destroy hook invokeDestroyHook(ch); // 当所有的remove hook都调用了才会真正调用移除dom的方法 listeners = cbs.remove.length + 1; rm = createRmCb(ch.elm as Node, listeners); // 调用module的remove hook for (i = 0; i &lt; cbs.remove.length; ++i) cbs.remove[i](ch, rm); if (isDef(i = ch.data) &amp;&amp; isDef(i = i.hook) &amp;&amp; isDef(i = i.remove)) &#123; // 调用vnode的remove hook i(ch, rm); &#125; else &#123; rm(); &#125; &#125; else &#123; // Text node api.removeChild(parentElm, ch.elm as Node); &#125; &#125; &#125;&#125;function createRmCb(childElm: Node, listeners: number) &#123; return function rmCb() &#123; if (--listeners === 0) &#123; const parent = api.parentNode(childElm); api.removeChild(parent, childElm); &#125; &#125;;&#125; 同样是遍历，只不过这里是移除节点 updateChildren我们知道当新旧节点均有children并且互不相同的时候会调用updateChildren方法来对children进行diff：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function updateChildren(parentElm: Node, oldCh: Array&lt;VNode&gt;, newCh: Array&lt;VNode&gt;, insertedVnodeQueue: VNodeQueue) &#123; let oldStartIdx = 0, newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; let oldEndVnode = oldCh[oldEndIdx]; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx: any; let idxInOld: number; let elmToMove: VNode; let before: any; // 遍历 oldCh newCh，对节点进行比较和更新 // 每轮比较最多处理一个节点，算法复杂度 O(n) while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 当前节点可能已经被处理过 oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left &#125; else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx]; &#125; else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // 新旧开始节点相同，直接调用 patchVnode 进行更新，下标向中间推进 patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // 新旧结束节点相同，直接调用 patchVnode 进行更新，下标向中间推进 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right // 旧的开始节点等于新的结束节点，两个节点进行patch patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue); // 把旧的开始节点插入到末尾 api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left // 旧的结束节点等于新的开始节点，两个节点进行patch patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue); // 把旧的就结束节点插入到开头 api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; // 如果上述情况都不符合，那么只有可能是以下两种情况 // 1. 这个节点是新创建的 // 2. 这个节点在原来的位置是处于中间的（oldStartIdx 和 endStartIdx之间） // 如果 oldKeyToIdx 不存在，创建 key 到 index 的映射 // 而且也存在各种细微的优化，只会创建一次，并且已经完成的部分不需要映射 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; idxInOld = oldKeyToIdx[newStartVnode.key as string]; if (isUndef(idxInOld)) &#123; // New element // 将新节点插入到开头 api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); newStartVnode = newCh[++newStartIdx]; &#125; else &#123; // 如果不是新节点，说明该节点之前存在，找到该节点 elmToMove = oldCh[idxInOld]; // 如果两个节点key相同但是sel不同，那就通过createElm创建新的dom节点然后插入到开头 if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node); &#125; else &#123; // 将oldCh中已存在的节点和新的开始节点进行patch patchVnode(elmToMove, newStartVnode, insertedVnodeQueue); // 将oldCh中处理过的节点置空，等循环处理到这个地方的时候方便直接跳过 oldCh[idxInOld] = undefined as any; // 将处理过后的节点插入到旧的开始节点之前 api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node); &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; &#125; // oldCh或newCh中有一方先循环结束 if (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123; if (oldStartIdx &gt; oldEndIdx) &#123; // oldCh 已经全部处理完成，而 newCh 还有新的节点，需要对剩下的每个项都创建新的 dom before = newCh[newEndIdx+1] == null ? null : newCh[newEndIdx+1].elm; addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue); &#125; else &#123; // newCh 已经全部处理完成，而 oldCh 还有旧的节点，需要将多余的节点移除 removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125; &#125;&#125; 直接看整个过程会有点懵，可以结合例子理解一下，我们拿两个数组进行演示： 假设旧节点顺序为[A, B, C, D]，新节点为[B, A, C, D, E] 第一轮比较：开始结束节点两两并不相等，于是看newStartVnode在旧节点中是否存在，最后找到了在第二个位置，调用patchVnode进行更新，将 oldCh[1] 至空，将 dom 插入到oldStartVnode前面，newStartIdx向中间移动，状态更新如下 第二轮比较：oldStartVnode和newStartVnode相等，直接 patchVnode，newStartIdx和 oldStartIdx向中间移动，状态更新如下 第三轮比较：oldStartVnode为空，oldStartIdx向中间移动，进入下轮比较，状态更新如下 第四轮比较：oldStartVnode和 newStartVnode相等，直接patchVnode，newStartIdx和 oldStartIdx向中间移动，状态更新如下 第五轮比较：oldStartVnode和 newStartVnode相等，直接patchVnode，newStartIdx 和 oldStartIdx向中间移动，状态更新如下 oldStartIdx 已经大于 oldEndIdx，循环结束，由于是旧节点先结束循环而且还有没处理的新节点，调用 addVnodes处理剩下的新节点 到目前为止，整个snabbdom的核心流程已经梳理完毕 参考链接","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.limuyang.cc/tags/源码阅读/"},{"name":"snabbdom","slug":"snabbdom","permalink":"https://www.limuyang.cc/tags/snabbdom/"}]},{"title":"阅读分析Redux源码","date":"2019-01-12T16:55:21.000Z","path":"2019/01/12/阅读分析Redux源码/","text":"之前在Medium上看过一篇很有意思的文章： The deepest reason why modern JavaScript frameworks exist 文章里面大概描述了这么一个事实：我们用着一系列现代开发框架(Vue、React、Angular)，但是我们却忽略了他们之所以存在的最重要的意义： 管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 无论是Vuex还是Redux，其实都是为了解决我们state的管理的一系列问题而产生的，这里主要分析Redux的原理。 先看一眼Redux源码的文件结构：12345678910├── applyMiddleware.js├── bindActionCreators.js├── combineReducers.js├── compose.js├── createStore.js├── index.js└── utils ├── actionTypes.js ├── isPlainObject.js └── warning.js 基本都包含了我们常用的一些API外加一些工具类方法，那就先从入口文件开始看起。 index123456789101112131415161718192021222324252627282930313233343536import createStore from './createStore'import combineReducers from './combineReducers'import bindActionCreators from './bindActionCreators'import applyMiddleware from './applyMiddleware'import compose from './compose'import warning from './utils/warning'import __DO_NOT_USE__ActionTypes from './utils/actionTypes'/* * This is a dummy function to check if the function name has been altered by minification. * If the function has been minified and NODE_ENV !== 'production', warn the user. */function isCrushed() &#123;&#125;if ( process.env.NODE_ENV !== 'production' &amp;&amp; typeof isCrushed.name === 'string' &amp;&amp; isCrushed.name !== 'isCrushed') &#123; warning( 'You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.' )&#125;export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes&#125; index入口文件对外释放了我们常用的一些API，这个文件本身自带一个isCrushed方法，通过注释可以了解到这个被Redux开发者称为dummy function的方法用于判断Redux代码是否被压缩，在开发环境会给出警告，其实是一个压缩检验函数。 createStore通常我们创建一个store一般会这么写： 12let storestore = createStore(rootReducer，initState，compose(applyMiddleware(sagaMiddleware))) 第一个参数是返回下一组状态树的函数，通常我们会使用combineReducers方法来生成，紧接着我们需要传入初始化的state，最后一个参数是enhancer，它可以让我们用一些中间件来增强Store，比如提供time travel/persistence，下面通过整体代码来看一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298import $$observable from 'symbol-observable'import ActionTypes from './utils/actionTypes'import isPlainObject from './utils/isPlainObject'/** * Creates a Redux store that holds the state tree. * The only way to change the data in the store is to call `dispatch()` on it. * * There should only be a single store in your app. To specify how different * parts of the state tree respond to actions, you may combine several reducers * into a single reducer function by using `combineReducers`. * * @param &#123;Function&#125; reducer A function that returns the next state tree, given * the current state tree and the action to handle. * * @param &#123;any&#125; [preloadedState] The initial state. You may optionally specify it * to hydrate the state from the server in universal apps, or to restore a * previously serialized user session. * If you use `combineReducers` to produce the root reducer function, this must be * an object with the same shape as `combineReducers` keys. * * @param &#123;Function&#125; [enhancer] The store enhancer. You may optionally specify it * to enhance the store with third-party capabilities such as middleware, * time travel, persistence, etc. The only store enhancer that ships with Redux * is `applyMiddleware()`. * * @returns &#123;Store&#125; A Redux store that lets you read the state, dispatch actions * and subscribe to changes. */export default function createStore(reducer, preloadedState, enhancer) &#123; // 传参判断 if ( (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'function') || (typeof enhancer === 'function' &amp;&amp; typeof arguments[3] === 'function') ) &#123; throw new Error( 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.' ) &#125; // preloadedState默认是undefined if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; /// 函数柯里化 传入createStore作为参数 return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; // 存储当前的reducer let currentReducer = reducer // 存储当前的state let currentState = preloadedState let currentListeners = [] let nextListeners = currentListeners // 判断是否正在分发事件 let isDispatching = false /** * This makes a shallow copy of currentListeners so we can use * nextListeners as a temporary list while dispatching. * * This prevents any bugs around consumers calling * subscribe/unsubscribe in the middle of a dispatch. */ function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; /** * Reads the state tree managed by the store. * * @returns &#123;any&#125; The current state tree of your application. */ // 返回当前的state function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState &#125; /** * Adds a change listener. It will be called any time an action is dispatched, * and some part of the state tree may potentially have changed. You may then * call `getState()` to read the current state tree inside the callback. * * You may call `dispatch()` from a change listener, with the following * caveats: * * 1. The subscriptions are snapshotted just before every `dispatch()` call. * If you subscribe or unsubscribe while the listeners are being invoked, this * will not have any effect on the `dispatch()` that is currently in progress. * However, the next `dispatch()` call, whether nested or not, will use a more * recent snapshot of the subscription list. * * 2. The listener should not expect to see all state changes, as the state * might have been updated multiple times during a nested `dispatch()` before * the listener is called. It is, however, guaranteed that all subscribers * registered before the `dispatch()` started will be called with the latest * state by the time it exits. * * @param &#123;Function&#125; listener A callback to be invoked on every dispatch. * @returns &#123;Function&#125; A function to remove this change listener. */ function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true // 浅拷贝一份当前的listener ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; /** * Dispatches an action. It is the only way to trigger a state change. * * The `reducer` function, used to create the store, will be called with the * current state tree and the given `action`. Its return value will * be considered the **next** state of the tree, and the change listeners * will be notified. * * The base implementation only supports plain object actions. If you want to * dispatch a Promise, an Observable, a thunk, or something else, you need to * wrap your store creating function into the corresponding middleware. For * example, see the documentation for the `redux-thunk` package. Even the * middleware will eventually dispatch plain object actions using this method. * * @param &#123;Object&#125; action A plain object representing “what changed”. It is * a good idea to keep actions serializable so you can record and replay user * sessions, or use the time travelling `redux-devtools`. An action must have * a `type` property which may not be `undefined`. It is a good idea to use * string constants for action types. * * @returns &#123;Object&#125; For convenience, the same action object you dispatched. * * Note that, if you use a custom middleware, it may wrap `dispatch()` to * return something else (for example, a Promise you can await). */ function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; /** * Replaces the reducer currently used by the store to calculate the state. * * You might need this if your app implements code splitting and you want to * load some of the reducers dynamically. You might also need this if you * implement a hot reloading mechanism for Redux. * * @param &#123;Function&#125; nextReducer The reducer for the store to use instead. * @returns &#123;void&#125; */ // 用作code splitting 或者 dynamical load reducer function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer // This action has a similiar effect to ActionTypes.INIT. // Any reducers that existed in both the new and old rootReducer // will receive the previous state. This effectively populates // the new state tree with any relevant data from the old one. dispatch(&#123; type: ActionTypes.REPLACE &#125;) &#125; /** * Interoperability point for observable/reactive libraries. * @returns &#123;observable&#125; A minimal observable of state changes. * For more information, see the observable proposal: * https://github.com/tc39/proposal-observable */ function observable() &#123; const outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== 'object' || observer === null) &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; // When a store is created, an \"INIT\" action is dispatched so that every // reducer returns their initial state. This effectively populates // the initial state tree. dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; Store对外提供了4个API： getState() dispatch(action) subscribe(listener) replaceReducer(nextReducer) 这些API在上面都有一一呈现，从上往下看，首先createStore.js会对传参进行处理，根据参数类型来判断是否传入了过多的enhancer，同时会给出提示我们可以用compose来组合多个enhancer，然后判断是否传入了preloadedState，没有的话默认赋值为undefined，最后判断传入的enhancer，当传入的类型不是function类型直接抛异常，如果传参类型无误，将createStore传入enhancer作为参数，这里其实是一个函数柯里化，enhancer会返回一个函数，然后将reducer和preloadedState作为下一级入参。 接下来看一下主要API部分的实现，getState其实就是返回当前的state，如果判断正在调用dispatch会报错： 1234567891011function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState&#125; 然后是我们常用的dispatch方法： 12345678910111213141516171819202122232425262728293031323334function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action&#125; 调用dispatch时候方法内部会先判断传入的action是否是plain objects，这个方法也很简单： 1234567891011121314/** * @param &#123;any&#125; obj The object to inspect. * @returns &#123;boolean&#125; True if the argument appears to be a plain object. */export default function isPlainObject(obj) &#123; if (typeof obj !== 'object' || obj === null) return false let proto = obj while (Object.getPrototypeOf(proto) !== null) &#123; proto = Object.getPrototypeOf(proto) &#125; return Object.getPrototypeOf(obj) === proto&#125; 然后判断action是否含有type属性，没有的话会报错，当isDispatching标志位为false的时候，将这个标志位设为true，然后将传入的action和currentState传入currentReducer得到当前的状态快照，完成这件事之后又重置isDispatching为false，以便执行下一轮的dispatch，最后依次执行通过subscribe方法订阅的回调。 上面提到的subscribe方法平常开发比较少用到，你可以在订阅的回调里面通过getState方法获取当前的state，看一下相关实现： 123456789101112131415161718192021222324252627282930313233343536373839function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true // 浅拷贝一份当前的listener ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125;&#125; 就是简单地浅拷贝一份当前的回调List，将订阅的回调加入nextListeners，返回一个取消订阅的函数，调用这个函数会将该订阅从nextListeners里面删除，可以看一个官方的使用示例： 123456789101112131415161718192021function select(state) &#123; return state.some.deep.property&#125;let currentValuefunction handleChange() &#123; let previousValue = currentValue currentValue = select(store.getState()) if (previousValue !== currentValue) &#123; console.log( 'Some deep nested property changed from', previousValue, 'to', currentValue ) &#125;&#125;const unsubscribe = store.subscribe(handleChange)unsubscribe() 最后一个，也是不常用的方法replaceReducer： 12345678910111213function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer // This action has a similiar effect to ActionTypes.INIT. // Any reducers that existed in both the new and old rootReducer // will receive the previous state. This effectively populates // the new state tree with any relevant data from the old one. dispatch(&#123; type: ActionTypes.REPLACE &#125;) &#125; 这个方法一般用作code splitting或者 dynamical load reducer，成功替换reducer之后会发出一个type为ActionTypes.REPLACE的action。 combineReducers基于 Redux 的应用程序中最常见的 state 结构是一个简单的 JavaScript 对象，它最外层的每个 key 中拥有特定域的数据。类似地，给这种 state 结构写 reducer 的方式是分拆成多个 reducer，拆分之后的 reducer 都是相同的结构（state, action），并且每个函数独立负责管理该特定切片 state 的更新。多个拆分之后的 reducer 可以响应一个 action，在需要的情况下独立的更新他们自己的切片 state，最后组合成新的 state。 这个模式是如此的通用，Redux 提供了 combineReducers 去实现这个模式。这是一个高阶 Reducer 的示例，他接收一个拆分后 reducer 函数组成的对象，返回一个新的 Reducer 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export default function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; // 过滤一些不存在的reducer for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) // This is used to make sure we don't warn about the same // keys multiple times. let unexpectedKeyCache if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; let shapeAssertionError try &#123; assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; combineReducers接受一个对象作为参数，这个参数里面每一个key都对应着一个值为reducer function的函数，在这个方法里面首先会对传入的reducers进行过滤，去掉一些不存在的reducer，把过滤后的结果存入finalReducers，然后通过assertReducerShape规范我们写的reducer函数，看一眼这个方法： 123456789101112131415161718192021222324252627282930313233function assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] const initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; if ( typeof reducer(undefined, &#123; type: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;) === 'undefined' ) &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined when probed with a random type. ` + `Don't try to handle $&#123; ActionTypes.INIT &#125; or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125; 这里给每个reducer函数传入了一个type为ActionTypes.INIT的action，按理说正常情况我们的reducer在接受到未定义type的action时候应该返回默认state，所以这里判断如果返回了undefined那么说明这个reducer写的不够规范。 最后返回一个名为combination的函数，这个函数其实在createStore.js的dispatch方法里面有体现： 123// ... 省略无关代码 currentState = currentReducer(currentState, action)// ...省略无关代码 这个函数就是把所有的reducer循环执行，然后根据传参前后的state判断是否改变来决定返回下一组状态还是当前状态。 composecreateStore的第三个函数就是store enhancer用于增强Store，当你需要传入多个store enhancer的时候就需要通过compose方法将其进行组合，看一下组合的逻辑： 12345678910111213141516171819202122/** * Composes single-argument functions from right to left. The rightmost * function can take multiple arguments as it provides the signature for * the resulting composite function. * * @param &#123;...Function&#125; funcs The functions to compose. * @returns &#123;Function&#125; A function obtained by composing the argument functions * from right to left. For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 这个函数会将传入的参数进行组合从右到左进行执行，所有传递给compose方法的参数都必须是函数，通过reduce方法组合，给用compose方法组合后的函数传入的第一个参数会作为compose函数最后一个函数参数的参数，联想到我们使用createStore方法的时候： 1enhancer(createStore)(reducer, preloadedState) 如果有多个store enhancer这里的enhancer就是compose，createStore将作为最后一个store enhancer函数的参数，然后按照洋葱圈模型从右向左执行，下面我们可以聊一聊store enhancer。 store enhancer store enhancer，可以翻译成store的增强器，顾名思义，就是增强store的功能。一个store enhancer，实际上就是一个高阶函数，它的参数是创建store的函数（store creator），返回值是一个可以创建功能更加强大的store的函数(enhanced store creator)，这和React中的高阶组件的概念很相似。 一般来说一个store enhancer的代码结构如下：123456function enhancerCreator() &#123; return createStore =&gt; (...args) =&gt; &#123; // do something based old store // return a new enhanced store &#125;&#125; 我们可以找一个store enhancer，刚好redux内部就有一个用于增强作用于dispatch方法的中间件的store enhancer生成器，也就是applyMiddleware，这里有一点要注意的是，因为middleware都是异步的，所以通过这个方法生成的store enhancer必须放在第一位，看一下相关实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243import compose from './compose'/** * Creates a store enhancer that applies middleware to the dispatch method * of the Redux store. This is handy for a variety of tasks, such as expressing * asynchronous actions in a concise manner, or logging every action payload. * * See `redux-thunk` package as an example of the Redux middleware. * * Because middleware is potentially asynchronous, this should be the first * store enhancer in the composition chain. * * Note that each middleware will be given the `dispatch` and `getState` functions * as named arguments. * * @param &#123;...Function&#125; middlewares The middleware chain to be applied. * @returns &#123;Function&#125; A store enhancer applying the middleware. */export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; // 创建一个新的store const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.' ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; // 传入getState和dispatch，返回以next为参数的匿名函数 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 通过传入的createStore以及reducer和state创建一个新的Store，然后定义一个临时dispatch方法，在通过applyMiddleWare处理之前调用dispatch会报错，然后会调用middlewares数组中每一个中间件函数，我们可以找一个中间件函数看一下内部的处理过程，这里看一下redux-thunk的处理方式： 1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 每一个middleware都会接受Store的dispatch和getState方法作为参数，redux-thunk的增强型作用是可以让你dispatch一个函数，这样就知道了我们的chain里面的函数都是类似于这样的： 123// 省略代码 return next =&gt; action =&gt; &#123;// 省略代码 变相的去掉了一层，然后通过compose方法组合出来一个增强后的dispatch： 1dispatch = compose(...chain)(store.dispatch) 将store原生的dispatch作为参数，后续的每一个middleware都对这个dispatch进行增强，当遇到redux-thunk的时候，他会检测当前的action是否是一个函数，是的话就执行这个函数，同理其他的middleware也是依次执行的。 总结虽然Redux是一个体小精悍的库，但它相关的内容和API都是精挑细选的，足以衍生出丰富的工具集和可扩展的生态系统。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.limuyang.cc/tags/源码阅读/"},{"name":"redux","slug":"redux","permalink":"https://www.limuyang.cc/tags/redux/"}]},{"title":"京晚8点--H5单页面手势滑屏效果实践","date":"2018-08-27T23:11:04.000Z","path":"2018/08/27/京晚8点-H5单页面手势滑屏效果实践/","text":"项目背景京晚8点作为内容平台重点打造的内容IP，通过优质的内容形式，潜移默化中让用户了解产品，建立对京东开始玩内容的心智和认知，目前这个项目已经迭代到第5期，最开始的时候我们的首页效果是一个卡片形式的时间轴，首页的背景大图会随着时间轴拖动到不同的卡片而进行切换：从第5期开始，我们采用了一种全新的交互方式来给用户更好的体验反馈，那就是滑屏，可以先看一下效果： 要实现的滑屏效果1、左右滑动可以切换背景图，同时在临界状态做出相应处理(滑动到第一张图片不能左滑，最后一张图片不能右滑)2、滑动切换图片的时候带有覆盖的动效 为了实现上述需求，需要考虑三个问题： 对图片组应该采用何种形式的布局？ 滑动切换时候如何实现覆盖动效？ 如何处理临界状态以及临界延伸状态？ 对图片组应该采用何种形式的布局 首先假设我们有一堆这样的背景图，要实现这种层叠的效果最简单的方式莫过于设置 z-index ，从右向左滑动的过程就像从一个卡牌组的最上方不断的抽取最上面那一张卡牌的过程，这样我们就可以使用position: absolute 结合z-index得到最基本的布局： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=\"card-list\"&gt; &lt;div class=\"card-wrapper\" v-for=\"(item, index) in cardsList\" :style=\"&#123;zIndex: cardsList.length - index&#125;\" &gt; &lt;div class=\"card-img\" :style=\"&#123;backgroundImage: 'url('+ item +')'&#125;\" &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import bg1 from '../img/bg1.jpg' import bg2 from '../img/bg2.jpg' import bg3 from '../img/bg3.jpg' export default &#123; data() &#123; return &#123; cardsList: [ bg1, bg2, bg3 ] &#125; &#125; &#125;&lt;/script&gt; 滑动切换时候如何实现覆盖动效滑动切换我们可以通过监听touch事件，计算手指滑动的位移，通过translate3d(x, y, z)去控制当前卡片在x轴上的位移，当从右向左滑的时候当前卡片向左移出屏幕，设置一个滑动的临界点，超出该临界点则判定滑动到下一张图，否则回到初始位置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=\"card-list\"&gt; &lt;div class=\"card-wrapper\" v-for=\"(item, index) in cardsList\" :style=\"&#123;zIndex: cardsList.length - index&#125;\" @touchstart=\"cardTouchStart\" @touchmove=\"cardTouchMove\" @touchend=\"cardTouchEnd\" &gt; // 省略部分dom布局 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import bg1 from '../img/bg1.jpg' import bg2 from '../img/bg2.jpg' import bg3 from '../img/bg3.jpg' export default &#123; data() &#123; return &#123; cardsList: [ bg1, bg2, bg3 ], // 使用一个touch对象存储一些属性，方便后续操作 touch: &#123;&#125; &#125; &#125;, methods: &#123; cardTouchStart(e) &#123; // touch事件初始化标志位 this.touch.initiated = true // 开始滑动的x轴坐标 this.touch.startX = e.touches[0].pageX // x轴方向上的滑动偏移量 this.touch.deltaX = 0 &#125;, cardTouchMove(e) &#123; if (!this.touch.initiated) &#123; return &#125; // 滑动操作 &#125;, cardTouchEnd(e) &#123; // 重置标志位 this.touch.initiated = false &#125; &#125; &#125;&lt;/script&gt; 既然是通过translate3d进行位移变幻，我们还需要在恰当的时候初始化所有卡片的位置，这里默认初始化位置都是translate3d(0, 0, 0)，同时当前卡片滑出屏幕外的最大位移应该刚好是屏幕宽度，这样当反向滑动的时候卡片也能立即回到屏幕可见区域，所以我们代码可以这么处理：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;script&gt; import bg1 from '../img/bg1.jpg' import bg2 from '../img/bg2.jpg' import bg3 from '../img/bg3.jpg' const transform = 'transform' // 屏幕宽度 let clientWidth export default &#123; data() &#123; return &#123; cardsList: [ bg1, bg2, bg3 ], touch: &#123;&#125;, nodeList: [], imgNodeList: [], selectIndex: 0 &#125; &#125;, created() &#123; this.$nextTick(() =&gt; &#123; clientWidth = document.documentElement.clientWidth // array-like-object转换成array this.nodeList = Array.from(document.getElementsByClassName('card-wrapper')) this.imgNodeList = Array.from(document.getElementsByClassName('card-img')) // 初始化卡片位置 this.initCards() &#125;) &#125;, methods: &#123; cardTouchStart(e) &#123; // touch事件初始化标志位 this.touch.initiated = true // 开始滑动的x轴坐标 this.touch.startX = e.touches[0].pageX // x轴方向上的滑动偏移量 this.touch.deltaX = 0 // 确保卡片从初始化位置开始位移 this.initCards() &#125;, cardTouchMove(e) &#123; if (!this.touch.initiated) &#123; return &#125; // 滑动操作 &#125;, cardTouchEnd(e) &#123; // 重置标志位 this.touch.initiated = false &#125;, initCards() &#123; this.nodeList.forEach((item, index) =&gt; &#123; if (index &gt;= this.selectIndex) &#123; item.style[transform] = `translate3d(0, 0, 0)` this.imgNodeList[index].style[transform] = `translate3d(0, 0, 0)` &#125; else &#123; item.style[transform] = `translate3d(-$&#123;clientWidth&#125;px, 0, 0)` this.imgNodeList[index].style[transform] = `translate3d($&#123;clientWidth&#125;px, 0, 0)` &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 关于 initCards方法这里有几点需要解释一下，首次京晚8点这个项目每一期都有好几个视频，同时每一天晚上8点都会准时更新一只视频，所以这里用一个变量selectIndex去标识今天应该切到哪一只视频，index小于selectIndex 的卡片就会移出到屏幕外，而index大于selectIndex的卡片则会由于我们设置了z-index的关系而不可见，其次，为了达到滑动时候下一张卡片覆盖当前卡片的效果，我们这里用了一个很巧妙的方式：错位，也就是说当包裹卡片的div由于手指滑动而向左滑动出屏幕外的时候，我们控制卡片自身产生一个向右滑动同样距离的位移，这样就能给人看起来卡片没在动的假象，向右移动同理，上一个图直观的看一下： 通过代码来呈现这个效果： 1234567891011121314// 省略不相干代码 cardTouchMove(e) &#123; if (!this.touch.initiated) &#123; return &#125; // 动态偏移量 this.touch.deltaX = e.touches[0].pageX - this.touch.startX if (this.touch.deltaX &gt;= 0) &#123; // 向右滑动 &#125; else &#123; // 向左滑动 &#125; &#125;,// 省略不想干代码 以右滑为例给出大致处理过程： 123456789101112131415161718192021222324252627282930313233343536cardTouchMove(e) &#123; if (!this.touch.initiated) &#123; return &#125; // 滑动操作 // 动态偏移量 this.touch.deltaX = e.touches[0].pageX - this.touch.startX this.touch.offset = -clientWidth + this.touch.deltaX if (this.touch.deltaX &gt;= 0) &#123; if (this.selectIndex === 0) &#123; // 第一张，无法右滑 &#125; else &#123; // 向右滑动 this.nodeList[this.selectIndex].style[transform] = `translate3d(0, 0, 0)` this.imgNodeList[this.selectIndex].style[transform] = `translate3d(0, 0, 0)` // 上一张进入视野 this.nodeList[this.selectIndex - 1].style[transform] = `translate3d($&#123;this.touch.offset&#125;px, 0, 0)` this.imgNodeList[this.selectIndex - 1].style[transform] = `translate3d($&#123;-this.touch.offset&#125;px, 0, 0)` &#125; &#125; else &#123; // 向左滑动 &#125;&#125;,cardTouchEnd(e) &#123; // 重置标志位 this.touch.initiated = false if (this.touch.deltaX &gt;= 0) &#123; // 右滑 if (this.selectIndex === 0) &#123; // 第一张，无法右滑 &#125; else &#123; this.nodeList[this.selectIndex - 1].style[transform] = `translate3d(0, 0, 0)` this.imgNodeList[this.selectIndex - 1].style[transform] = `translate3d(0, 0, 0)` &#125; &#125;&#125; 看下初步效果已经出来了 如何处理临界状态以及临界延伸状态上面其实处理过一种临界状态，就是当滑动到第一张或者最后一张的时候不做处理，还有一种临界延伸状态，假设我们这个时候手指从左向右滑动，并且我们此时滑过的宽度已经超过了屏幕的宽度，这个时候对用户来说体验最好的处理是继续拉出下一张卡片，同样用向右滑动给出处理的示例： 1234567891011121314// 向右滑动this.nodeList[this.selectIndex].style[transform] = `translate3d(0, 0, 0)`this.imgNodeList[this.selectIndex].style[transform] = `translate3d(0, 0, 0)`if (this.touch.offset &lt; 0) &#123; // 右滑位移还未超出一个屏幕宽度 this.nodeList[this.selectIndex - 1].style[transform] = `translate3d($&#123;this.touch.offset&#125;px, 0, 0)` this.imgNodeList[this.selectIndex - 1].style[transform] = `translate3d($&#123;-this.touch.offset&#125;px, 0, 0)`&#125; else &#123; // 右滑位移超出了一个屏幕的宽度 this.nodeList[this.selectIndex - 1].style[transform] = `translate3d(0, 0, 0)` this.imgNodeList[this.selectIndex - 1].style[transform] = `translate3d(0, 0, 0)` this.selectIndex -= 1 this.touch.startX = e.touches[0].pageX&#125; 可以看到无缝连续过渡的效果，还有一种需要处理的情况也是出于用户体验考虑，我们应该设置一个阈值，我这里设置的是屏幕宽度的20%，当用户滑动没有超过这个阈值的时候卡片回到原来位置，超过则滑动到下一张： 12345if (this.touch.deltaX &lt; this.touch.threshold) &#123; // 回到原点 &#125; else &#123; // 执行滑动逻辑 &#125; 优化点到目前为止上面的代码示例只是给出了最基本的效果，实际项目中卡片还用到了平滑过渡，这里推荐使用tween.js的ES6实现版本es6-tween，另外，实际我们项目中处理触摸事件的时候有一点很重要的是处理多指滑动，这里提供一个比较靠谱的思路：通过官方TouchEvent API里面提供的changedTouches对象查找发生了变化的触点，通过对比这些触点的identifier属性去找到最开始触摸屏幕的那个触点，忽略其他触点的事件即可。","tags":[{"name":"滑屏效果","slug":"滑屏效果","permalink":"https://www.limuyang.cc/tags/滑屏效果/"},{"name":"京晚8点","slug":"京晚8点","permalink":"https://www.limuyang.cc/tags/京晚8点/"}]},{"title":"京晚8点-H5视频沉浸式播放解决方案","date":"2018-07-22T23:46:19.000Z","path":"2018/07/22/京晚8点-H5视频沉浸式播放解决方案/","text":"“沉浸播放式”这个概念是我从Android开发里面的沉浸式引申过来的一个概念，沉浸式其实就是隐藏页面顶部的status bar和底部的navigation bar之后呈现出来的页面，一般用户很容易把沉浸式状态栏和透明化状态栏混为一谈，他们的区别如下： 沉浸式状态栏 透明化状态栏 那么回到前端开发，让我们看一下如何让video标签呈现这种沉浸式的播放效果，平常我们使用video标签都是这样的： 123456789101112&lt;div id=\"app\"&gt; &lt;video id=\"videos\" playsinline=\"true\" webkit-playsinline=\"true\" /*IOS播放视频会自动调用原生播放器全屏播放，这里使用这个属性让IOS内播放视频的时候使用inline模式，同时我们设置宽高等于屏幕宽高来实现IOS下的全屏播放*/ x5-video-orientation=\"portraint\" preload=\"auto\" style=\"width: 100%;height: 100%\" &gt; &lt;source src=\"//gw.alicdn.com/bao/uploaded/TB1YKBlb_ZRMeJjSsppXXXrEpXa.mp4\" type=\"video/mp4\"&gt; &lt;/video&gt;&lt;/div&gt; 正常情况下我们要做竖版视频，视频的比例都是16:9，也就是高/宽约等于1.78，这里用到的测试视频也是16:9的，而且默认情况下video的object-fit属性的值是contain，也就是保持长宽比，我们先看下不做处理在iphone6/7/8下的表现情况： 看起来比较完美，因为这几款手机分辨率都是16:9的，视频维持屏幕大小完全没有问题，接下来看一下分辨率不是16:9的机型，比较典型的就是iphoneX，面向老板开发的同学可能对适配这款机型颇有怨言： 有人会觉得奇怪为什么我们设置了video的宽高都是百分百上下还漏出了两个白条，这里其实是object-fit这个属性在作怪，既然默认的是contain，我们就改为fill吧，再看一下效果: 这样看起来没问题，但是你觉得产品小姐姐会这么轻易放过你吗？too navie，你看我们正常16:9的视频在iphoneX这种18:9的屏幕上是有形变的，而且市面上这么多分辨率不同的设备，如果要追求不同的手机上有最接近的用户体验这么做肯定是不行的，有人可能会提到object-fit中的cover属性，没错，这个属性可以让我们的视频等比例缩放，如果宽高不匹配会对处理对象做裁剪操作，来我们看一下现在在微信里面的效果： 其他效果都蛮好，你会发现右上角有个可恶的全屏，这个全屏按钮是微信的x5内核自带的，没法去除，这个有很多人给腾讯x5开发团队那边提过issue，但是暂时没有办法处理，我后续会提到一个另辟蹊径的方案，先回到这里，点了这个全屏按钮之后会进入微信的全屏播放模式，而且放完之后会出现一堆广告列表，这都是我们不想看到了，其次如果我们的产品需求不单单是全屏播放，还想在视频上面放一些交互按钮之类的，这种方式就做不到，因为video是在最上一级的，但是两种方式例外，一个是微信把你们的域名加入白名单，这种可以在Android手机的video上随意放置dom元素，IOS本身没有这个限制，另一种更为通用的方式是用微信x5内核的同层播放模式，这种模式有两种好处： 去除了右上角讨厌的”全屏”按钮 真正实现了x5内核下的沉浸式播放，我们看到目前的实现在微信上还是带有浏览器的titleBar的在x5内核的环境下实现同层播放很简单，只需要在video上添加这么两行属性： 12x5-video-player-type=\"h5\"x5-video-player-fullscreen=\"true\" 再看一下这个时候的效果： 确实是真正意义上的沉浸式播放，如果你的app里面webview用的也是x5内核那么这个页面也能在app上达到同样的效果，但是这种同层播放依然有无法解决的问题，首先这个全屏模式会重新计算宽高，触发视口大小变化，也就是说用户视觉上会有一个视口变化的过程，其次，同层播放模式虽然没有了”全屏”按钮，但是左上角的按钮用于退出沉浸式全屏，右上角的按钮点开是分享，分享的内容不可定制，固定位当前页面的title+url的组合，如果你对页面的定制化要求比较高的话，我这里有一个备选的方案，那就是放弃同层播放模式，当然这个前提是你不需要在video页面上做一些交互操作，或者说你的域名处于微信白名单下，当我们在非沉浸式下又想要打到等比例缩放视频的效果，同时我们还要去除x5自带的”全屏”按钮，最好的方式就是动态去计算视频的宽高，把视频撑大，把”全屏”按钮撑出浏览器页面，这样基本就能达到我们的目的了，这里以16:9的标准为例： 123456789101112131415161718this.$nextTick(() =&gt; &#123; // 动态处理video标签宽高适配 const video = this.$refs.video const ratio = Math.fround(document.documentElement.clientHeight / document.documentElement.clientWidth) if (ratio &gt;= 1.78) &#123; // 竖屏 video.height = document.documentElement.clientHeight + 100 video.width = Math.floor(video.clientHeight * 0.572) const winW = document.documentElement.clientWidth video.style.left = (winW - video.width) / 2 + 'px' &#125; else &#123; // 宽屏 video.width = document.documentElement.clientWidth + 100 video.height = Math.floor(video.width * 1.78) const winH = document.documentElement.clientHeight video.style.top = (winH - video.height) / 2 + 'px' &#125; &#125;) 讲解下思路，16:9的视频也就是高宽比差不多是1.78，那么大于这个比例的就是类似于iphoneX的长屏幕类型的手机，对于这种手机我们要做等比缩放适配的话就以手机的长为标准，先让视频的长度等于手机的长度，这里我加上的100px可以理解为上下在加上50px，目的就是为了把视频长度拉大，让”全屏”按钮消失在视线内，实际这个值可以自己尝试修改，让后宽就是此时高的1/78倍，然后使用绝对布局去设置视频的左边距，就可以达到等比缩放的效果，同理可以理解处理宽屏手机的代码部分，当然，应该还有更完美的方案，可以在评论区留言探讨~","tags":[{"name":"video","slug":"video","permalink":"https://www.limuyang.cc/tags/video/"},{"name":"沉浸式","slug":"沉浸式","permalink":"https://www.limuyang.cc/tags/沉浸式/"},{"name":"x5内核同层播放器","slug":"x5内核同层播放器","permalink":"https://www.limuyang.cc/tags/x5内核同层播放器/"}]},{"title":"webpack从0到1使用指南","date":"2018-05-19T16:02:23.000Z","path":"2018/05/19/webpack从0到1使用指南/","text":"为什么要用webpack关于为什么要使用webpack，我比较认同的一种说法是： webpack可以很好地管理你开发中遇到的各种HTML、JS、CSS以及各种图片资源文件，同时对应不同的资源，webpack还提供了对应的Loaders将其进行转化为适用于浏览器使用的格式 如何从0开始上手webpack后会无期里面，阿吕说过这么一句话：”你连世界都没有观过，哪里来的世界观”，在我们实际的项目开发中，比如你用的是vue，那么vue已经有很好的脚手架工具(vue-cli)供你使用了，或者有的开发团队，会有技术Leader专门预先做好相关的模板，方便后来新加入的成员尽快上手项目，但是随着你开发的项目越多，你可能会越不注意到那些最基本的东西，比如说这个模板到底是如何搭建的，或者说让你自己来搭建一个模板给其他人用，是否也能做到如此的简单易上手，我想这是每一个想要在前端路上进阶的人需要考虑的问题。 最好的方式就是自己试着去搭一个最简单的模板，从0到1的过程是最痛苦的，但是1到2或者说2到3都是水到渠成的事，下面就看看怎么开始从0搭建一个基于webpack的vue的开发环境 创建项目注：使用的webpack版本为^3.10.0首先通过webstorm或者你手上的其他IDE创建一个空的项目，我这里暂且叫proWebpack，创建好后是这个样子的： 因为我们通过npm来管理包，然后每个项目的根目录下都会有一个package.json文件来管理项目的配置信息，包括名称、版本、许可证等元数据以及记录所需的各种模块，包括 执行依赖，和开发依赖，我们可以通过在命令控制台用npm init命令创建一个package.json文件，但是这样很麻烦，因为这样npm会通过命令行问答的方式来初始化并创建package.json文件，为了方便起见我们使用npm init -y，这样npm就会使用一些默认值进行初始化： ok现在我们得到一个package.json文件，包含了一些简单的信息比如name、version等字段，接下来，因为我们是想搭建一个用于vue开发环境的webpack目录结构，到目前为止还没看到vue的影子，依然是在命令行使用npm install vue --save，这里注意package.json中的依赖包有dependencies和devDependencies两种，这两种的区别：dependencies 表示我们要在生产环境下使用该依赖，devDependencies 则表示我们仅在开发环境使用该依赖，我们install时候使用–save会把包安装在dependencies 下面，所以执行完上面的命令你可以看到这样的目录结构：123456789101112131415&#123; \"name\": \"proWebpack\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"vue\": \"^2.5.16\" &#125;&#125; 然后在devDependencies下面安装webpack，再次提醒，由于webpack4变化较大，这里使用^3.10.0版本的webpack： npm install -D webpack@3.10.0，此时目录结构如下：123456789101112131415161718&#123; \"name\": \"proWebpack\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"vue\": \"^2.5.16\" &#125;, \"devDependencies\": &#123; \"webpack\": \"^3.10.0\" &#125;&#125; 创建入口文件接下来创建入口文件，在根目录下创建一个index.html作为启动页面，一个webpack.config.js作为webpack配置文件(实际项目中这里会有webpack配置文件，分别用于开发环境和生产环境，这里简便起见就用一个配置文件)，新建一个src目录，在该目录下新建一个index.js作为打包入口文件：1234567proWebpack├─ index.html 启动页面├─ package-lock.json├─ package.json 包管理├─ src│ └─ index.js 入口文件└─ webpack.config.js webpack配置文件 为了更接近vue-cli创建出来的模板，我们还需要创建一个Vue实例提供给入口文件的el挂载，这个Vue文件很简单长这样：123&lt;template&gt; &lt;div&gt;proWebpack&lt;/div&gt;&lt;/template&gt; 然后写好入口文件：1234567import Vue from 'vue'import App from '../App.vue'new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 同时别忘记在Index.html里面要提供一个供vue实例挂载的HTMLElement实例：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;proWebpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"app\"&gt;proWebpack&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样准备工作做得差不多了，下面做最核心的部分 webpack.config.js的编写webpack有这么几个核心的概念： entry 入口起点，webpack会找出入口起点的直接或间接依赖项，将他们进行处理输出为我们称之为bundle的文件中 output 输出路径，告诉 webpack 在哪里输出它所创建的 bundles以及如何给这些buldles命名 loader 因为webpack本身只能理解javascript文件，所以当我们要用vue或者React的时候可以使用相关的loader(比如我们熟知的vue-loader)来将其转换成webpack 能够处理的有效模块 plugins 扩展插件，可以用于打包的优化和压缩，这个可能要结合实际使用更好理解 module 模块 webpack中的一切你都可以理解为模块 chunk 代码块，一个 chunk 由多个模块组合而成，用于代码合并与分割。 下面开始配置，因为所有输出文件的目标路径必须是绝对路径，所以这里要用到使Node.js 的 path 模块123// 引入webpack和path模块const path = require('path')const webpck = require('webpack') 简单配置文件的entry和output12345678910111213const path = require('path')const webpck = require('webpack')const productionPath = require('./package.json').namemodule.exports = &#123; entry: &#123; index: './src/index.js' &#125;, output: &#123; path: path.join(__dirname, 'dist', productionPath), filename: 'bundle.js' &#125;&#125; 这里代码应该不难理解，就是从index.js这个入口进去，把直接或间接依赖项打包输出dist文件夹目录下,怎么运行呢，我们需要在package.json的scripts对象里面添加我们自己的build命令：12// 这里用最简单的命令&quot;build&quot;: &quot;webpack -w&quot;, 因为我们的webpack配置文件就叫webpack.config.js，默认情况下，webpack在执行的时候会搜索当前目录webpack.config.js 文件执行，实际开发中我们会使用 –config 选项来指定配置文件来对开发环境和生产环境的配置做出区分 直接在控制台npm run build，果不其然报错了：1234567ERROR in ./App.vueModule parse failed: Unexpected token (1:0)You may need an appropriate loader to handle this file type.| &lt;template&gt;| &lt;div&gt;proWebpack&lt;/div&gt;| &lt;/template&gt; @ ./src/index.js 2:0-28 很明显，webpack告诉我们他没法识别vue文件，需要我们提供一个相关的loader来处理成webpack可以识别的文件，这里先npm install vue-loader -D，然后回到webpack.config.json配置loader：123456789101112131415161718192021222324252627const path = require(&apos;path&apos;)const webpck = require(&apos;webpack&apos;)module.exports = &#123; entry: &#123; index: &apos;./src/index.js&apos; &#125;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; // 模块配置 rules: [ //模块规则(配置 loader、解析器等选项) &#123; // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test是必须匹配选项 // exclude 是必不匹配选项(优先于 test 和 include) // 对选中后的文件通过 use 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。 test: /\\.vue$/, exclude: /node_modules/, use: &#123;loader: &quot;vue-loader&quot;&#125; &#125; ] &#125;&#125; 配置好之后再run一遍，咦，又报错，我们看下主要的报错信息：1234ERROR in ./App.vueModule build failed: Error: Cannot find module &apos;vue-template-compiler&apos; at Function.Module._resolveFilename (module.js:527:15) at Function.Module._load (module.js:476:23) cannot fount那就是需要我们去install呗，但是为什么要下这个模块，我找到一个比较靠谱的说法： 其中 vue-template-compiler 是 vue-loader 的 peerDependencies，npm3 不会自动安装 peerDependencies，然而 vue-template-compiler 又是必备的，那为什么作者不将其放到 dependencies 中呢？有人在 github 上提过这个问题，我大致翻译一下作者的回答（仅供参考）：这样做的原因是因为没有可靠的方式来固定嵌套依赖的关系，怎么理解这句话？首先 vue-template-compiler 和 vue 的版本号是一致的（目前是同步更新），将 vue-template-compiler 指定为 vue-loader 的 dependencies 并不能保证 vue-template-compiler 和 vue 的版本号是相同的，让用户自己指定版本才能保证这一点。查看作者的回答（英文） 。如果两者版本不一致，运行时就不会错误提示。 那只需要我们npm i vue-template-compiler -D一下，然后在跑一遍build脚本，不出意外你应该能在项目根目录看到一个dist文件夹，把这个文件夹里面的js文件引入启动页面：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;proWebpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"app\"&gt;proWebpack&lt;/div&gt;&lt;script src=\"/dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接下来我们要访问这个页面，这里用到webpack提供的devsever来调试我们的页面， DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。这就是为什么你用vue-cli搭建出来的脚手架可以做到页面实时渲染，配置这个也很简单，在webpack.config.js里面添加如下配置：123devServer: &#123; port: 3000, // 端口号 &#125; 其实webpack-dev-server可以配置很多参数，这里不过多展开，接下来需要修改下我们的build脚本：1\"build\": \"webpack-dev-server\" 别忘了npm install一下webpack-dev-server，最后执行npm run build看到控制台报出成功信息并告诉你你的项目正运行在localhost:3000：1234567$ npm run build&gt; proWebpack@1.0.0 build D:\\proWebpack&gt; webpack-dev-server --openProject is running at http://localhost:3000/webpack output is served from / 访问localhost:3000看到如下显示的话，恭喜你，webpack配置如何从0到1你应该已经清楚了： 更进一步我们知道了怎么初步配置webpack还远远不够，实际开发中我们会遇到更多样的情况，比如说当我们只有一个输出文件的时候我们可以在output写死，就像我们上面写的：1234output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125; 但是当我们有多个文件输出的时候，一个个去写是一个费力不讨好的做法，这个时候就要用到webpack内置的变量了，我们可以这么写：1234output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;[name].[hash].js&apos; &#125; 这样会赋予每一个bundle唯一的名称，并且在每次构建过程中，生成唯一的 hash ，这时候稍微改动一下脚本文件：12345\"scripts\": &#123; \"start\": \"webpack-dev-server\", \"build\": \"webpack -w\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, 之前写一起是为了方便理解， 现在我把跑本地服务器和打包的脚本拆开写，更语义化，一般正常开发也是这么做的，先跑一下build，你会发现此时dist文件夹下面生成了新的打包文件index.8ad46f4fb5c8385db614.js，然后把这个文件同样引入index.html，跑start脚本发现结果也是照常输出，但是又有了新的问题，如果我们每次build之后都要手动引入带着一长串hash的js文件也是很蠢的事情，所以这里我们可以用上一个plugin叫做html-webpack-plugin，这个插件主要有两个作用：1、在每次编译完成之后动态为html文件引入外部资源(script、link)，对于我me你这种带hash的文件名来说无疑是极为方便的2、可以制定一个模板的html文件，html-webpack-plugin可以根据这个模板来生成html入口文件 下面看下如何使用：12345678910// 引入const HtmlWebpackPlugin = require('html-webpack-plugin') //省略若干代码 plugins: [ new HtmlWebpackPlugin(&#123; filename: './index.html', // 生成的入口文件的名字，默认就是index.html template: './index.tpl.html',// 有时候，插件自动生成的html文件，并不是我们需要结构，我们需要给它指定一个模板，让插件根据我们给的模板生成html inject: 'body',// 有四个选项值 true, body, head, false----true:默认值，script标签位于html文件的 body 底部 body:同true head:插入的js文件位于head标签内 false:不插入生成的js文件，只生成一个纯html &#125;) ], 用到的index.tpl.html只是和之前的index.html作了一点小小的区分，让人知道这是模板生成的：1234567891011// index.tpl.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;这是模板生成的&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"app\"&gt;proWebpack&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方便起见我们在package.json在添加一个clean的脚本，每次build之前先删除之前生成的dist文件：123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot;, &quot;build&quot;: &quot;npm run clean &amp;&amp; webpack -w&quot;, &quot;clean&quot;: &quot;rimraf dist&quot;, // 添加clean脚本 &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125; 然后run build一下：我们发现这个时候的入口文件已经是根据模板自动生成的了，而且自动把生成的js文件添加到了入口文件里面，同时npm run start命令看到的界面也是使用模板生成的页面，这就大功告成了。 最后其实这里还有一点没有提到的就是css的处理，除了css-loader我们平常开发还会用到一些css预处理器如scss，还有postcss等样式处理工具，这里的处理其实也不难，感兴趣的朋友可以自己尝试一下，这里由于篇幅原因(我想偷懒)就不过多展开了。","tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.limuyang.cc/tags/webpack/"}]},{"title":"未知旅程 合影留念","date":"2018-04-29T10:07:17.000Z","path":"2018/04/29/未知旅程-合影留念/","text":"从1994年的17号台风，父亲出海时浩汉10岁，莺莺口中的19年前，旅行者1号飞出太阳系，周沫所在的某中国南部影视城的黄叶满，苏米口中的天气马上变暖地这些线索基本可推知：三兄弟出发的时间大概是2013年冬天，浩汉2013年29岁左右。此行的出发点是东极岛，根据发射地点在印度，江河口中的3980公里(图上直线距离，因为浩汉偷蛋的情节里江河拿出地图说到了比例尺)，基本可推至目的地在中印边境的西藏南部。 人物分析。电影里，所有人都是骗子，也都被别人骗了。高明之处就在于，他们说的假话，骗了电影里的人，也骗了电影外的人。 胡生胡生这站，叫乡情。 如果你以为傻子就只是傻子，那你就错了。 胡生其实很明白，自己根本不适合外面的世界。在周沫工作的那个影视基地，你可以看出他对外面世界的巨大陌生与疏离。所以他骗了江河浩汉，说是去抽烟，个人觉得更有可能是他自己思考了许久，见江河浩汉已走，便自己回了东极岛。 依据是，浩汉打电话问宾馆前台，宾馆前台就没看到过“抽烟”的这个人。当然你会反驳，前台根本懒得理他们。但是按出发前江河给胡生的指示，“无论你在哪公里走丢，只要回到原地等就可以，至于其他的，我都安排好了”。所以如果胡生在原地等，宾馆、电台是一定会找到他的。 比较有意思的是这样一句话，“大家都说我脑子有问题，他们(江河浩汉)说我是正常的。”原因很简单。江河没观过世界，有着老师一样平等待人的善良。而浩汉则是因为，胡生是东极岛上唯一说他“很坚强”并且“很欣赏”他的人，所以作为本能回馈，说他脑子没问题。 然而事实是，当胡生丢了的时候，江河浩汉根本就没回头找他。只是在电台广播登了一条寻人启事。然而事实是，当寻人电台反问浩汉所寻之人是智障否的时候，浩汉没怎么犹豫就回复了“啊，对”。然而事实是，甚至在江河的幻想中，邻居周沫姐姐成名了，兄弟出书衣锦还乡了，根本就忘了有他胡生这么个人。至于为什么是江河的幻想，后面说江河的时候再解释。 胡生跑回岛上，等了他们所有人3年。从岛歌时的破败荒芜到最后的开满烟花，都没能再见到家乡曾经的朋友。胡生自离开东极岛的第一天晚上私自跑回家乡，他熟悉的，没有第二个人的东极岛，找回属于自己的平凡之路，和所有人，后会无期。 或许胡生的结局，是所有人里最好的。 周沫周沫这站，叫友情。她有点像《1988》里的孟孟，但却不是。 你身边一定有一个叫周沫的人，她儿时同你一起成长。后来，你们分开，但是，你们都没忘了彼此，偶尔联系一定会说，有机会一定一起吃个饭，或者是，要常聚常联系啊。 而她却已不是当年的她：“大城市就跟这个片场差不多，没什么意思”，“往上爬，得靠人际关系，家庭势力”。虽然自己只是个替身，不过依然乐观。因为她坚信，“背井离乡就得要出人头地”。 其实哪有公平呢，当他们走在影视基地里时，一旁的群演三五成群的聚成一堆，替身从空中吊着威亚落地，蓝色衣服的八路、绿色衣服的伪军、黑色衣服的国军打成一片，或许在镜头之外，许多正演在那边补妆吃饭，而很多想演群众演员的路人正在门外等待。他们之中有多少人只是为了混口饭吃，而又有多少人是真的有怀有一个演员梦。片场里，一行人穿过影视基地，其实是穿过了太多人的人生和喜怒哀乐。（楼主乱入一下，这里楼主认为还含有对目前泛滥的抗日神剧的一个讽刺） 在江河意淫的结局里，她红了，结尾船上的电视里，她成为万千人的偶像。或许她真的红了，因为她有一天摸透了这个行业真正的规则；或许她依旧只是个小演员，在为自己的前途努力打拼。 然而在真实的场景里，周沫骗了浩汉。 她先是试探的问了浩汉关于莺莺的情况。浩汉说自己“混得一般，留个念想”。看到浩汉依然对莺莺念念不忘，她自己找了个台阶：“幸亏我10岁的时候，就及时不喜欢你了”。或许周沫10岁那年，浩汉的父亲离开了浩汉，或许周沫10岁那年，浩汉开始与莺莺通信，从此心中只有莺莺。 然而喜欢就是喜欢。不然怎么会那么努力，去找浩汉喜欢的明星要签名照？不然在分别时，怎么有那么深情的一个回眸？ 然而，粉转路人，以及，浩汉心不在焉，这才是事实。 浩汉说粉转路人的时候，周沫的脸上，先是笑脸，然后僵住疑惑，接着是自嘲似的淡笑，最后是巨大的失落。自信满满希望能让对方喜欢，却换来一个残损的回应，浩汉啊浩汉，你哪怕是安慰我一下也好，为什么就那么忍心伤害一个喜欢着你的人？ 因为对恋人，我们习惯说假话，对朋友，我们习惯说真话。所以周沫和浩汉，只能是朋友。 然后浩汉继续补刀，说周沫“这身衣服没刚才那件好看”，周沫终于从对浩汉的幻想中走出，“这衣服也不合身，头发还是假的，你以为我有的选啊”。 你。以。为。我。有。的。选。啊。周沫的悲剧就在，她没得选。喜欢的角色没得选，喜欢的人也没得选，一切都是因为，走上的路让她没得选。 完美时不真实，真实时不完美。你看我完美时，我不过是替身。你看我不是替身时，我却只能穿上不合身的衣服，带上假的头发。 浩汉说两人从小一起长大，但却说不算青梅竹马，希望两人时常见面。周沫此时的脸上，洋溢着巨大的喜悦。没关系，你记得我们一起长大就好，没关系，你希望时常见我就好。 她希望自己有一天可以用真实的完美的站在儿时喜欢的浩汉面前。就像是他们在电影里第一次相见时那样，浩汉和他就这么互相凝望对方到出神。 她不想去接浩汉送她的花，我猜不是因为“不好拿”，而是她怕那束花侵占了拥抱浩汉的空间。她是多么希望和自己哪怕是曾经喜欢的人在可能是诀别的那次分别前互相拥抱。 然而只能是，朋友。所以，什么都没发生。周沫说去下一部戏，浩汉说去下一个地方。周沫的下一部戏，是被枪杀，是终结，是死亡，或许，也是释然。浩汉的下一个地方，据胡生的交待，是莺莺，是浩汉从未见过的lover，是希望，是新生，是浩汉在外10年的支柱和动力。然而事实是，殊途同归。 “幸亏我10岁的时候，就及时不喜欢你了”。在说这话之前，周沫用手把浩汉英俊的脸扭向自己。这个小动作像极了情侣之间信誓旦旦前的准备活动，然而周沫说出口的不是“你知道吗，从10岁那年我就一直喜欢你”，而是她知道，只能是朋友，不然连这样轻松逗弄你的机会，都没有了。 “记得啊，要是你们以后还混得不好，可以来找我”，“混得好，你们就不会来找我了”。这话虽说是“你们”，但却是对浩汉一个人说的。潜台词是“浩汉，如果你落魄，我会一直等你”“浩汉，如果你成功，就去给你爱的人幸福，那个人，一定不是我”。周沫说这话时云淡风轻，就像是对自己说一样。 我没有一个字说我爱你，但我的每一句话，每一个表情，每一个动作都在说我爱你。因为你粉转路人，因为你心不在我。所以，你。以。为。我。有。的。选。啊？我能做什么？我只能默默地，凝望你，祝福你。 这份情感，像极了莺莺口中的“但爱，就是克制”。这克制，在片场你望我的时候，在路上我逗你的时候，在桥头你伤我的时候，在路上我离开的时候。 周沫留下的那个美极了的回眸消失在浩汉继续前行的路上，眼神里，是对浩汉单纯而炽烈的情感，或许你的视线里早已没有我，但我知道，你肯定会在那个方向，转身离开。所以在你消失的那一刻，我依然可以，挂着幸福的笑。 一声枪响，在替身小演员的平凡之路上，周沫和所有人，后会无期。 然而你是这世界上最好看的姑娘。 苏米苏米这站，叫爱情。他有点像《1988》里的娜娜，但也不是。 苏米也是个骗子，不折不扣的，正义的，组团来的，骗子。 同江河的相遇，就像是江河给那个宾馆下的定义一样：“顺路又便宜，缘分吧”，于是此等便宜且顺路的“好事”，摊给了江河。 仙人跳的过程从一开始就埋好了伏笔，此时故事双线开展。浩汉注意到的那辆满身泥点的黑色轿车，这便是三叔团伙的线索。 然后电影是一段复制《1988》的开房经历：保安裹着军大衣背对着路睡在迎客松的招牌下的沙发上？前台的服务员不知去向。我叫了一声服务员，保安缓缓伸出手，把军大衣往空中一撩，放下的时候那里已经半坐着一个女服务员。服务员边整理头发边梦游一样到了前台后面。 于是转角遇到爱。苏米出场。 苏米接到了三叔发来的暗号，就是那首《Que Sera Sera》。江河当着苏米朗诵歌词中文版的时候，我想不只是苏米动了心。一个满脸沧桑，一本正经却浪漫文艺的“大叔”放在任何女生面前，都具有足够的杀伤力。就着辣酱面包的文艺大叔，让苏米认识到，这世上竟有在如此诱惑下依然淡然于此享受音乐美食的特立独行的可爱之人。江河顺手递给苏米他的黑暗料理，打断了苏米想要说的话。这时舒缓的钢琴曲盖过《QSS》，江河的单纯引发了苏米对儿时美好的思索，侧脸上，浮现了与行骗相悖的美好的笑。 这一刻，不管你时妓女也好，骗子也罢。都会疯狂对这个厨师产生莫大的好感，因为他烹饪出了，你心里怀念的味道。 他们的相爱。一个是装狠，一个是真纯。 然后是分属不同次元的二人光怪陆离的对话。 ——老师，你喜欢脚啊？——当你赤脚踩在地板上时，就不会有静电了。 这样的对话一出，便预示着二人便再无可能在一起了。最后船上的镜头，不过是《旅行者》里的镜像罢了。 “江老师，我不是你的学生，你不用对每个过客负责，也别去教路人该走那条路。”，“从小到大我都是优，你叫我怎么从良？”潜台词是：我怎么生活你管不着，你我不过路人。苏米是个有故事的人，这样的姑娘其实很难找到能说话的人。因为说出口的每句话都话中有话，可到最后你发现她通通是说给自己在听。好像肯跟着你去到天涯海角，真要离开的时候无所牵挂。 苏米虽然是个骗子，但本性依然有善的一方面。比如对肚子里孩子的绝对呵护。她关心面包里是否有防腐剂，她要赚钱在国外生孩子。她的价值观是：嫖客是错的，去赚犯错人的钱就是没错。看上去似乎有那么一点“以邪制邪”的正义。然而在三叔眼里，她和江河浩汉还都是孩子，因为“小朋友爱分对错”。 她想把自己的故事都将给江河听，这故事一定很坎坷，但无非如此：当我还是一个小女孩的时候，我问我的妈妈，我将来会成什么样呢？我会变美丽吗？我会变富有吗？她是这么的告诉我的——568包钟，868包夜。 于是在犹豫之后，她还是离开了江河。江河是男人，是男人就有成为负心汉王八蛋的可能。所以她最后还是踏上了三叔的车，带着江河给予她泯然前的挣扎，走上平凡之路，与所有人，后会无期。 莺莺 莺莺这站，叫亲情。 同样的，也是骗子，骗了浩汉19年。 在一开始，她是我们生命中最爱的那个姑娘，而她所在的地方，叫做远方。莺莺对于浩汉，在胡生一开始介绍形成的英文字幕里，就是“dream lover”。 浩汉紧张而又专注的望着莺莺老练的换着电灯泡，而后刘莺莺回头，浩汉挤出了一丝微笑，而刘莺莺却像见一个老朋友般，大大方方伸出了自己的手，自信的说出来自己的名字，浩汉伸手，却被两人中间硬隔着一个台球桌阻挡了。 横在两个人中间的，是隐藏了19年的巨大骗局。 浩汉为了掩饰尴尬提出了来一局台球，自信满满的浩汉认为拿下莺莺志在必得，不仅是球桌上的拿下。于是开球的他上来没有什么策略，就是“大力出奇迹”，即使莺莺把巧克粉放在浩汉旁边，示意让他做好准备在出杆，浩汉也丝毫不为所动。 结果自然是换莺莺上手。“你先听我说完，别问问题”第一颗球打进。 现在告诉你可能不早不晚，虽然我们认识时间久，但见面时间短。第二、三颗球打进。 19年前，9417号台风，你父亲离开了你。第四颗球打进。 你视父亲为偶像，你认为他死得其所。第五颗球打进。 其实他没死，而是来找了我和我妈。第六颗球打进。 他来换欠我们母女的债，而你也长大了。第七颗球打进。 天底下不是所有债都能还，而他对你则欠下了新债，他很想知道你的消息。第八颗球打进。 于是我们就“偶然的”认识了，我们通信，是你父亲想知道你的消息。台面上只剩最后一颗球。 然而莺莺打不下去了，收杆。因为，父亲死了，真的是真死了。莺莺一直都在说，你父亲。却从没说，咱爸。 当一场浩大的骗局在你面前被坦白的时候，你会怎么做呢。愤怒，失落，委屈，还是悲伤。浩汉拿着台球杆在一旁听完了整个事情的来龙去脉，他一言不发看着莺莺一个一个打进台面上的球，就像一层一层揭开少年时的疤。 莺莺把球半轻半重地塞入球网，一切尘埃落定，开门离开，“你消化一下吧”。 讽刺的是，浩汉眼中神话一般的父亲，不是死在搏击风浪中，而是喝了酒，抽了烟，点了房子，烧死了。 “每一封信都是我写的，”所以莺莺在乎浩汉；“只不过后来，只剩我一个人读了。”所以莺莺在乎父亲。 然而2013年，莺莺只在这个小镇，开了一家小台球厅。所以她留不住弟弟浩汉。浩汉在外打拼了10年，却只有一部车，又要送江河入职。所以浩汉载不走爱人莺莺。 “喜欢就会放肆，但爱就是克制”，浩汉临走前刘莺莺沙哑着喉咙告诉他这个道理。我想，浩汉对莺莺是放肆，而莺莺对浩汉，则是深沉的爱。既有男女之爱，也有姐弟之爱。 骗一个人19年，浩汉难过，莺莺又何尝好受。骗人的人永远比被骗的人痛苦，在她根本不想欺骗的前提下。命运可笑地将他们联系在了一起，用一种以为是偶然，但是其实是必然的方式。 “你有我的一切联系方式，走吧。”。潜台词是，“我等着你回来，在任何你想回来的时候。”。 于是浩汉上路，他甚至还没决定选择哪种情绪接受这个现实。那个注定要错过的好姑娘，转身离开，在新的一桌台球里，踏上释怀之后的平凡之路，同所有人，后会无期。 阿吕阿吕这站，叫无情。 他用高超的骗术，印证了歌词里那句“当一部车消失天际，当一个人成了谜，你不知道，他们为何离去，就像你不知道这竟是结局。”。回头再看，你仍然不知道他那句是真，那句是假。 我宁愿相信，他说的话都是真的。 你永远猜不到自己会在什么时候遇见阿吕。一个计划之中的转弯，一次计划之外的停泊，每一个转角都有可能遇见未知的旅人，但又未必就是他。 阿吕，是我们每个人生命中或早或晚，迟早要出现的那个人。 他幽默，豁达，身上背负着千山万水的情怀。他行程十几万公里，心中有着不为外人所知的遗憾。他生里来，死里去，看着最亲爱的人离开自己，又用自我的方式将她铭记——即便那不是真的。 阿吕像一个悖论，你希望成为他，但又抗拒成为他。他说，小伙子，你应该多出来走走的。江河下意识地反抗，可是我的世界观和你的不一样。于是他笑了，你连世界都没有观过，哪儿来的世界观。江河无从反驳。 终究无法抗拒阿吕的魅力，于是你信任了这样的一个人。你觉得他可交，甚至愿意和他一起上路。你满心期待，准备转身告诉他这可能是你一生中最重大的决定——接着你看到了他的背影。你不确定这是真的还是假的，只能站在原地傻傻等待，心中怀有最后的欢喜。直到他放下了所有你的行李，也卸下了你所有的期望，你到那时才相信，他给你上了一课，却无情地收了高额学费。 或许他死了，和可笑的nt3m5p卫星一样没升空就炸了，因为在高温环境下，汽油车是吃不起柴油的。或许他没死，和旅行者1号一样冲破太阳系，运气好驾着骗来的车，回到东莞卖车买摩托娶个懂他的新老婆。 他到底叫吕洞宾，还是叫吕行者？总之，在放下马达的那一刻他驱车飞驰消失，走上荒凉的平凡之路，同所有人，后会无期。 江河 江河这站，叫兄弟情。 胡生对江河老师的评价是：“他人很怪”。连胡生都觉得他怪，东极岛民自然觉得他更怪。 自带“说教”光环和“全知”光环。书本上的东西，他全都懂，而且有个“我教你”的口头禅——“这是比例尺，我教你啊”，“我教你啊，面包和辣酱……” 面包夹辣椒，工作靠分配，不喜往上爬，从事小教12年。周沫说他不思进取。如果你跳出电影看这么个男人，估计哪个女的都不愿意跟他，窝囊。 然而就像阿吕说的，“有时你想证明给一万个人看，最后发现，只有一个人懂，这就够了”，对于浩汉，那个人是胡生，而对于江河，那个人是苏米。 三叔那条线，原计划该是“警察”查房，然后捉奸，敲一笔竹杠。一向正气浩然的江河表现出了一种少有的霸气，锁上门，踹开窗，带着苏米和浩汉开溜。这一切都是为了苏米那句“你要保我”，然而在全过程中，这种霸气只是一种看似冷静的霸气。因为他完全可以让警察进来，说这是我朋友和我妻子，这样或许胡生也就不会消失。在苏米“你要保我”的催化下，江河激发出的是强烈的个人英雄主义情怀，为了这个一见钟情的女子，一改以往“动口不动手”的儒士风范，做了带她一起上路的冲动决定。于是根本来不及思索，夺窗而逃。但这逃也是非常有趣的，来看看在“身败名裂”的危机关头江河的整套下意识动作：先送苏米出，再给苏米鞋，指了奶色的车，扔出行李，再掩护队友离开，随后自己跳窗，拉上心爱的女生，冲上车，并一度在惊吓中驾驶不肯让出方向盘。这套动作考虑全面几近完美，如果不是逃跑这个目的，那简直可算作《如何成为一个女生心中的男神》的教科书范例。在这样有情有义的男子面前，我想没有哪个女生不会对他产生好感。 此时镜头不断切换优雅的苏米，紧张的江河，腿麻而龟爬的浩汉，背景音乐重复苏米敲门进入时的诱惑音乐——于苏米这只是一个排演了不知多少遍的局，于江河浩汉则关乎“身败名裂”。这样的对比冲突加上背景音乐的烘托正搔到观众的G点，舒服的不行。 “我决定的事，不会被改变。”。江河认真了，或者，还没回过神。但无论如何，他单纯的可爱。 谈谈即将分别的时候。阿吕开走了浩汉的车，两兄弟在经历了一路和谐之后，终于在最后抑制不住自己内心的情绪，产生了强烈的矛盾。江河觉得他一定有苦衷，情有可原。浩汉觉得事实放在眼前，何必用那种话安慰自己。转而产生了彼此价值观的矛盾和冲突，谁都劝说不了谁，于是一场没有结果的争斗在一望无垠的道路上展开了。这场闹剧越发强烈——直到nt3m5p轰然升空，缓缓上扬，又忽然爆炸。 在江河心中，他被阿吕“你连世界都没观过”的话刺痛，因为说到自己痛处，所以他相信阿吕没有说谎，有苦衷。然而看到连阿吕的梦“破碎”了，还没迈出第一步的自己，又去和浩汉争论什么呢？ 在这一刻，我相信不止我一个人想到《秒速5厘米》的那个片段。吐个槽，两人打得很出戏，即视感全无，根本不像是动手打人，这是我唯一找出的两个男主演的不好的地方。 在火箭残骸旁，两人最终告别。此时江河已经发生改变，他从一开始关注“入职”到关注“横穿整个中国”。改变他的，是阿吕，而浩汉与之刚刚相反，他的回复是“那有什么意义呢？”。此时浩汉也已发生改变，他从关注“横穿整个中国”到关注“意义”。改变他的，也是阿吕。 马达一定会选择江河，因为狗比人清楚，在没水，没车，没朋友的境况下，浩汉原路折返，能不能活着走出这戈壁，都是问题。这是马达设定的第一个必要。 马达设定的第二个必要，就是印证江河之死。一会再说这个问题。 说说让人觉得甚至有些生硬的“后来”。 一周目的时候，觉得这结局简直草率。直到四周目的时候，我似乎看明白了点。 江河回到东极岛时，下着大雨。然而东极岛的柴伯公雕像，就是那个自由男神，居然举着燃烧的火炬！ 大雨和火，在东极岛之歌的尾声出现过短短一瞬，毫无疑问，火燃烧了一刹那，就熄灭了。然而在结尾，大雨之中火炬居然熊熊燃烧在天际。 然后是幽灵导游的出现。全场景，只有江河一个人在山上走。 接着是无厘头的“80集电视剧”和“观影狂潮”，以及超越《继承者》。这里又有个很大的矛盾，电视连续剧怎么能用“观影”呢？而且，这样天马行空的介绍甚至扯到韩国收视，未免也太天马行空了吧？最后导游的话是，“要买纪念品的朋友请往这边走”，整组画面依然是江河和山头。莫非是平行时空里天上的街市？是否能这样大胆猜测，唯一解释的是，“后来”不过是江河《旅行者》里的镜像。也就是把小说里的象征性描写语言以画面的形式展示。柴伯公的火代表理想自由与探索之火，在现实的滂沱大雨面前依然熊熊燃烧。幽灵导游则是反映了东极岛被建设的十分繁华。 于是后面的情节也顺畅了起来。在《旅行者》这部书里，江河依旧没忘记自己钟爱的教育事业，东极岛又有了学校，于是你看到了孩子们满街跑。船上电视里放着火了的周沫，那个理解他，告诉他人各有志的女子(浩汉则一直对江河小教12年表示不屑)。跟他之前向浩汉所承诺过的那样(当时两个人在没有挡风玻璃的车里，最后还飘来一张报纸砸在浩汉头上)，他没有给浩汉一个结局，而是把最后留给了苏米。船上，苏米依偎在他的肩头。 这是《旅行者》的结局，不是《后会无期》的结局。苏米要出国生孩子，江河在西藏支教，同时丢失了苏米的卡片。如果最后的“后来”是真正的结局，那么两人相遇的概率是多少？这部电影还会叫《后会无期》么？ 这或许就是江河的一场梦吧，《旅行者》中，江河的幻想的镜像。 江河篇的最后，说说江河之死。 一开始，我以为江河不会死，他会安静的在西藏写字，教书。然后一个细节让我改变了这个想法。 没错，就是【猫狗人】。电影里一个出现了2次的npc。摘录猫狗人原话如下： “我在这个城市生活6年了，可是一直没什么朋友。我养了4只猫，可是大家都说应该养狗诶，男的嘛，我觉得狗啊，是一种需要陪伴的动物，我是很喜欢狗的，但是我没有勇气养，可是在夜晚来临的时候，我就看着窗外的车流，我觉得这个世上这么多人，可是没有人想听我说话。” 然后节目到点，猫狗人的话被停掉。 “你好主持人，我今天终于迈出了这一步，我把那4只猫送给朋友了。我养了1条狗。” “那我可以再迈出一步吗？我们现在在天台上。” 这就是两个故事：4猫换1狗+抱狗自杀。 这说的不就是江河么：怪，所以没朋友。4只猫，苏米、胡生、浩汉、阿吕，换1只狗，马达。这不就是这条无期之路么？到了西藏，他算是迈出了一步，那我可以再迈出一步么？那个地方，除了马达，以他的怪异，似乎叫不到朋友，而且那个地方，有几个人能通他在一个水平线上交流？写完了《旅行者》，他便没有什么期望了，苏米不知何处，而他又是个“等着分配”“不会争取”“不喜欢往上爬”的人，在没有什么动机，让他上路。 于是这个不喜欢往上爬的人选择下落。 “那我可以再迈出一步么？”“当然可以。”“我们现在在天台上。” 我们是江河、马达，当然，还有他紧握着的《旅行者》里的浩汉、阿吕、胡生、周沫、莺莺。以及靠在他肩头的，他再也找不到的，苏米。 浩汉浩汉哥。整部电影的灵魂和泪点，他是很多台词的注解。是“像你像他像那野草野花”的最好注解。有时候你真觉得，自己或是身边的人，像极了浩汉。 浩汉这站，叫绝情。 他也是骗子，不过他自以为是的觉得能骗了所有人，其实，他只是骗了自己。 在胡生眼里，“浩汉哥是个在外面闯荡过的男人。”——幼年丧父，“出海捕鱼4年、出租车司机开了3年，跑运输2年，幼儿园保安干了1年。”。于是他买了一辆米色的车(但所有女人都会叫：哇，奶色《1988》乱入)，“想回家乡大干一场”。 然后就发生了开始的那一幕。东极岛最后的岛民们开了一场演唱会，估计是庆祝“大岛建小岛迁”的政策，主题是离乡歌唱晚会，晚会上，还很可能演唱了岛民们为了歌颂小岛而创作的《东极岛之歌》。就如同电影里播放《东极岛之歌》时的画面一样一样的，目的很简单，反讽。 浩汉哥在胡生的叙述中出场，他在台上的神演讲一语成谶：“我今天上了这个台，就不怕自己下不了台，现在我要说，我们要……” 回头再看，发现几乎所有的关于浩汉的剧情似乎都在讲，他怎么威风凛凛的上台，又是怎么“不怕让自己下不了台”的。 然后话筒扩音断了。这是必然的。电影场景里里，舞台上的工作人员已经把音箱都拉走了。 介绍一下这几组镜头的电影场景，台上是话筒和乐谱架，台下是小板凳。浩汉哥登台时，台下观众坐着塑料小板凳鼓掌，从下台演员的装束可推知，节目不是大合唱就是诗朗诵。胡生说了，他和他的两个兄弟，也就是江河浩汉是最后离开东极岛的。所以基本可推知晚会主题可能与迁居离乡有关。 至于浩汉上台没说完的那句，从他和江河胡生的对话和遇到阿吕之后那天晚上的对话可基本补全：“现在我要说，我们要齐心协力，把我们的东极岛建设成海上丽江，那片海岸上的沙滩，可以建成阳光沙滩(Sun of beach)……”。 然而，没人鸟他。除了胡生：“他很坚强，我很欣赏”。 胡生的欣赏不是没有道理的。在整个家乡都已经破落到无力回天的时候，在家乡的一条路还没有一辆车宽的时候，浩汉是整个东极岛唯一有勇气重建家乡的人，他的梦想是【振兴家乡的旅游业】。所以，【浩汉是一个有乡土情结的人，他爱自己的家乡】。也可以把这当做歌词里“当每个繁星抛弃银河的夜里”的注解，浩汉，就是那个繁星。 然而事实是：虽然浩汉满地都是“朋友”，他自己还是被家乡轰走。以送江河之名上路，顺路拜访周沫、莺莺。 这还不是浩汉上路的全部原因。在振兴家乡旅游业这个梦想受阻之后，他希望通过这一路的冒险，让自己有所收获，有所历练。希望可以遇上一些人和事让自己强大，甚至可以帮助自己，振兴家乡旅游业。而且，他的新车需要上路，不然不是白买了。这辆车在他眼里，是他可以对江河、胡生臭屁的资本。你看，江老师，我至少现在能用这交通工具送你上路，我还在外面认识不少人，满地都是我朋友，哪儿拉屎都有人给我送纸。 至少在出发时，他是这么想的。 当然，也有一丝悲壮。“带的走的留不下，留不下的别牵挂”，或许你没看懂他决定烧掉自己的房子的意义。这个行动的台词是：混不好，就别回来了，要像出海搏击风浪的父亲一样，要么衣锦还乡，要么客死他乡。从后来莺莺谈到信件中的内容可推知，浩汉有轻微的恋父倾向，或者说，崇拜父亲。 戏剧的是，爆炸过后，浩汉的房子没有倒。反倒是胡生和周沫的房子倒下了，从《后会无期》曲子放出是浩汉安慰胡生的动作可佐证胡生的房子倒了，后面和周沫的对话可佐证周沫的房子也倒了，所以剩下没倒的，是浩汉的房子。然而房子倒了的，周沫和胡生，安然无恙。房子没倒的浩汉，却真的客死他乡。这房子能留下，也算是一个念想。供若干年后，胡生、莺莺、周沫凭吊故人罢。这或许可以微微算作为浩汉之死埋下的第一条线。 然后三人上路。 周沫篇已经分析了二人的感情，周沫其实是喜欢浩汉的。然而此时浩汉心里只有莺莺，他来找周沫的原因，一是单纯看周沫，因为两人儿时感情好，二是看周沫混得好不好，能否成为他振兴家乡旅游业的合作伙伴。然而周沫只是个替身小演员。在影视基地的路上，浩汉似乎有种撮合周沫和江河的意思，仔细看会发现，江河一直和周沫谈论人生，浩汉一直在和胡生嘻嘻哈哈，而除非周沫主动询问，浩汉不会主动挑起话题。原因可能有二，一是心怀愧疚，二是避嫌不想让周沫旧情重燃。 在江河苏米线里，浩汉则继续扮演撮合的月老角色。因为他知道江河木讷怪异，满口说教惹人厌烦，能让江河产生爱意并且也对他产生爱意的女生不多。浩汉处处为兄弟江河打圆场：“但我要跟你说的是，我们两个都在帮你，尤其是我旁边这位。”，“从来不知道替自己争取一下”(为兄弟鸣不平，同时恨铁不成钢)，在白客过来寻事时“休想动我朋友”，小声提醒江河“昨天晚上这是个局”，拉开白客“让他们聊”，在宾馆发现的可疑车辆追来时快步赶回加油站，在江河加了柴油后也没怎么发火，甚至快步走上三叔面前“你这样不对啊”要给“三叔一个忠告”，只为了给江河与苏米博取一点机会，那半句被三叔忠告打断的话非常直白“你怎么说我都可以，但我朋友……”……在与自己无关的这条线里浩汉从没酱油，而区别于浩汉莺莺线里，江河的酱油。因为浩汉知道，江河这傻小子，根本不懂女人。然而浩汉这样淡淡的关怀以及包容，却丝毫没有，充斥着现下主流价值观的基情四射。而就是让你简单的感觉，来自兄弟的那一点支持。这在于二人的演技和语言动作的设定。你单纯分析两人的人设，一个臭屁，一个闷骚，这特么不就是标准的攻受二人组么，但你代入电影去看，你就不得不佩服台词、动作、演员对角色的拿捏的功力，因为这么攻受的人设，你却能看出微微的兄弟情。然而兄弟情不就是这样的么，不需要太浓，我懂你就好。 三叔这个人非常经典，可谓句句成谶。明天单独拿来分析。他那句“我一早知道你不是好人，没想到连坏人都不是，你这样怎么在社会上混啊。”和“汽油车不能加柴油。”绝对是对这一路旅程的注解。 然后是浩汉的失误，在回答电台主持人“是智障吗？”这个问题时，给出了“啊，是。”的回复。导致胡生因不愿意接受这个称呼而放弃与电台取得联系，从而回到东极岛的结局。 接下来是浩汉满地捡钱的情节，这就是转折的分界点。掏手机的一个意外，导致钱掉，导致晒钱晒卡片，导致车挡风玻璃被偷和卡片丢失，导致两人耽误行程遇上阿吕，导致车被偷，导致浩汉锐变，导致二人分别，导致浩汉之死。卡片丢失，导致江河与苏米失联，间接导致江河之死。这么一看，这个小细节的设计，关系到后面一系列的大事件发生。可怕的蝴蝶效应。 两人带上头盔继续上路。江河提出写《旅行者》的想法。这时有一段很关键的对话。浩汉：“记得结尾的地方把我美化一下。”江河：“不，浩汉，那个位子不是留给你的，有很多话我们在生活里说不出口，所以在书的结尾，我要对苏米说：”然后是尼玛一张报纸。这里通过《旅行者》的暗示，表明在最后，也就是结局，浩汉不会出现。结合最后一幕，那段“最后一面”“最后一句”，可基本推知，浩汉死了。佐证见下文。 夹蛋那段又很有寓意。我们用自己习惯的方式去达成目标，发现结果是各种失败。当成功近在咫尺，却功亏一篑。你换一种方式达到目标，然而这时候你才发现，这目标早已不是你想要的了。这概括这段旅程的意义。三人以习惯的方式上路，却一路囧途，各种失败。在离目的地不远的地方，功亏一篑车被开走了。换作步行走到目的地的时候两人发现，和当初各自想要的相去甚远。江河想去入职，可却受阿吕影响，产生了“横穿整个中国”的豪迈。浩汉想去探寻冒险的意义和情义的价值，一路走来，他发出了“那也比情义这两个字寿命长”的感叹。不过，这都是后话了。 接着是让浩汉三观第一次崩坍的19年欺骗，在莺莺篇里基本分析清楚了。浩汉的对莺莺的所有情感，都被莺莺一句“喜欢就是放肆”概括了，而莺莺对浩汉的所有情感，都被莺莺一句“带爱就是克制”概括了。浩汉还能说什么，只能将放肆克制，然后选择一个新的环境，新的心情。离开。莺莺的离去，浩汉的第一根支柱倒塌。 在这里顺路提一下浩汉的父亲，“带的走的留不下，留不下的别牵挂”，这正是浩汉父亲的写照，他带浩汉来到了东极岛，却没能把浩汉留在身边，所以浩汉父亲离开的时候，起初的打算一定是不再牵挂浩汉。然而那是他亲生的儿子，怎么能不牵挂。子如父，两人虽然表面看似洒脱，但却都不能做到真正洒脱，因为此时浩汉心中，尚有【情义】二字牵绊。 当浩汉知道父亲居然是这样一个人的时候，第二根支柱倒塌。儿时坚持的，崇拜的都是假的虚无的，没有搏击风浪，只有死的窝囊。 之后浩汉心情低落，在浩汉计划的行程里，在他没把握的周沫和有把握的莺莺那里，他都没有找的他想要的—【事业】和【情义】。不过想到未知的远方，他又悄悄鼓起勇气，因为他除了相信一定有让他为这段旅途的意义作注解的人和事出现，对江河的询问，他只是搪塞了一句“没事，还是送你去入职要紧”。这和之前“你就等着看好戏吧”的胸有成竹形成巨大反差。意在点名经过此事，浩汉元气大伤，你看，这时的他早没有我的朋友满地是的臭屁得意了。 所以这时候他帮江河想了一个结尾，就是电影最后的那段结尾，浩汉用来用以自我安慰，却没想到让所有人为这句话做了注解。电影此时的场景，和电影结尾的场景完全一致。可断定故事结尾是从这里剪出去的。（楼主乱入一下，其实两幕场景并不相同，最后的时候车外飘着小雪，而此时的场景没有，所以必然其中一个是现实，另一个是小说中）还有一个证据就是《女儿情》这首歌的生硬插入，就像是打断场景一样。这是电影叙事的有意为之。 《女儿情》这首歌的插入其实也是有深意的，在人物分析篇之后的bgm和歌曲分析篇里，我将一一驳斥所谓的“bgm乱入说”和“抄袭音乐裁缝郭敬明MV说”。 在《女儿情》的进程中，司机换成了江河。而后浩汉为了给自己打气唱起了歌，结果马达出场。 至于马达的意义，已在江河篇做了说明，不再赘述。从二人收留马达时，马达就注定选江河，因为你想想看，马达是怎么醒来的？浩汉一巴掌扇醒的。我不知道狗记不记仇，反正如果黑这部电影的人被醍醐灌顶的扇了一巴掌，他们肯定记仇。 带马达上路的时候，你已经能明显感觉到浩汉的无力感：“连家乡都没了，哪来的什么家门，我们跟野人有什么区别。”之后是更大的迷茫，他们进了迷宫，“你确定是这条路吗？”，“我们是不是来过这里啊？”。这里江河问浩汉，其实都是在打自己的脸。大家还记得江河出发前对胡生说过什么吗？“至于其他的，我都安排好了。”你看江河是地理老师，他能准确的说出nt3m5p的含义，然而让他真正走在路上，他却只能不断询问浩汉路走对了没。然而浩汉嘴上一直说“确定”，但二人始终在迷宫里打转。其实就是在说明，在人生旅途中，江河浩汉迷失了，江河的百科全书在现实面前毫无用场，浩汉开着车原地打圈圈，还不承认自己迷失。情节这个时候就是在攒大招，让二人一直掉血、掉血、掉血，只为了槽满憋一个人的上线，带二人走出迷茫。 于是阿吕应运而生。这个人就是为了让江河浩汉从“失落失望失掉所有方向”中挣扎出来的神一般的“骗子”。这个角色设定的恐怖就在于，他让二人没有看到“看见平凡才是唯一的路”，而是把二人带到巨大的精神狂热中，然后一骑绝尘。你看，走向平凡之路的人都会活得好好的：周沫、胡生、苏米、莺莺。阿吕带着江河浩汉非要在这么一条平凡之路上另辟蹊径，什么卫星啊，一号啊环中国啊之类虚无缥缈的，结果这三个人，少说生死未卜，按我的看法，导演编辑就是把他们往死里写的。 为什么。你们说，这个世界，需要阿吕这样理想主义和浪漫主义么？阿吕就是带他们上路，可惜却把他们丢在半路，于是江河浩汉陷入了更大的危机之中，就是所谓的信仰缺失。这部电影本身就是在自嘲。 好了关于主题的讨论日后分析。今天这章的重点在人物，我们继续。 很明显，浩汉是不喜欢让阿吕同行的。但队友送人头，没办法，阿吕上车了。浩汉开始开始瞧不起阿吕的，因为我有车你没有，所以他说“14万公里算不了什么。”随后，的这个回答，让阿吕一度成为旅途的掌控者：“我为的是自由，而你却是为了生活。”这一句，让阿吕逼格或者情怀立马爆棚。吐个槽，这句话的句式怎么那么像苍老师的某句名言啊。此时浩汉依旧不依不饶，逼问之下，阿吕说出了摩托车被偷的窘境。说的时候阿吕迟疑了一下，不知道是不好意思，还是有所隐瞒。估计两种解释都有道理。对阿吕的解读一直是双线并且互不冲突的，你可以认为阿吕一直说真话，也可以认为他一直说假话，也可以认为他一会说真话一会说假话。在没有肯定证据和完善想法前，个人倾向是阿吕一直说真话，半夜在行程上与江河产生矛盾，然后决定偷车完成所谓的理想。 这里有个地方其实在印证其实阿吕说的不全是真话。过隧道的时候，高呼“我不在乎”，然而他根本不知道这个隧道有多长。于是越过隧道后，缺氧的他说了句：“这隧道怎么这么长。”说明，对这段跑了6遍的路，他确实不太熟悉。之后只听到浩汉的一句英文，就自信断定浩汉是教书的，“我悬崖都摔过好几次，一般人的职业，我一眼就能看出来”，这句打脸也能看出他并不是那么的神。 但是这并不妨碍浩汉的改变。因为阿吕的出现，他开始对旅途重拾信心。原因是，他们在阿吕的带领下找到了路，注意路是双重含义，地理意义和人生意义上的。浩汉甚至在小解后对阿吕说出了要和他一起骑摩托车回到东极岛上的想法。“放心吧，明天等我把朋友送到目的地，我们就骑摩托车回去。”浩汉这么说，可推测，他的计划就该是送江河到站，卖车买摩托，和阿吕一起做一个“伟大的骑士”，拍照片，写稿件，让人们认识东极岛，这样家乡的旅游业就可以振兴了。 从此刻起，浩汉满血复活。但这次的复活，却是为殒命做铺垫。 在电台里，有个老女人问大夫男根固本丸的事，我曾经一度将之与阿吕的那句命根子肯定硬联系起来，认为这女的是阿吕的夫人。但阿吕帮二人走出了交警检查的困境，这说明阿吕跟这一带的交警很熟，于是我放弃了这样的分析。要知道，浩汉开的可是无照车，一路没走过车多的路。 接着阿吕给浩汉和江河讲述了同学会和老婆的故事。然后浩汉发现，这个人和自己是多么惊人的相似，阿吕的同学会和浩汉的上台下不了台不过是一个故事的两个讲法而已，你大声疾呼，结果是，根本没人鸟你。浩汉就是那个想证明给一万个人看的人，结果，真的只有一个人懂。而那个人是胡生。 接着是那段nt3m5p。这玩意我反正是没百度到，但是确实有点神，你想，芬兰卫星，印度发射，追赶旅行者1号。产地，发射地，目的地的联系太微弱了。或许历史上真的有，恕我孤陋寡闻。对这点，做个标记。留待之后查证。这个晚上对主线构成影响的是两件事，旧矛盾的解决和新矛盾的产生。旧矛盾是头盔事件，被nt3m5p解决。新矛盾是行程安排，江河高呼，“可是我明天要入职诶”，阿吕根本不鸟，“我老婆如果能看到nt3m5p发射，一定很高兴”。车主浩汉的回答其实很明确，不看卫星，送江河入职，“我恢复得很快，男人嘛，不要为儿女情长的事情所牵绊，最重要的是事业。”这就是在告诉阿吕，别想你老婆的事了，搭着我的车，要听我的话。这个矛盾直接导致了偷车事件。阿吕也给了二人答复：“今天是旅行者1号，冲破太阳系，进入浩瀚宇宙的日子。”“他这样在太空孤独的漂流，只为了这样一个简单的理由，就是要到外面的世界看一眼”所以，我，吕行者2号是一定要去看一看的，你们这些菜鸟，挡不住我的。这话里的深意，浩汉显然没听懂。 阿吕还有一句是说给江河的“有些人，一辈子只蜷在一个角落里，连窗户都懒得开，更别说踏出门”。此时音乐走起，天光微醒。这句话算是点醒了江河，这也可能是江河为什么江河一直替阿吕说好话的一个原因吧。 然后是猫狗人之死，已分析过不赘述。 如果你对半夜的矛盾有预设，阿吕接下来的偷车计划就特别明显了。先让二人休息一下，自己去试车，试了一下，浩汉没察觉，他就开走了。中途放下照片，马达和行李。他还不想害死两人。 于是浩汉当着江河的面，又一次重复了开头的打脸画面，威风凛凛的跑上台，高呼着自己不怕下不了台，说着路遥知马力日久见人心的豪言，看着话筒没声——车被开走，一句话都说不出来。 自此满血浩汉回到濒死状态。自己在旅途中建立起来的第三根支柱倒塌。车换摩托的骑士事业，和刚刚建立起信任的情义顷刻间化为乌有。要注意，浩汉一直在强调的两个东西，事业和情义。现在都没了。活着对他而言的意义，只剩下一个，送江河。 江河说阿吕有苦处，阿吕则说自己有痛处。当情义，事业都消失了。浩汉只剩下疼痛的自己，车没了，自己再没有臭屁的资格了。甚至一贯斯文的他在此时爆出了第一句粗。 江河依然对阿吕的话奉若神明，重复着“人真的不应该只蜷缩在一个角落的。”骗了自己那么久，浩汉也第一次承认自己“我是没什么事业的”。“但我不会出来作孽”，我着谁惹谁了？凭什么我的车被偷”。这句话更像是在帮导演说。韩寒既视感：我是没什么事业，但也没出来作孽，凭什么我就代笔了？于是我就拍了这部电影，然后告诉黑黑们，韩仁均先生就藏在片场工作台的抽屉里，我只要不知道该怎么拍了，就打开抽屉问韩仁均先生这是该用仰拍啊还是俯拍啊，韩仁均先生就会告诉我，世事难料啊，难料啊，难料啊——568包钟，868包夜。 好了，大半夜码字太困太热了，寝室没空调，只能自己编个冷笑话降降温解解乏，顺便调戏一下无脑黑黑们。继续。 江河继续为阿吕辩护，浩汉直接归因于两人世界观不同。江河那句没讲完的“可是”笔者估计是想说，“可是阿吕说的对，我连世界都没观过，根本没有世界观” 然后是呼应开头的桥段，照片洗出来了。上路时浩汉说“未知旅程，合影留念。”然而结果是——“好不容易拍张合影还没有脸……”。哎，没有脸。 然后是浩汉很没有理智的把责任推给江河，浩汉什么都没了，也只能在江河面前，当一回马后炮教训他一番了。“我好心送你，你乱勾搭女人，把胡生给丢了，乱信任男人，把车给丢了，还替别人说话”平心而论，这一系列的事情的发生，两人都有责任。 两人的争执非常合理，被真善美和阿吕洗脑的江河党们是阿吕的忠实粉丝，而车被偷了情义事业都没了一无所有就等着慷慨赴死的浩汉派是阿吕的铁杆黑黑。谈到妓女问题，两方动起手来。 这时秒速5厘米上映。然后炸了。这个炸不是两个王也不是四个二，是一定具有象征意义的。阿吕的理想破碎了，这就像是你拉着你老婆去看胸口碎大石，结果却看到了大石碎胸口一样。 这种失落，相信江河浩汉都感受到了。 于是打斗似乎都变得没有意义，跑到这大戈壁图的是什么，难道是和同行伙伴solo么？显然不是，这个爆炸，让二人重新回到，定义目的的问题上。 当然，江河的目的似乎是达到了，翻过山头就是入职地。但他却变得非常不安，你看江河不断重复的那句话：“人真的不应该只蜷缩在一个角落的。”完蛋，这荒凉戈壁我来教书，不就是有把我圈在一个角落么。所以在这个角度上，江河自杀的可能性非常大。 而浩汉的目的呢？周沫是个伪后没起来，莺莺打野打废了，本来以为有个很牛父亲光环居然是个毒buff。打钱不容易，半路鸟被杀了装备直接让敌人运回血池。先知江河跑去送人头，请问浩汉怎么打？谈个求目的。 温水煮青蛙，《1988》里的经典桥段，表达两人对现实和自身的不同看法，是个人就懂不解释。 结局很好理解。焦躁的江河和绝望的浩汉。一个从沉睡的世界观里决定苏醒却注定只能继续沉睡，另一个连世界观是什么都不知道了。马达注定选江河，因为浩汉没水没食物没交通工具，原路返回，基本就挂在戈壁里了。江河这个连世界都没观过的人，早忘记浩汉怎么回去这档子事了。他现在满脑子就是，完蛋了，我被圈住了，人不应该永远蜷在一个角落的，怎么办，完蛋了。 浩汉最后说的几句话很耐人寻味：“我要去忙我的失业了”然而他自己也说了“我是没什么事业”他还在不遗余力的骗自己，或许只不过是在赴死前保留他一贯臭屁的高姿态。“可那又有什么意义呢”，这时候的浩汉已经心力交瘁了，根本不再去想出发前“横穿整个国家”的豪言壮语，更别谈意义了，能当饭吃么，能当车开么。“你不适合在这个社会上混”，此时的浩汉依然懂江河内心真正的想法，浩汉知道江河陷入了温水煮青蛙的绝境中，被现实的锅盖死死盖在荒凉戈壁，却生出了一颗跳出蜷缩之地的心。所以狗给你吧，至少可以互相陪伴。于是他放下狗，头也不回就走了。他知道狗不会陪他一起赴死。所以一眼都没回头看过。 当然浩汉在死之前依然选择欺骗自己，我这种人，哪都是朋友，狗你留着吧，我走了。 浩汉真的就走了，他没有平凡之路可走，他无路可走，在一无所有的戈壁里，和所有人，后会无期。 五周目看到东极岛胡生目睹东极岛开出绚烂烟花的那一刻，我不知道是不是有人像我一样，觉得这就像是《飞屋》里，最后那个房子落在老人设计的那个地方。虽然江河浩汉都已长逝，东极岛这个在浩汉眼中“多好的概念”还是成为旅游胜地。浩汉【振兴家乡的旅游业】之梦，终于成为现实。我想胡生必是代替浩汉看到了东极岛的繁荣，如此九泉之下，浩汉也可瞑目了罢。然而胡生，却只能在东极岛上，等江河浩汉，一个又一个三年。 五周目看完，听《后会无期》《平凡之路》《女儿情》《QSS》，真的，可以飙泪。 首先我必须道歉。除了1周目是在电影院看的，2-5周目都是看的ts。请原谅一个学生党没收入的苦衷。电影院看完1周目，我真心觉得这片子没故事性，但是很轻松，很能逗乐。我想就算是一部喜剧片，他也至少可以及格了。在2014年，你或许还真找不出几部能让你从头会心笑到尾的电影。当然，这只是1周目的感受，当时我只对柴伯公雕像大雨中的玄冥火耿耿于怀。于是手贱想ts求证一下。但是看的时候就各种脊背发凉了。 昨天和今天凌晨更完的主线人物篇在【阿吕】【江河】】【浩汉】这三篇中有很多内容上的错综问题，结构和情感也没有【胡生】【周沫】【莺莺】这三篇拿捏的到位，而且因为热饿困的影响，很多时候写着写着就忘了之前的篇章里写没写了，造成了一定的问题，今天也是要把人物篇做一个整合。 在四、五周目的逐帧分析里，我的word里面是截图了的。鉴于电影上映问题，暂不发截图。等一切尘埃落定，我自会新开一贴，对所有细节一一分析。 或许这真的是一部第一遍笑，第二遍笑不粗感到沉重，到第三遍泪目的电影吧。也或许这就是导演想要达到的效果。 对于普通青年，它就是一部喜剧；对于文艺青年，它就是一部文艺片；对于喜欢作死磕细节的2B青年，它就是一部黑色幽默的公路片。对于不是青年的人，请出门左拐，《小3时代》等你。 然而那些自以为是文艺青年却没认真看几遍就瞎喷的，还是到幼儿园学学怎么刷牙和做眼保健操吧。 欢迎讨论。楼主要开始6刷了。ts清晰度太差，而且少了部分情节，有些地方写的不到位，还望各位吧友海涵。 （以上就是原作者截止到目前为止的全文，楼主尚有三个疑惑作者并未解答：1、浩然和阿力在哪？结尾演员表上有两个人的名字，而电影中始终没有出现。2、从莺莺那出来片中和结尾到底哪个是真实哪个是小说？3、男根固本丸的广告到底是纯粹为了搞笑还是另有寓意？） —- 转自后会无期吧原文链接","tags":[{"name":"后会无期","slug":"后会无期","permalink":"https://www.limuyang.cc/tags/后会无期/"},{"name":"影评","slug":"影评","permalink":"https://www.limuyang.cc/tags/影评/"}]},{"title":"vue-router中使用EventBus传值需要注意到的问题","date":"2018-03-31T22:26:58.000Z","path":"2018/03/31/vue-router中使用EventBus传值需要注意到的问题/","text":"最近负责开发一个视频相关的项目，要用到vue-router，同时涉及到一些共有状态管理，但是少量的状态又不想用vuex，于是用到了EventBus，一般来说， 我们用EventBus的步骤如下： 首先新建一个js用来创建我们的EventBus，如Bus.js 123import Vue from 'vue'; ...export default new Vue(); 接着，我们在需要的地方通过$emit触发自定义事件，比如我这个时候有一个视频当前播放时间的状态需要传递 123import Bus from '../components/Bus.js'...Bus.$emit('currentTime', 'time') 再然后就是我们在另一个路由页面(就分别叫页面A和B吧)通过$on监听自定义事件 123import Bus from '../components/Bus.js'...Bus.$on('currentTime', (time) =&gt; console.log(time)) 通常情况下这个是应该可以打印出我们想要的数据，但是经我实验发现，当第一次通过路由跳转页面的时候控制台是没有任何输出的，只有第二次跳转开始控制台才有输出，然后我就去查了下资料，发现有这么一种说法: vue-router切换的时候，会先加载新的组件，当新的组件渲染好但是还没mount的时候，销毁旧组件，然后再挂载新组件，也就是说当B页面的生命周期进行到beforeMount的时候，下一步走到的就是A页面的beforeDestory方法和接下去的destroyed方法 要知道我们一般都是在B页面的created方法里面去使用$on监听自定义事件，但是通过上面那段话我们知道，当我们在create方法里面监听事件的时候$emit事件已经发出去了，此时监听器还没有注册，那么要让$on监听到A页面的$emit发出的事件，可以在A页面的beforeDestory或destroyed去执行$emit，附上vue-router切换时候相关的生命周期顺序图： 图片出自 但是我这个项目和这个人有不一样的地方，因为我需要留存上一个路由页面的状态，所以我在router-view的外面用了keep-alive属性，所以也就不存在A页面会走到beforeDestory和destoryed的说法，那么这时候该怎么做，我一开始是做了实验，既然我直接$emit那边接收不到，那我就延迟去$emit，一开始我用了个2s的延迟: 12345import Bus from '../components/Bus.js'...setTimeout(() =&gt; &#123; Bus.$emit('currentTime', 'time')&#125;, 2000) 目的就是让B页面$on执行开始监听事件的时候我再去$emit，发现是可以的，我又把时间减少到1s，依然正常运行，但是如果我们要去精确计算两个页面的切换时间岂不是太蠢，后来我就想到了vue自带的一个方法，敲黑板vm.$nextTick( [callback] )，这个方法的作用就是在dom更新之后异步执行回调方法，我在这个时候去$emit果然能够成功获取到数据，大功告成。 顺便说一句，如果路由外面没有使用keep-alive的话，你会发现随着切换次数增多$on监听事件执行的次数也越来越多，和你切换页面的次数成正比，尤大在issue里面说这是因为$on事件是不会自动清除的，也就是说你切换的次数越多$on监听也会越来越多，解决的方法是需要在B页面的beforeDestroy里面手动使用$off去关闭监听: 1234import Bus from '../components/Bus.js'beforeDestory() &#123; Bus.$off('currentTime', (time) =&gt; console.log(time))&#125; 以上 参考链接vue2 eventbus 求解惑vue中eventbus被多次触发（vue中使用eventbus踩过的坑）","tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://www.limuyang.cc/tags/vue-router/"},{"name":"eventbus","slug":"eventbus","permalink":"https://www.limuyang.cc/tags/eventbus/"}]},{"title":"不吹不黑聊聊前端框架--尤雨溪Live整理","date":"2017-11-10T22:58:38.000Z","path":"2017/11/10/不吹不黑聊聊前端框架-尤雨溪Live整理/","text":"最近买了尤雨溪大大的Live：不吹不黑聊聊前端框架，这场Live让我的前端思维到了前所未有的高度：当我们身为前端开发萌新，在前端人才金字塔的浮动与挣扎中思考该学什么框架、该如何入门前端、又遇到学习瓶颈怎么办的时候，正是这些业界大牛们用自己的行动引导着我们，有如尤大所说：多思考场景需求，多看看技术到底做了怎样的取舍，现在把相关的东西作为笔记整理下来，希望对前端开发有兴趣的同学都可以去支持一下尤大 组件可以是函数想象一下整个应用是一个大的函数，函数里面可以调用别的函数，每一个组件是一个函数，一个组件可以调用其他的函数，整个一个树状结构 组件是有分类的 纯展示型的组件，数据进，DOM出，直观明了 接入型组件，在React场景下的container component，这种组件会跟数据层的service打交道，会包含一些跟服务器或者说数据源打交道的逻辑，container会把数据向下传递给展示型组件 交互型组件，典型的例子是对于表单组件的封装和加强，大部分的组件库都是以交互型组件为主，比如说Element UI，特点是有比较复杂的交互逻辑，但是是比较通用的逻辑，强调组件的复用 功能型组件，以Vue的应用场景举例，路由的router-view组件、transition组件，本身并不渲染任何内容，是一个逻辑型的东西，作为一种扩展或者是抽象机制存在 JSX和模版的对比JSX本质就是Javascript，它完全获得了Javascript的灵活度，它最大的价值在于书写功能型组件的时候比纯模版更好，但是模版在展示型和其他的用例上也是不差的，模版会让你更少的把逻辑放在视图里面，展示型的组件虽然在逻辑上比较简单但是在样式上还是具有一定的复杂度 代码的拆分(colocation)把应该放一起的东西放一起，比如说在vue的单文件组件里面我们把模版、样式和javascript的逻辑都是放在一起的，目前主流框架都是这么做的，如果这概念扩展开来，组件的文档也是可以和组件的其他东西放一起的，组件化之后和传统的Separation of concern就有区别了，传统的Separation of concern是以语言为单位作切分，组件是以组件本身作为一个切分的抽象 变化侦测和渲染机制 渲染机制 现代的前端框架里面渲染这块最重要的是声明式(Declarative)，相比较之下的概念是命令式(Imperative)，Imperative最直接的例子是我们使用Jquery时候拿到一个选择器”直接干”，使用命令去进行操作，直截了当，但是很快就会遇到维护性的问题，英文里面有个词叫做jQuery Spaghetti，Spaghetti的意思是意大利面，这个词的意思就是说你的代码写到后面会像一坨意大利面一样，维护起来很困难，声明式的好处就是说我们直接描述说数据和DOM结构之间的映射关系应该是怎么样的，不需要我们手动去做这些操作 React里面有一个等式 view = render(state) ，这里render就是我们在React里面写的render函数，vue的模版其实也是编译成渲染函数的，所以模版和JSX之间的本质是相似的，输入state，输出DOM，理想情况下我们就是描述了这样一种关系，那输入变了输出也会跟着变，我们不需要顾虑输入和输出之间发生了什么事情，具体到底层实现可以是Virtual DOM，但并不一定得是Virtual DOM，可以是细粒度的绑定 变化侦测 用过vue的朋友知道vue的数据是响应式的，vue会把你传递的数据进行转化，转化过后当你改变一些属性的值的时候，vue就会进行相应的更新，附上尤大相关的演讲PPT，里面有详细的过程：ppt Live提问：问：一直有一个疑问，以前 被人诟病，为啥 vue 的声明式写法就是推崇的？答：HTML里面这个onclick里面的Javascript的作用域是全局的，当你在vue里面这么写的时候是有很明确的Javascript作用域的，你的绑定以及你的method所能触及的影响范围是设定好的，这个跟全局的Javascript有本质的区别，另外当我们在vue或者Reac里面这么写的时候你的Javascript逻辑和你的模版或者说你的JSX是在一起的，可以联想我们之前提到的colocation的概念，所以并不会造成一个维护上的困难，但是如果你在全局的Html里面这样直接裸写，你完全不知道你这段Javascript可能会引用到哪里的变量或者是调用的哪里的方法 简单的总结，变化侦测主要分为两种： pull所谓pull，系统不知道数据什么时候变了，它需要一个信号去告诉它说数据有可能变了，在这个系统才会去进行一次比较暴力的比对，在React里面的表现是Virtual Dom Diff，在Angular里面就是整个脏检查的流程，能够这么做的前提是现在Javascript足够快，虽然有浪费但是性能上也可以接受 push相比之下，vue的响应式数据或者RXJS的数据机制，在数据变动之后立刻就可以知道数据变动了，而且一定程序上我们会知道哪些数据变了，这样就可以进行相对更细粒度的更新，pull的这种更新是最粗粒度的，所以在大型应用里面我们要帮助系统来减少一些无用功，但是push的形式也有它的缺陷，粒度越细，你的每一个绑定都会需要一个observabel/watcher，这样会带来相应的内存以及依赖追踪的开销，所以在vue2里面选择的是一个比较中等粒度的方案，在组件级别是push，每一个组件是一个响应式的watcher，当数据变动时候我们可以对组件进行更新，在每个组件内部则是用Virtual Dom进行比对，push和pull之间的本质区别是在于用侦测成本换取一定程度的自动优化 状态管理状态管理这个概念其实也是在FB提出了Flux之后才搬到台面上来讲，Flux在经历了初期的混乱竞争之后慢慢的合流到了Redux上，vux在一定程度受到了Redux的影响，状态管理的本质是从源事件(source event)映射到状态的迁移和改变，然后在映射到UI的变化，声明式的渲染已经帮我们解决了从状态到UI的映射，这一块，所以状态管理这些库他们做的实际上是如何管理将事件源映射到状态变化的过程，如何将这个映射的过程从视图组件中剥离出来，如何组织这一部分代码来提高可维护性，是状态管理要解决的本质问题 把 Vue 当 Redux 用把 Vue 当 MobX 用 现在的状态管理方案还面临一些其他的共同的尴尬，一个是组件的局部状态和全局状态如何区分，现在是局部状态和全局状态并没有很明显的区分，另一个是全局状态和服务端数据之间，现有的方案是把服务端抓过来的数据塞到store里面去 路由路由是只有在大型的单页应用才会遇到的一个问题，传统的路由思想是比较有侵入式的，每个路由有自己的数据模型，有自己的模板等，但是当Reac和vue出现之后人们发现把路由和组件解耦是可行的并且还更加灵活，比如Reac直接用不带路由是完全没问题的，另一个启示是，如果从组件出发去思考路由，本质上就变成了把一个url映射到组件树结构的一个过程，url到组件的映射会有一些小的分歧，我们到底是应该从url出发，还是从这个状态出发，其实本质是一样的，因为url就是一个序列化的状态。 当实际在SPA中去做一个你会发现路由会涉及到许多其他问题，比如说hash模式和history模式如何兼容，重定向，别名，懒加载，然后最复杂的是跳转，路由之间的跳转需要提供各种”钩子”，然后这些”钩子”里面又可能做异步操作，”钩子”里面也有可能取消这次跳转，使得这次跳转无效等等。 整体来说现在主要的路由方案都有点相似，比较有意思的是最新的reat-router4，他推崇的是一种用组件本身来做路由的一种思路，这里很大程度上利用了上述第四大组件”功能型组件”，在父组件里面声明式的渲染其他组件，跟传统的路由组件方案的区别是”去中心化”，他不是把整个路由表写在一个地方，是分散的写在各个组件里头，这样做的好处是灵活性非常好，但是也有一些问题，首先，集中式的路由表对于理解整个应用的结构是有帮助的，另一方面，去中心化的路由对于跳转的管理会弱一些，他对于跳转的管理是直接用组件的生命周期去做的。 web路由和app路由的区别：目前web路由整体思路上是一样的，将url映射到组件树，从一个url跳转到另一个url，我们把新的url push到历史的stack里面去了，但是stack前一个位置所对应的位置是被我们丢弃掉的，我们从一个状态迁移到另一个状态我们整个应用界面迁移到另一个状态了，原生应用上的跳转就像一叠卡片一样，新的界面会盖在现有的界面上，当你退回去的时候只是把当前的卡片拿掉，之前的卡片就会出现，web用的路由方案做app会比较别扭。 CSS方案主流的 CSS 方案 跟 JS 完全解耦，靠预处理器和比如 BEM 这样的规范来保持可维护性，偏传统 CSS Modules，依然是 CSS，但是通过编译来避免 CSS 类名的全局冲突 各类 CSS-in-JS 方案，React 社区为代表，比较激进 Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面），一种比较折中的方案 比较 CSS 方案时首先要明确场景的问题，如果应用逻辑已经组件化了，是一个比较复杂应用的开发，传统的 CSS 方式可维护性就有问题了react-css-in-js反对css-in-js的文章 传统 css 的一些问题： 作用域 Critical CSS Atomic CSS 分发复用 跨平台复用 css-in-js有很多不同的方案，这些方案各自解决了上述的一些问题，但是并不完美： CSS Modules，Inline-Styles，vue的单文件组件里面直接加一个scoped都可以解决这个问题 所谓的Critical ，比如说我们直出一个页面，可能我们整个应用有几十个页面，但是我们直出的永远是第一个页面，如果没一个页面都有一个对应的CSS的话，理论上渲染首屏我们只需要首屏的CSS就够了，这就是所谓的Critical CSS，在服务端渲染尤为重要，解决的办法是在服务端渲染的时候侦测到渲染要用到哪些CSS，css-in-js和vue2.3+有一个运行时的功能，在编译过程里面可以把CSS的插入跟组件的生命周期挂钩，同样可以起到收集Critical CSS的效果 Live提问：问：在vue里 使用CSS Modules 会不会比 使用 scoped 好？答：我个人觉得没有什么本质的区别，scoped的成本会更低一点，CSS Modules会有一定的运行时的代价，因为需要用动态的class绑定 Atomic CSS的概念：比如说我们有两条CSS规则，一条是color：red，一条是color：green，我们写两个button的样式，一个按钮是红的，一个按钮是绿的，原子类的话就会把color：red单独拆成一个类：A，把color：green单独拆成一个类：B，然后所有button共享的再拆成一个类：C，然后红色的button可以说是AC，绿色的button是BC，总而言之就是把尽可能多的共享的一些单独的规则都拆成一个很小很小的类，这样出来的最后的结果是你的CSS可压缩性更好了，可以变得更小，对应于css-in-js里面的Style Chunk 分发复用的论点是说css-in-js都是Javascript，所以可以跟普通的Javascript模块一样直接发包到npm上去复用，确实Javascript比纯CSS更容易去组合复用，但是css你也可以发到npm上然后webpack直接引用，这一点上并不算完全的优势 跨平台复用：VueX里面就是把静态的css在parse之后编译成Javascript，就可以跨平台复用了 构建工具构建工具解决的其实是几方面的问题： 任务的自动化 开发体验和效率（新的语言功能，语法糖，hot reload 等等） 部署相关的需求 编译时优化 大公司里怎样开发和部署前端代码 虽然 Vue 本身用 flow，但建议使用 TypeScript 的 flow，主要从开发体验、生态完善度上考虑 服务端数据通信长久以来我们传统的做法都是围绕Rest，服务端如果暴露的是一个比较标准的Rest API，那我们客户端就可以直接拿一个fetch直接去抓，或者围绕Rest来做一个资源的抽象/封装，特定的应用会遇到比较复杂的场景，一种是，数据直连，数据之间有大量的关联性，另一类是有实时推送同步的需求，这种情况下传统的Rest做法会比较痛苦。Vue.js 服务器端渲染指南 跨平台渲染从前端框架的角度去看，跨平台渲染的本质是在设计框架的时候要让框架的渲染机制和DOM解耦，这里面有很多种实现方式，并不一定需要Virtual Dom，本质上只要把框架更新时候的一些节点操作封装起来，你就可以做到跨平台，一个原生的渲染引擎，比如 React Native 和 VueX本质都是在底层针对每个平台有一个适配的渲染引擎，只要把渲染引擎暴露的结点操作的 API，跟框架运行时对接一下，就可以实现将框架里面的代码渲染到原生的目的。这里的解耦很清晰，这也是为什么能看到 NG 可以接 React Native，VueX 可以跑 Vue 文件，VueX 可以跑在 NativeScript 上等等。 新规范 Web ComponentWeb Component 和类 React、Angular、Vue 组件化技术谁会成为未来？ WebAssembly是面向 Web 的通用二进制和文本格式，可以跑在浏览器里面。但是在目前的形势下，WebAssembly 暂时还操作不了 DOM，对于框架的影响暂时比较有限，待观望 总结总结一下吧，我们聊了很多东西，可能比较杂，但我希望大家发现其中一些共性的东西：技术方案都是先有问题，再有思路，同时伴随着取舍。在选择衡量技术的时候，尽量去思考这个技术背后是在解决什么问题，它做了怎样的取舍。这样一方面可以帮助我们更好的理解和使用这些技术，也为以后哪天你遇到业务中的特殊情况，需要自己做方案的时候打好基础。","tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.limuyang.cc/tags/前端框架/"},{"name":"知乎Live","slug":"知乎Live","permalink":"https://www.limuyang.cc/tags/知乎Live/"},{"name":"尤雨溪","slug":"尤雨溪","permalink":"https://www.limuyang.cc/tags/尤雨溪/"}]},{"title":"javascript中call、apply、bind方法的使用","date":"2017-11-08T20:50:19.000Z","path":"2017/11/08/javascript中call、apply、bind方法的使用/","text":"context的概念在知道我们为什么要使用call、apply、bind方法之前，我觉得有必要先了解一下context的相关概念，通常context的作用是取决于函数将如何被调用，当函数作为对象的方法调用时，this就会被设置为调用方法的对象：1234567var object = &#123; foo: function()&#123; console.log(this === object); &#125; &#125;; object.foo(); // true 当通过new一个对象的实例的方式来调用一个函数的时候，this的值将被设置为新创建的实例：123456function foo()&#123; console.log(this); &#125; foo() // window new foo() // foo&#123;&#125; 当作为未绑定对象被调用时，this默认指向全局上下文或者浏览器中的window对象。然而，如果函数在严格模式下被执行，上下文将被默认为undefined 动态改变this的值然而call、apply、bind方法允许你在自定义的context中执行函数，什么意思呢，通俗的说就是可以不遵循上面给出的部分定义，可以动态的改变this，我们直接引出MDN关于call方法的定义： call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表) 举个例子：123456789// 非严格模式下function add(args) &#123; console.log(this); &#125; function sub(args) &#123; console.log(this); &#125; add(); // Window &#123;frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …&#125; sub(); // Window &#123;frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …&#125; 结果是符合预期的： 当作为未绑定对象被调用时，this默认指向全局上下文或者浏览器中的window对象 我们给他加上call方法：1234567891011// 非严格模式下 function add(args) &#123; console.log(this); &#125; function sub(args) &#123; console.log(this); &#125; add(); // Window &#123;frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …&#125; sub(); // Window &#123;frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …&#125; add.call(sub,1); // ƒ sub(args) &#123; ... &#125; sub.call(add,1); // ƒ add(args) &#123; ... &#125; 这时候this的值有点类似于第一种情况： 当函数作为对象的方法调用时，this就会被设置为调用方法的对象 看起来我们调用call方法的时候好像实际上是进行了对象方法的调用： 12345678sub.call(add,1); //sub=&gt;var sub = &#123; add: function()&#123; console.log(this); &#125;&#125;;sub.add(); // sub 这就是动态的改变了this还有一点要注意的是，这里call和apply方法第一个参数的this值并不一定是该函数执行时真正的this值，比如在非严格模式下，我们传入null或undefined会自动指向全局对象，在浏览器环境中就是window，在node环境中就是global，另外我们还可以传入一些原始值(数字，字符串，布尔值)，这时候的this会指向这些原始值的包装对象，比如传入的是数字，会指向Number。 call和apply的区别既然call和apply方法能够动态的改变this的值，我们可以利用这个特性来实现简单的继承，比如此时我们有一个父构造函数：1234567function Product(name, age) &#123; this.name = name; this.age = age; this.say = function() &#123; console.log(this.name+\"is\"+this.age+\"years old\"); &#125; &#125; 如果我们想写一个子构造函数，只需要在子构造函数里面调用父构造函数的call方法就可以实现继承：1234function Toy(name, price) &#123; Product.call(this, name, price); this.self = \"single\"; &#125; 实现继承的同时父子构造函数还都能分别有自己的属性，比如这里的self属性。这里使用了call方法作为演示，其实apply方法的使用和call方法并无多大区别，重点在参数上，他们的第一个参数都是一个指定的this值，这个值可以是任意js对象，但是第二个参数有区别，call方法接受的是若干个参数的列表，而apply方法接受的是一个包含多个参数的数组，如果上面的例子用apply来写的话就是这样：123456789101112function Product(name, age) &#123; this.name = name; this.age = age; this.say = function() &#123; console.log(this.name+\"is\"+this.age+\"years old\"); &#125; &#125; function Toy(name, price) &#123; Product.apply(this, [name, price]); this.self = \"single\"; &#125; bind方法的特殊性之所以把bind方法单独放出来是因为bind方法和前面两者还是有不小的区别的，虽然都是动态改变this的值，举个例子：123456789101112var obj = &#123; x: 81, &#125;; var foo = &#123; getX: function() &#123; return this.x; &#125; &#125; console.log(foo.getX.bind(obj)()); //81 console.log(foo.getX.call(obj)); //81 console.log(foo.getX.apply(obj)); //81 有没有注意到使用bind方法时候后面还要多加上一对括号，因为使用bind只是返回了对应函数并没有立即执行，而call和apply方法是立即执行的，并且MDN还提到，当使用new操作符调用绑定函数时指定的this参数会变无效：1234567891011var obj = &#123; x: 81, &#125;; var foo = &#123; getX: function() &#123; return this.x; &#125; &#125; var result = foo.getX.bind(obj); console.log(new result()); //getX bind方法的另一个应用是使一个函数拥有预设的初始函数，这些参数作为bind的第二个参数跟在this(或其他对象)后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面：1234567891011function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]// Create a function with a preset leading argumentvar leadingThirtysevenList = list.bind(undefined, 37);var list2 = leadingThirtysevenList(); // [37]var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3] 参考链接Understanding Scope and Context in JavaScript Function.prototype.call()","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"call","slug":"call","permalink":"https://www.limuyang.cc/tags/call/"},{"name":"apply","slug":"apply","permalink":"https://www.limuyang.cc/tags/apply/"},{"name":"bind","slug":"bind","permalink":"https://www.limuyang.cc/tags/bind/"}]},{"title":"javascript立即执行函数(IIFE)","date":"2017-09-11T21:46:54.000Z","path":"2017/09/11/javascript立即执行函数-IIFE/","text":"通常我们声明一个函数有以下几种方式：12345678910111213141516171819202122// 声明函数f1function f1() &#123; console.log(\"f1\");&#125;// 通过()来调用此函数f1();//一个匿名函数的函数表达式，被赋值给变量f2:var f2 = function() &#123; console.log(\"f2\");&#125;//通过()来调用此函数f2();//一个命名为f3的函数的函数表达式(这里的函数名可以随意命名，可以不必和变量f3重名)，被赋值给变量f3:var f3 = function f3() &#123; console.log(\"f3\");&#125;//通过()来调用此函数f3(); 如果你看过一些自定义控件的话你会发现他们大多数都是沿用这种写法： 1234(function() &#123; ... // 这里开始写功能需求 &#125;)(); 这是我们常说的立即执行函数(IIFE)，顾名思义，也就是说这个函数是立即执行函数体的，不需要你额外去主动的去调用，一般情况下我们只对匿名函数使用IIFE，这么做有两个目的： 一是不必为函数命名，避免了污染全局变量 二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 如果看到这两句话无法理解，那么先从IIFE的运行原理说起。 因为IIFE通常用于匿名函数，这里就用简单的匿名函数作为栗子： 1234var f = function()&#123; console.log(\"f\");&#125;f(); 我们发现这里f只是这个匿名函数的一个引用变量，那么既然f()能够调用这个函数，我把f替换成函数本身可以么： 123function()&#123; console.log(\"f\");&#125;(); 运行之后得到如下结果： 1Uncaught SyntaxError: Unexpected token ( 产生这个错误的原因是，Javascript引擎看到function关键字之后，认为后面跟的是函数声明语句，不应该以圆括号结尾。解决方法就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算，这里区分一下函数声明和函数表达式： 12345671、函数声明(即我们通常使用function x()&#123;&#125;来声明一个函数)function myFunction () &#123; /* logic here */ &#125;2、函数表达式(类似以这种的形式)var myFunction = function () &#123; /* logic here */ &#125;;var myObj = &#123; myFunction: function () &#123; /* logic here */ &#125;&#125;; 小学我们就学过用()括起来的表达式会先执行，就像下面这样： 11+(2+3) //这里先运行小括号里面的内容没有意见撒 其实在javascript中小括号也有相似的作用，Javascript引擎看到function关键字会认为是函数声明语句，那么如果Javascript引擎优先看到小括号会怎么样： 1234//用小括号把函数包裹起来(function()&#123; console.log(\"f\");&#125;)(); 函数成功执行了： 1f //控制台输出 这种情况下Javascript引擎就会认为这是一个表达式，而不是函数声明，当然要让Javascript引擎认为这是一个表达式的方法还有很多： 1234567!function()&#123;&#125;();+function()&#123;&#125;();-function()&#123;&#125;();~function()&#123;&#125;();new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // 只有传递参数时，才需要最后那个圆括号。... 回到前面的问题，为什么说IIFE这种形式避免了污染全局变量，如果你见过别人写的jquery插件，里面通常会有类似这样的代码： 1234(function($)&#123; ... //插件实现代码&#125;)(jQuery); 这里的jquery其实是该匿名函数的参数，联想一下我们调用匿名函数时候是用f()那么匿名带参数的就是f(args)对吧，这里把jquery作为参数传入该函数，那么在函数内部使用形参$的时候就不会影响到外部环境，因为有些插件也会用到$这个限定符，你在这个函数内部可以随意折腾。 以上，在此过程中参考了以下两篇文章： javascript立即执行某个函数：插件中function(){}()再思考 JavaScript中的立即执行函数","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.limuyang.cc/tags/javascript/"},{"name":"IIFE","slug":"IIFE","permalink":"https://www.limuyang.cc/tags/IIFE/"}]},{"title":"告别五月","date":"2017-06-01T22:06:01.000Z","path":"2017/06/01/告别五月/","text":"2017年6月1号转眼就跑到那似水流年里去了，然而身边的人都不珍视自己的似水流年我要告别5月 诉一整个5月是我成长最快的日子我心里很乱，当我沿着这条路走下去的时候心里总想着另一条路上的事好像王小波在《黄金时代》中描述到的：”那一年我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。” 别在2017-06-01这个节点我把多说换成了搜狐畅言让我和你告个别开源不易，且行且珍惜 离我只愿蓬勃的生活在此时此刻成为一名真正意义上的移动WEB前端开发工程师“移动”两字是我刻意加上去的，很好的显露出我没有如愿成为一名移动开发工程师的不忿最后，我发现我真的胖了。","tags":[{"name":"告别","slug":"告别","permalink":"https://www.limuyang.cc/tags/告别/"}]},{"title":"自始至终","date":"2017-02-17T22:25:29.000Z","path":"2017/02/17/自始至终/","text":"我已经快忘了来这座城市的初衷 我总是没有勇气把生活过的波澜壮阔 2016-6-26，我终于离开了生活和学习了四年的城市，这个城市含着与我记忆无关的繁华，就这么走了也没捎上一句不咸不淡的问候 人最可悲的心甘情愿用不知道多少个日夜的交替去执着自己不该执着的事物,然而早已白露不是惊蛰，世间也不存在那壶让人醉生梦死的酒我只知道这个城市有我无法割舍的记忆和无法忘却的故人… 2017年元旦去了一趟东极之东，那里晚霞中的风车阵太美,傍晚的暮霭渐渐化成粉色的温柔…其实东极还有另一种宁静，那是大家启程返航的时候，我们懈怠了一点，于是看到的也多一点，那时候的东极才是真正的东极… 你很难找到跟你性情相通的人，你发现你只是一个存在， 又或者在别人眼里根本就看不见你。","tags":[{"name":"自始至终","slug":"自始至终","permalink":"https://www.limuyang.cc/tags/自始至终/"}]},{"title":"Handler机制从入门到放弃(二)","date":"2016-10-29T22:48:19.000Z","path":"2016/10/29/Handler机制从入门到放弃-二/","text":"从注释看起Hander的源码只有不到800行，而且大多数代码相对来说还是比较好理解的，尤其是相对于其他更加接近底层的代码来说，在看源码时候有一点挺重要的就是不要忽略注释的作用，Handler类开头有这么几行注释： 123&lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own. 归纳一下就是：- 安排消息和任务在将来的某一个点执行- 使一个动作进入队列为了能够在另一个线程中执行回顾一下我们为什么要用Handler：&gt; 在Android中，当要更新UI的时候，我们必须要在主线程中进行更新，原因时当主线程被阻塞了5s以上就会出现ANR异常，会导致程序崩溃。所以一些耗时的操作必须要放在子线程中，但是在子线程中又不能做更新UI的操作，所以为了解决这个问题，Android设计了handler机制。这么一对比，很容易的印证了这段话：使一个动作进入队列在另一个线程中执行：这不就是异步执行耗时任务么；安排消息和任务在将来的某一个点执行：联想一下postDelayed之类的延时操作的方法，或者给出一个很常见的例子，比如说引导页延时启动：12345678910111213141516171819new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; Log.d(\"ThreadName 1\",Thread.currentThread().getName()); //第一次登陆扫描本地音乐 if (SPUtils.getValue(SplashActivity.this, \"isFirst\", \"First\", true)) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //耗时操作 //清空表 Log.d(\"ThreadName 2\",Thread.currentThread().getName()); DataSupport.deleteAll(MusicInfoDetail.class); MusicUtils.scanMusic(SplashActivity.this, musicInfo); DataSupport.saveAll(musicInfo); SPUtils.putValue(SplashActivity.this, \"isFirst\", \"First\", false); &#125; &#125;).start(); &#125;, 2000); 这里是我自己的Demo里面的一部分代码，这里使用postDelayed延时2s启动，然后在子线程执行更新数据库的操作，很好的印证了上面两点。 创建Handler在上一篇文章Handler机制从入门到放弃(一)里面我们已经演示了两种创建Handler的方法并且给出了部分实际操作的代码，但是都是在主线程也就是UI线程创建的，我们可以尝试一下在子线程中创建Handler： 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; private Handler mainHandler; private Handler childHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainHandler=new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; childHandler=new Handler(); &#125; &#125;).start(); &#125;&#125; 运行一下，果不其然代码蹦了： 报错信息： 1java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare() 告诉我们说在Thread里面创建Handler需要调用Looper.prepare( )，那把这一句加上试试： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private Handler mainHandler; private Handler childHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainHandler=new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); childHandler=new Handler(); &#125; &#125;).start(); &#125;&#125; 果然很成功的运行了，但是这是为什么，来看一下Handler的源码： 这里提供一个简便的方法，为了快速找到原因可以在打开的源码(我这里使用sublimeText查看)里使用ctrl+f快捷键搜索Looper.prepare( )出现的地方： 123456789101112131415161718public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 这是Handler的其中一个构造方法，看到这么一段： 12345mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; 在构造方法里通过Looper.myLooper()获取到一个Looper对象mLooper，如果为空则报错，找到Looper.myLooper()方法： 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 注释给出的解释是这个方法回返回跟当前线程相关联的Looper对象，如果没有则返回空，还是没找到答案，接着找Looper类里面对sThreadLocal的定义： 12// sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 又是注释里面告诉了我们重要信息，这里告诉我们只有你调用了Looper.prepare()方法sThreadLocal.get()才不会返回空，那么说来说去还是要看Looper.prepare()的代码： 12345678910111213141516/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 看下面那个，Looper.prepare()调用了prepare()的重载方法prepare(boolean quitAllowed)并且传入了true参数，这个方法判断sThreadLocal.get()是否会返回一个Looper对象，如果没有的话就set一个新的Looper进去，如果已经有了再调用prepare()方法的话就会报错，不信邪的可以在mainHandler创建之前也调用一个Looper.prepare()，控制台就会出现这个错误： 那么问题来了，为什么我们在主线程创建Handler不需要调用Looper.prepare()，而在子线程中需要呢，可以合理的猜想是不是系统给我们主动调用了，毕竟我们大部分的操作还是在主线程上，每次都要那么Looper.prepare()来一次多麻烦，有了猜想还要去源码寻求验证，主线程是ActivityThread，从ActivityThread类里搜索相关信息，用跟上面一样的方法： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 抓重点： 1Looper.prepareMainLooper(); 找到Looper类中关于这个方法的定义： 123456789101112131415/** * Initialize the current thread as a looper, marking it as an * application&apos;s main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125; 这里又会主动调用prepare(boolean quitAllowed)方法，通过注释也了解到我们不需要主动去创建UI线程的looper，系统自动会给我们创建好了，这里印证了前面的猜想。 这里得出一个结论： 在主线程中可以直接创建Handler对象，而在子线程中需要先调用Looper.prepare()才能创建Handler对象。 这里先不管Looper是什么，暂时知道有这个东西，下面可以看一下如何发送消息。 如何发送消息这里就用到了第二种创建Handler的方法： 1234567891011Handler myHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //根据参数进行操作 break; &#125; super.handleMessage(msg); &#125; &#125;; //其他地方调用myHandler.sendMessage(xxx); 这里的其他地方调用指的就是在子线程里面，当我们在子线程里面执行完耗时操作之后如果需要传递一些数据给主线程，比如通知主线程更新UI之类的，就可以这么做： 12345678910111213141516171819202122final Handler myHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //根据参数进行操作 &#125; &#125; &#125;; new Thread(new Runnable() &#123; @Override public void run() &#123; Message msg=new Message(); //what是用户自定义的识别码 msg.what=1; //通过arg1和arg2可以给Message传递简单的int型数据 msg.arg1=123; msg.arg2=456; //通过给obj赋值Object类型传递向Message传入任意数据 msg.obj=null; myHandler.sendMessage(msg); &#125; &#125;).start(); 当然除了传递这些简单数据之外Message类还能以setData方式携带Bundle数据： 123Bundle bundle = new Bundle(); bundle.putString(\"data\", \"data\"); message.setData(bundle); 我们看到这里是在子线程中调用了sendMessage(msg)方法，然而我们却在主线程中使用handleMessage(Message msg)接受消息，这之间一定发生了一些不可描述的事情，让我们来找找看，当然除了sendMessage(msg)方法Message类还有许多其他发送消息的方法： 1234567891011121314151617181920212223public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0); &#125; public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis); &#125; public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis); &#125; ..... 巧的是，这些方法无论转折多少次都走向了同一个方法： 1234567891011121314151617181920212223242526272829/** * Enqueue a message into the message queue after all pending messages * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;. * &lt;b&gt;The time-base is &#123;@link android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt; * Time spent in deep sleep will add an additional delay to execution. * You will receive it in &#123;@link #handleMessage&#125;, in the thread attached * to this handler. * * @param uptimeMillis The absolute time at which the message should be * delivered, using the * &#123;@link android.os.SystemClock#uptimeMillis&#125; time-base. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. */ public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; 这个方法接受两个参数，msg和uptimeMillis，msg就是我们需要传递的消息，uptimeMillis则是发送消息时候的绝对时刻，它的值等于自系统开机到当前时间的毫秒数再加上延迟时间，这个延迟时间就是我们调用sendxxxDelayed里面传入的时间参数，这个方法会把一个消息放入消息队列(message queue)，然后把这个方法的两个参数加上新建的MessageQueue 对象传入enqueueMessage(queue, msg, uptimeMillis)方法里，从字面上理解MessageQueue 是一个消息队列，那么队列就会有入队和出队的方法，这个enqueueMessage(queue, msg, uptimeMillis)应该就是入队的方法： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 没有发现什么，这里又调用了enqueueMessage(msg, uptimeMillis)方法，这个方法在MessageQueue类里面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 代码有点长，一步一步看，先看前面一部分： 123456if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; 这里判断了一下msg.target对象是否为空，还记得之前的enqueueMessage(queue, msg, uptimeMillis)方法吗： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 这个方法是在Handler中执行的，这里把一个this对象赋值给msg.target，那么从Message类找一下这个target到底是什么，找到这个： 1/*package*/ Handler target; 这样脉络就很清晰了，这里是把Handler跟Message对象绑定起来，接着往下看： 12345678910111213141516171819202122232425262728293031323334msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; 这个msg.when就是用传入的uptimeMillis参数赋值，表示入队时间，看到这个if判断： 12345678if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; ... &#125; 有人可能会好奇这个when怎么会为0呢，这里提一嘴，Handler除了有正常的sendMessage之流的方法还有一个比较特殊的方法： 12345678910public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0); &#125; 这个方法特殊在什么地方呢，打个比方，如果说我们正常的sendMessage之流的方法是一群正常排队的人，按照来的时间先后有序排队，但是sendMessageAtFrontOfQueue就是那种个别不老实的，它能直接插队到最前面，然后他传递的uptimeMillis为0，这也是唯一一个特殊的发送消息的方法。 这个判断语句成立的条件有三点：p == null || when == 0 || when &lt; p.when p == null说明当前looper处于空闲状态，也就是没有什么消息需要处理 when == 0说明有消息插队插到了MessageQueue最前面 when &lt; p.when指的是新入队的消息队列需要排队的时间比正在执行的消息排队的时间短 综合来说就是，如果这时候新进来一个消息，这时候消息队列里面没有需要执行的消息，或者新进来的这个消息是通过sendMessageAtFrontOfQueue(Message msg)方法传进来的，或者说新进来的这个消息需要等待的时间比之前在等待的消息等待的时间短，那么就把这个消息插入链表的表头，此时系统会唤醒这个消息队列无论队列是否堵塞。 12// Got a message. mBlocked = false; 这一行代码说明只要消息队列有消息，这个队列就不阻塞，然后把这个布尔值传递： 12boolean needWakeneedWake = mBlocked; 那么这一块代码就打通了，下面这块else语句块： 12345678910111213141516171819else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; 讲的是如何把消息插入链表的内部，这时候就不需要去调整唤醒消息队列的时间，因为唤醒的时间是跟表头有关的，这样整个入队的操作差不多就过了一遍. 出队操作既然有入队操作那么肯定也有出队操作，如果你还记得我们最开始使用的Looper类的话，那么这里不妨直接告诉你，出队的方法就在Looper类里面，这里有个loop()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); //死循环 for (;;) &#123; //把消息从队列取出 Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 注意这两段代码： 12final Looper me = myLooper();final MessageQueue queue = me.mQueue; 之前说过一个线程必须有一个Looper，这里不仅获取到了Looper，还获取到了当前线程绑定的MessageQueue也就是消息队列，然后loop()方法最开始是判断当前线程是否有Looper对象，之后进入一个死循环，在循环体内不断的从消息队列(Message queue)中取出消息对象，为什么这么说，看这个next()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Message next()&#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; . . . . . . nativePollOnce(mPtr, nextPollTimeoutMillis); // 阻塞于此 . . . . . . // 获取next消息，如能得到就返回之。 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; // 先尝试拿消息队列里当前第一个消息 if (msg != null &amp;&amp; msg.target == null) &#123; // 如果从队列里拿到的msg是个“同步分割栏”，那么就寻找其后第一个“异步消息” do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; // 重新设置一下消息队列的头部 &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); msg.markInUse(); return msg; // 返回得到的消息对象 &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; . . . . . . // 处理idle handlers部分 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; &#125;&#125; 注释已经很详细了，现在知道了哪里把消息取出来，但是还不知道消息是哪里处理的，接着上面的loop()方法的代码往下看： 1msg.target.dispatchMessage(msg); 这一行很关键，字面意思都可以看出来这里是分发消息，找到源码查看一下，之前说过msg.target就是与Message绑定的Handler，所以在Handler的源码里面找： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 代码很简单，但是答案就快揭晓了，Handler通过post和sendMessage之类的方法把消息发出去，绕了一大圈又回到了Handler，先别激动，看看代码到底说了什么： 12if (msg.callback != null) &#123; handleCallback(msg); 这里的msg.callback其实就是一个Runnable对象，可以通过查看Message源码发现： 1234567891011121314/** * Same as &#123;@link #obtain(Handler)&#125;, but assigns a callback Runnable on * the Message that is returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @param callback Runnable that will execute when the message is handled. * @return A Message object from the global pool. */ public static Message obtain(Handler h, Runnable callback) &#123; Message m = obtain(); m.target = h; //创建Message类时候系统建议使用Message msg=Message.obtain()；形式 m.callback = callback; return m; &#125; 你想到了什么，在回想一遍我们使用Handler的两种方式，一种是post(Runnable r)的形式，一种是sendMessage(Message msg)形式，第一种方式刚好传递的就是一个Runnable对象，看一下这个handleCallback(msg)方法： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 简单粗暴，走的就是post(Runnable r) 所传递参数的 run()方法，那么第二种形式呢： 12345if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; 这个mCallback是Hanlder.Callback类对象，这个Callback是Handler的内部的一个接口： 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 这就对应了sendMessage(Message msg)的形式，到此，真相大白，这里还有一点要注意的是，ActivityThread也就是UI线程是自动调用了Looper.loop()方法的所以在主线程使用Handler是不需要再去调用了，但是在子线程中却是要自己调用的，否则不会进入MessageQueue，而且Handler不仅仅只有更新UI的作用，它是与所创建的线程所绑定的，所以可以使用它在主线程向子线程发送消息，反过来也一样，关于这点的使用详见 Android主线程.子线程通信（Thread+handler） 总结从最开始的使用到从源码的角度去分析，写这篇博客花了很长的时间，最后做个总结： 在整个Android内部通信进程中，Handler机制如果捋顺了相互之间的关系的话其实不难理解 套用一段很形象的话解释这幅图： 我们可以把传送带上的货物看做是一个个的Message，而承载这些货物的传送带就是装载Message的消息队列MessageQueue。传送带是靠发送机滚轮带动起来转动的，我们可以把发送机滚轮看做是Looper，而发动机的转动是需要电源的，我们可以把电源看做是线程Thread，所有的消息循环的一切操作都是基于某个线程的。一切准备就绪，我们只需要按下电源开关发动机就会转动起来，这个开关就是Looper的loop方法，当我们按下开关的时候，我们就相当于执行了Looper的loop方法，此时Looper就会驱动着消息队列循环起来。 那Hanlder在传送带模型中相当于什么呢？我们可以将Handler看做是放入货物以及取走货物的管道：货物从一端顺着管道划入传送带，货物又从另一端顺着管道划出传送带。我们在传送带的一端放入货物的操作就相当于我们调用了Handler的sendMessageXXX、sendEmptyMessageXXX或postXXX方法，这就把Message对象放入到了消息队列MessageQueue中了。当货物从传送带的另一端顺着管道划出时，我们就相当于调用了Hanlder的dispatchMessage方法，在该方法中我们完成对Message的处理。 这段话出自 参考博客 深入源码解析Android中的Handler,Message,MessageQueue,Looper 从Handler+Message+Looper源码带你分析Android系统的消息处理机制 Android异步消息处理机制完全解析，带你从源码的角度彻底理解 聊一聊Android的消息机制","tags":[{"name":"Android","slug":"Android","permalink":"https://www.limuyang.cc/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"https://www.limuyang.cc/tags/Handler/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.limuyang.cc/tags/源码分析/"}]},{"title":"Handler机制从入门到放弃(一)","date":"2016-10-29T22:41:23.000Z","path":"2016/10/29/Handler机制从入门到放弃-一/","text":"闲来无事，准备好好梳理一下Handler机制，之前分析过没有写成博客，结果就是慢慢的淡忘了，这次趁着刚分析完，赶紧写下来。 在开始分析之前先打打基础，理解理解什么是线程以及什么是Handler，这里大部分内容引用一篇来自伯乐在线的文章，因为看来看去关于基础的部分这个人已经说得很好了，我就负责把主要的部分抽取出来。 原文地址：Android线程和Handler基础入门 现在大多数的移动设备已经变得越来越快，但是它们其实也不算是非常快。如果你想让你的APP既可以承受一些繁杂的工作而又不影响用户体验的话，那么必须把任务并行执行。在Android上，我们使用线程。 什么是线程？线程或者线程执行本质上就是一串命令（也是程序代码），然后我们把它发送给操作系统执行。 一般来说，我们的CPU在任何时候一个核只能处理一个线程。多核处理器（目前大多数Android设备已经都是多核）顾名思义，就是可以同时处理多线程（通俗地讲就是可以同时处理多件事）。 多核处理与单核多任务处理的实质上面我说的是一般情况，并不是所有的描述都是一定正确的。因为单核也可以用多任务模拟出多线程。 每个运行在线程中的任务都可以分解成多条指令，而且这些指令不用同时执行。所以，单核设备可以首先切换到线程1去执行指令1A，然后切换到线程2去执行指令2A，接着返回到线程1再去执行1B、1C、1D，然后继续切换到线程2，执行2B、2C等等，以此类推。 这个线程之间的切换十分迅速，以至于在单核的设备中也会发生。几乎所有的线程都在相同的时间内进行任务处理。其实，这都是因为速度太快造成的假象，就像电影《黑客帝国》里的特工Brown一样，可以变幻出很多的头和手。 Java核心里的线程在Java中，如果要想做平行任务处理的话，会在Runnable里面执行你的代码。可以继承Thread类，或者实现Runnable接口： 1234567891011121314151617181920212223242526// 1public class IAmAThread extends Thread &#123; public IAmAThread() &#123; super(\"IAmAThread\"); &#125; @Override public void run() &#123;// your code (sequence of instructions) &#125;&#125;// to execute this sequence of instructions in a separate thread.new IAmAThread().start();// 2public class IAmARunnable implements Runnable &#123; @Override public void run() &#123;// your code (sequence of instructions) &#125;&#125;// to execute this sequence of instructions in a separate thread.IAmARunnable myRunnable = new IAmARunnable();new Thread(myRunnable).start(); 这两个方法基本上是一样的。第一个版本是创建一个Thread类，第二个版本是需要创建一个Runnable对象，然后也需要一个Thread类来调用它。 Android上的线程无论何时启动APP，所有的组件都会运行在一个单独的线程中（默认的）—-叫做主线程。这个线程主要用于处理UI的操作并为视图组件和小部件分发事件等，因此主线程也被称作UI线程(Main Thread)。除了Main Thread之外的线程都可称为Worker Thread。Main Thread主要负责控制UI页面的显示、更新、交互等。 因此所有在UI线程中的操作要求越短越好，只有这样用户才会觉得操作比较流畅。一个比较好的做法是把一些比较耗时的操作，例如网络请求、数据库操作、 复杂计算等逻辑都封装到单独的线程，这样就可以避免阻塞主线程，这样就需要用到了Android的Handler机制。 这里划重点：Handler负责与子线程进行通讯，从而让子线程与主线程之间建立起协作的桥梁，使Android的UI更新的问题得到完美的解决 怎么创建Handler既然Handler有这样的好处，那么看Handler怎么用，官方给出了两种方式创建一个Handler： 1、使用默认的构造方法：new Handler()。 2、使用带参的构造方法，参数是一个Runnable对象或者回调对象。 12345678910111213141516171819202122//第一种方法private Handler handler = new Handler(); private Runnable myRunnable= new Runnable() &#123; public void run() &#123; //一些耗时操作 &#125; &#125;; //其他地方调用 handler.post(xxx); 这里就写一个post方法，实际上还有很多，诸如postDelayed、postAtTime//第二种方法Handler myHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //根据参数进行操作 break; &#125; super.handleMessage(msg); &#125; &#125;; //其他地方调用myHandler.sendMessage(xxx); 如何使用Handler这里使用一个简单的Demo来演示Handler的用法，界面偏简单就不贴了，直接贴代码，模拟的是点击Button执行下载，下载完成后更新UI。 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends Activity implements Button.OnClickListener &#123; private TextView statusTextView = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); statusTextView = (TextView)findViewById(R.id.statusTextView); Button btnDownload = (Button)findViewById(R.id.btnDownload); btnDownload.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; DownloadThread downloadThread = new DownloadThread(); downloadThread.start(); &#125; class DownloadThread extends Thread&#123; @Override public void run() &#123; try&#123; System.out.println(\"开始下载文件\"); //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程 Thread.sleep(5000); System.out.println(\"文件下载完成\"); //文件下载完成后更新UI MainActivity.this.statusTextView.setText(\"文件下载完成\"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 按照以前写Java的思路的话可能会这么写，但是运行程序时候会发现控制台报错： 1android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 错误的意思是只有创建View的原始线程才能更新View。出现这样错误的原因是Android中的View不是线程安全的，下面给出合理的解释： 因为UI访问是没有加锁的，在多个线程中访问UI是不安全的，如果有多个子线程都去更新UI，会导致界面不断改变而混乱不堪。所以最好的解决办法就是只有一个线程有更新UI的权限，所以这个时候就只能有一个线程振臂高呼：放开那女孩，让我来！那么最合适的人选只能是主线程。 来自—Android中线程那些事 那么为了规避Android的这种机制，我们这里分别采用Handler的两种方式来实现上面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118A、使用post方式public class MainActivity extends Activity implements Button.OnClickListener &#123; private TextView statusTextView = null; //uiHandler在主线程中创建，所以自动绑定主线程 private Handler uiHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); statusTextView = (TextView)findViewById(R.id.statusTextView); Button btnDownload = (Button)findViewById(R.id.btnDownload); btnDownload.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; DownloadThread downloadThread = new DownloadThread(); downloadThread.start(); &#125; class DownloadThread extends Thread&#123; @Override public void run() &#123; try&#123; System.out.println(\"开始下载文件\"); //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程 Thread.sleep(5000); System.out.println(\"文件下载完成\"); //文件下载完成后更新UI Runnable runnable = new Runnable() &#123; @Override public void run() &#123; MainActivity.this.statusTextView.setText(\"文件下载完成\"); &#125; &#125;; uiHandler.post(runnable); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;B、使用sendMessage方式实现public class MainActivity extends Activity implements Button.OnClickListener &#123; private TextView statusTextView = null; //uiHandler在主线程中创建，所以自动绑定主线程 private Handler uiHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 1: System.out.println(\"msg.arg1:\" + msg.arg1); System.out.println(\"msg.arg2:\" + msg.arg2); MainActivity.this.statusTextView.setText(\"文件下载完成\"); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); statusTextView = (TextView)findViewById(R.id.statusTextView); Button btnDownload = (Button)findViewById(R.id.btnDownload); btnDownload.setOnClickListener(this); System.out.println(\"Main thread id \" + Thread.currentThread().getId()); &#125; @Override public void onClick(View v) &#123; DownloadThread downloadThread = new DownloadThread(); downloadThread.start(); &#125; class DownloadThread extends Thread&#123; @Override public void run() &#123; try&#123; System.out.println(\"开始下载文件\"); //此处让线程DownloadThread休眠5秒中，模拟文件的耗时过程 Thread.sleep(5000); System.out.println(\"文件下载完成\"); //文件下载完成后更新UI Message msg = new Message(); //虽然Message的构造函数式public的，我们也可以通过以下两种方式通过循环对象获取Message //msg = Message.obtain(uiHandler); //msg = uiHandler.obtainMessage(); //what是我们自定义的一个Message的识别码，以便于在Handler的handleMessage方法中根据what识别 //出不同的Message，以便我们做出不同的处理操作 msg.what = 1; //我们可以通过arg1和arg2给Message传入简单的数据 msg.arg1 = 123; msg.arg2 = 321; //我们也可以通过给obj赋值Object类型传递向Message传入任意数据 //msg.obj = null; //我们还可以通过setData方法和getData方法向Message中写入和读取Bundle类型的数据 //msg.setData(null); //Bundle data = msg.getData(); //将该Message发送给对应的Handler uiHandler.sendMessage(msg); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 以上代码来自博客：Android中Handler的使用 上面这两种形式都能达到我们的要求，在此不一一测验，注释写的很详细了，看到这里应该已经大致知道了如何使用Handler，但是我想我们应该远远不满足于此，下一篇博客将带着大家从源码一起看看Handler机制到底是怎么实现的。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.limuyang.cc/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"https://www.limuyang.cc/tags/Handler/"}]},{"title":"人生苦短，我用Python--分分钟下载知乎美图给你看","date":"2016-08-11T19:45:46.000Z","path":"2016/08/11/人生苦短，我用Python-分分钟下载知乎美图给你看/","text":"起上次说了要爬知乎的图片，于是花了一下午的时间去完成这件事，发现暂时接触到的爬虫总是逃脱不了一个规律： 模拟登陆 获取真实网页HTML源代码 解析获取到的网页源代码 获取想要的资源(下载到某个文件夹或者输出到表格中整合起来) 也许和我说的有一些出入，应该是刚学这个东西的原因，接下来还想研究一下多线程爬虫、添加代理、爬取海量数据并整合成图表形式，先把能做的做了。 承因为是在上一次的基础上进行的，所以没有看上一篇文章的可以先看一下，这里用到的工具跟之前一样： win7 64位 旗舰版 Python 3.5 64-bit PyCharm 这里模拟登陆是跟之前一样的代码，直接贴就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576logn_url = 'http://www.zhihu.com/#signin'session = requests.session()headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36',&#125;content = session.get(logn_url, headers=headers).contentsoup = BeautifulSoup(content, 'html.parser')def getxsrf(): return soup.find('input', attrs=&#123;'name': \"_xsrf\"&#125;)['value'] # 获取验证码def get_captcha(): t = str(int(time.time() * 1000)) captcha_url = 'http://www.zhihu.com/captcha.gif?r=' + t + \"&amp;type=login\" r = session.get(captcha_url, headers=headers) with open('captcha.jpg', 'wb') as f: f.write(r.content) f.close() # 用pillow 的 Image 显示验证码 # 如果没有安装 pillow 到源代码所在的目录去找到验证码然后手动输入 try: im = Image.open('captcha.jpg') im.show() im.close() except: print(u'请到 %s 目录找到captcha.jpg 手动输入' % os.path.abspath('captcha.jpg')) captcha = input(\"please input the captcha\\n&gt;\") return captchadef isLogin(): # 通过查看用户个人信息来判断是否已经登录 url = \"https://www.zhihu.com/settings/profile\" login_code = session.get(url, allow_redirects=False).status_code if int(x=login_code) == 200: return True else: return Falsedef login(secret, account): # 通过输入的用户名判断是否是手机号 if re.match(r\"^1\\d&#123;10&#125;$\", account): print(\"手机号登录 \\n\") post_url = 'http://www.zhihu.com/login/phone_num' postdata = &#123; '_xsrf': getxsrf(), 'password': secret, 'remember_me': 'true', 'phone_num': account, &#125; else: print(\"邮箱登录 \\n\") post_url = 'http://www.zhihu.com/login/email' postdata = &#123; '_xsrf': getxsrf(), 'password': secret, 'remember_me': 'true', 'email': account, &#125; try: # 不需要验证码直接登录成功 login_page = session.post(post_url, data=postdata, headers=headers) login_code = login_page.text print(login_page.status) print(login_code) except: # 需要输入验证码后才能登录成功 postdata[\"captcha\"] = get_captcha() login_page = session.post(post_url, data=postdata, headers=headers) login_code = eval(login_page.text) print(login_code['msg']) 这里的代码来自GitHub上的fuck-login项目，在此表示感谢，我在原始代码上进行了改进，原始代码是适配了Python2.x和Python3.x，但是我学的是Python3.x所以去掉了一些我没用过的模块，也就是说我改进了后的代码是适用于Python3.x的。 下面就是准备获取图片了，先找一个目标，最近有一个问题很火： 长得好看，但没有男朋友是怎样的体验 还记得我列出来的步骤么，模拟登陆之后是获取真实的网页源代码，什么叫真实的，这个问题问得好，你没发现知乎很喜欢用动态加载技术么，也就是说，你看到的只是表象，这里也一样。 转 来，我们先点开点赞数最高的妹子上传的图片： 咳咳咳，好像跑偏了，我们的目标是星辰大海，正确的做法是鼠标右键查看网页源代码： 是不是看到了很多图片链接，当然我们要找.jpg、.jpeg、.png后缀的： 1&lt;img data-rawwidth=\"1632\" data-rawheight=\"2040\" src=\"//zhstatic.zhihu.com/assets/zhihu/ztext/whitedot.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1632\" data-original=\"https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_b.jpg\"&gt; 这里有两个：data-original和data-actualsrc，实际查看的图片是data-original的图片比data-actualsrc的大，下载下来也是如此，但是因为是使用正则去匹配规则，而data-original有多项，上面代码只是贴出来的一部分，实际匹配的结果类似这样： data-actualsrc12data-actualsrc=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_b.jpg&quot;&gt;data-actualsrc=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_b.jpg&quot;&gt; data-original 12345data-original=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_r.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/be7600989233bdf438e5ba23f2cdb685_b.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_r.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/b6274542f3785c27ab4a38d4db906efd_b.jpg&quot;&gt;data-original=&quot;https://pic2.zhimg.com/0930549116d22ffce22e98c32683d621_r.jpg&quot;&gt; 这是在同一段网页源码测试下的结果，匹配后一种会得到多个相同的url地址，解析起来也更麻烦，这也跟正则写的简单有关系，有兴趣的可以到时候自己修改一下正则表达式，这样下下来的图片也更高清的多。 分析了正则，下面要获取所有的图片该分析Chrome开发者面板的Post数据，因为知乎默认只显示部分回答，我们可以不断往下拉，直到看到这个： 点击的时候注意观察开发者面板： 简直完美，传递的数据： 12method:nextparams:&#123;&quot;url_token&quot;:37709992,&quot;pagesize&quot;:10,&quot;offset&quot;:30&#125; 很眼熟，url_token就是问题后面那串数字： 1https://www.zhihu.com/question/37709992 pagesize是固定的10，最后一个offset偏移量同样很好理解，这里显示10应该说的就是默认显示的10个答案，后面还查看到如下数据：12method:nextparams:&#123;&quot;url_token&quot;:37709992,&quot;pagesize&quot;:10,&quot;offset&quot;:20&#125; 12method:nextparams:&#123;&quot;url_token&quot;:37709992,&quot;pagesize&quot;:10,&quot;offset&quot;:30&#125; 也就是说我们在浏览器上每翻过10个答案浏览器就会向服务器发送Post请求在加载十个答案，恩差不多可以开始写代码了。 合模拟登陆之后的操作是找到Post的真实地址模拟浏览器向服务器发送请求： 1234567891011121314url = 'https://www.zhihu.com/node/QuestionAnswerListV2'header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Referer': 'https://www.zhihu.com/question/37709992', 'Origin': 'https://www.zhihu.com', 'Accept-Encoding': 'gzip, deflate, br',&#125;data = &#123; 'method': 'next', 'params': '&#123;\"url_token\":' + str(37709992) + ',\"pagesize\": \"10\",' + \\ '\"offset\":' + str(offset) + \"&#125;\", '_xsrf': getxsrf(),&#125; 注意 发送Post请求时候请加上&#39;_xsrf&#39;: getxsrf()这一行，否则的话返回的只会是404 Forbidden，应该是做了防伪登陆的缘故 然后是写正则，这里发现图片都是被包含在这里面： 1234&lt;div class=\"zm-editable-content clearfix\"&gt;......&lt;/div&gt; 所以先匹配到这一大串内容： 12pattern = re.compile('&lt;a class=\"author-link\".*?&lt;span title=.*?&lt;div class=\"zh-summary.*?' + '&lt;div class=\"zm-editable-content.*?&gt;(.*?)&lt;/div&gt;', re.S) 然后在匹配data-actualsrc里面的图片链接： 1pattern = re.compile('data-actualsrc=\"(.*?)\"&gt;', re.S) 还有一点要注意的是我们请求之后返回来的是json格式的数据，所以这里还要用到json模块： 123question = session.post(url, headers=header, data=data)dic = json.loads(question.content.decode('ISO-8859-1'))li = dic['msg'][0] 然后对其进行解析： 12345678910# 这里使用的是第一个正则表达式items = re.findall(pattern, li)# 接下来items = re.findall(pattern, li)# 存储图片链接imagesurl = []pattern = re.compile('data-actualsrc=\"(.*?)\"&gt;', re.S)for item in items: urls = re.findall(pattern, item) imagesurl.extend(urls) 执行下载操作： 123456789101112131415161718192021222324252627282930# 存放图片的地址PWD = \"D:/work/python/zhihu/\" for url in imagesurl: myurl = url filename = PWD + str(count) + '.jpg' if os.path.isfile(filename): print(\"文件存在：\", filename) count += 1 continue else: # 执行下载操作的方法 downpic(filename, myurl) count += 1 photoNum += 1 print(\"一共下载了&#123;0&#125; 张照片\".format(photoNum)) if not os.path.exists(PWD): os.makedirs(PWD) # 递归调用 change(offset, count, photoNum)# downpic方法源码def downpic(filename, url): print(\"正在下载 \" + url) try: r = requests.get(url, stream=True) with open(filename, 'wb') as fd: for chunk in r.iter_content(): fd.write(chunk) except Exception as e: print(\"下载失败了\", e) 运行结果 这只是一部分，我之前下了四五百张还在下~当然这是后话，感觉现在写的东西都很简单，希望下一次能写出难一点的东西出来。 这里正则部分参考了这里： 通过Python爬虫爬取知乎某个问题下的图片 最后是源码 源码中注释部分只能下载前十个答案里包含的图片的方法，还有一些想法未完成，本来是想打印一下正在下载哪个答主的回答，然后把图片分别保存到相应的单独文件夹，实现起来有点麻烦就没去搞，仅供参考。 亲测如果需要下载另一个问题的答案，只需要在:1234567data = &#123; &apos;method&apos;: &apos;next&apos;, &apos;params&apos;: &apos;&#123;&quot;url_token&quot;:&apos; + str(37709992) + &apos;,&quot;pagesize&quot;: &quot;10&quot;,&apos; + \\ &apos;&quot;offset&quot;:&apos; + str(offset) + &quot;&#125;&quot;, &apos;_xsrf&apos;: getxsrf(), &#125; 更换那串数字就行，就好比这样的形式： https://www.zhihu.com/question/48720845 但是这种形式的把数字换上去不起效： https://www.zhihu.com/question/49078894#answer-41776282 这个好像是知乎热门问答的链接形式，暂时没有深究","tags":[{"name":"知乎","slug":"知乎","permalink":"https://www.limuyang.cc/tags/知乎/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.limuyang.cc/tags/爬虫/"},{"name":"数据采集","slug":"数据采集","permalink":"https://www.limuyang.cc/tags/数据采集/"}]},{"title":"人生苦短，我用Python--一起来爬知乎娘","date":"2016-08-09T19:14:46.000Z","path":"2016/08/09/人生苦短，我用Python-一起来爬知乎娘/","text":"上次爬了教务处的成绩，接下来想去爬一爬知乎娘，好像大家都很喜欢爬知乎娘，GitHub上貌似已经有人把获取各种知乎数据的操作封装好了：zhihu-python ，但是良辰表示还是想自己试一试，我就爬点简单的，难度大的我也不会，我瞄准的是我自己关注的人的数据，差不多就这些东西： 关注者 / 提问 / 回答 / 赞同 那么下面开始分析，要拿到这个数据肯定是要先登陆的，那么先找到登陆界面： 这算是比较正常的界面，不知道为什么有的时候会出现新的验证码形式： 这种形式登陆的话我看传递的表单数据是你鼠标点击的坐标，这种情况暂时不知道怎么办，留给高手，我们分析上面那种，知乎登陆分为手机号登陆或者邮箱登陆，先试试邮箱登陆，查看Post数据： 然后是手机号登陆的: 现在理一下思路，我们要登录知乎要传递的数据如下： _xsrf() 用于防伪登陆 password captcha 验证码 phone_num/email 不同登陆方式传递的东西不同 phone_num/email以及passsword都需要自己输入，这个好办，我们需要解决如何获取 _xsrf和captcha 的问题，先解决 _xsrf，这个更简单一点，我们在知乎登陆页面 右键查看网页源代码，直接搜_xsrf： 1234&lt;div class=\"view view-signin\" data-za-module=\"SignInForm\"&gt;&lt;form&gt;&lt;input type=\"hidden\" name=\"_xsrf\" value=\"cf1ee28f15cea5dba3243a1c31a1b284\"/&gt;&lt;div class=\"group-inputs\"&gt; 我们要做的就是解析出这个元素，直接上代码： 12345678910logn_url = 'http://www.zhihu.com/#signin'session = requests.session()headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36',&#125;content = session.get(logn_url, headers=headers).contentsoup = BeautifulSoup(content, 'html.parser')def getxsrf(): return soup.find('input', attrs=&#123;'name': \"_xsrf\"&#125;)['value'] 下面获取验证码， 我发现无论是使用哪一种登陆方式，Chrome的开发者面板都会有这么一行： 当我把这个Request URL输入浏览器中就会转到这个验证码图片的界面，说明这个验证码是我们加载这个页面时候，浏览器向服务器发出请求然后下载下来的，那么现在我们有了URL地址： 这还是一个GET请求，这里注意这个传递的r参数是会不断变化的，这是一个当前Unix的时间戳，知道了这些可以着手获取验证码然后让用户自己输入： 12345678910111213141516171819202122try: from PIL import Imageexcept: pass# 获取验证码def get_captcha(): t = str(int(time.time() * 1000)) captcha_url = 'http://www.zhihu.com/captcha.gif?r=' + t + \"&amp;type=login\" r = session.get(captcha_url, headers=headers) with open('captcha.jpg', 'wb') as f: f.write(r.content) f.close() # 用pillow 的 Image 显示验证码 # 如果没有安装 pillow 到源代码所在的目录去找到验证码然后手动输入 try: im = Image.open('captcha.jpg') im.show() im.close() except: print(u'请到 %s 目录找到captcha.jpg 手动输入' % os.path.abspath('captcha.jpg')) captcha = input(\"please input the captcha\\n&gt;\") return captcha 这里获取验证码的代码来自GitHub上的fuck-login项目，在此表示感谢，接下里就是写一个方法判断用户是使用了哪一种登陆方式，然后传递相应的数据： 12345678910111213141516171819202122232425262728293031323334def login(secret, account): # 通过输入的用户名判断是否是手机号 if re.match(r&quot;^1\\d&#123;10&#125;$&quot;, account): print(&quot;手机号登录 \\n&quot;) post_url = &apos;http://www.zhihu.com/login/phone_num&apos; postdata = &#123; &apos;_xsrf&apos;: getxsrf(), &apos;password&apos;: secret, &apos;remember_me&apos;: &apos;true&apos;, &apos;phone_num&apos;: account, &#125; else: print(&quot;邮箱登录 \\n&quot;) post_url = &apos;http://www.zhihu.com/login/email&apos; postdata = &#123; &apos;_xsrf&apos;: getxsrf(), &apos;password&apos;: secret, &apos;remember_me&apos;: &apos;true&apos;, &apos;email&apos;: account, &#125; try: # 不需要验证码直接登录成功 login_page = session.post(post_url, data=postdata, headers=headers) login_code = login_page.text print(login_page.status) print(login_code) except: # 需要输入验证码后才能登录成功 postdata[&quot;captcha&quot;] = get_captcha() login_page = session.post(post_url, data=postdata, headers=headers) login_code = eval(login_page.text) print(login_code[&apos;msg&apos;])# 这部分代码同样来自[**fuck-login**](https://github.com/xchaoinfo/fuck-login)项目,我偷了很多懒,囧 这个时候判断是否登陆成功可以随便查看一个页面发送GET请求看是否返回200，这里就不多说，接下来才是关键，为了获取我关注的人的信息，先打开开发者面板，这个地方打钩： 因为网页有时候会跳转，这里打钩之后新跳转的页面的信息就不会覆盖之前接受到的信息，然后找到我关注的人，URL地址是： https://www.zhihu.com/people/GitSmile/followees 最开始我走了弯路，我以为直接在这个页面解析出我关注的人的信息就行，所以一开始我是这么做的，查看网页源代码，这里随便找一个我关注的人的信息： 1234567891011121314151617181920212223&lt;a title=\"死者代言人\"data-hovercard=\"p$t$forensic\"class=\"zm-item-link-avatar\"href=\"/people/forensic\"&gt;&lt;img src=\"https://pic1.zhimg.com/be39d110759e68f389b7d2934d7353bc_m.jpg\" class=\"zm-item-img-avatar\"&gt;&lt;/a&gt;&lt;div class=\"zm-list-content-medium\"&gt;&lt;h2 class=\"zm-list-content-title\"&gt;&lt;a data-hovercard=\"p$t$forensic\" href=\"https://www.zhihu.com/people/forensic\" class=\"zg-link author-link\" title=\"死者代言人\"&gt;死者代言人&lt;/a&gt;&lt;span class=\"icon icon-badge-best_answerer icon-badge\" data-tooltip=\"s$b$优秀回答者\"&gt;&lt;/span&gt;&lt;/h2&gt;&lt;div class=\"ellipsis\"&gt;&lt;span class=\"badge-summary\"&gt;优秀回答者&lt;/span&gt;&lt;span class=\"bio\"&gt;不养喵的爱喵法医。&lt;/span&gt;&lt;/div&gt;&lt;div class=\"details zg-gray\"&gt;&lt;a target=\"_blank\" href=\"/people/forensic/followers\" class=\"zg-link-gray-normal\"&gt;35968 关注者&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/forensic/asks\" class=\"zg-link-gray-normal\"&gt;2 提问&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/forensic/answers\" class=\"zg-link-gray-normal\"&gt;305 回答&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/forensic\" class=\"zg-link-gray-normal\"&gt;51278 赞同&lt;/a&gt;&lt;/div&gt; 然后在对比另一条： 1234567891011121314151617181920212223&lt;a title=\"陈亦飘\"data-hovercard=\"p$t$chen-yi-piao\"class=\"zm-item-link-avatar\"href=\"/people/chen-yi-piao\"&gt;&lt;img src=\"https://pic2.zhimg.com/d495751efbf837b1b5b08571add7df3d_m.jpg\" class=\"zm-item-img-avatar\"&gt;&lt;/a&gt;&lt;div class=\"zm-list-content-medium\"&gt;&lt;h2 class=\"zm-list-content-title\"&gt;&lt;a data-hovercard=\"p$t$chen-yi-piao\" href=\"https://www.zhihu.com/people/chen-yi-piao\" class=\"zg-link author-link\" title=\"陈亦飘\"&gt;陈亦飘&lt;/a&gt;&lt;/h2&gt;&lt;div class=\"ellipsis\"&gt;&lt;span class=\"bio\"&gt;音乐和电影是我的爱与慈悲&lt;/span&gt;&lt;/div&gt;&lt;div class=\"details zg-gray\"&gt;&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/followers\" class=\"zg-link-gray-normal\"&gt;74469 关注者&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/asks\" class=\"zg-link-gray-normal\"&gt;0 提问&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/answers\" class=\"zg-link-gray-normal\"&gt;80 回答&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao\" class=\"zg-link-gray-normal\"&gt;315971 赞同&lt;/a&gt;&lt;/div&gt; 要分解出这些元素，只要找出他们的共同点，当时机智如我一眼就发现每一个我关注的人的名字都有这么一行元素： 1class=&quot;zm-item-link-avatar&quot; 而且都包含在一个&lt;a&gt;&lt;/a&gt;标签里面，这就好办了，使用BeautifulSoup先分解出每一个我关注的人的名字： 123456789101112def getdetial(): followees_url = &apos;https://www.zhihu.com/people/GitSmile/followees&apos; followees_headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36&apos;, &apos;Referer&apos;: &apos;https://www.zhihu.com/people/GitSmile/about&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch, br&apos; &#125; myfollowees = session.get(followees_url, headers=followees_headers) mysoup = BeautifulSoup(myfollowees.content, &apos;html.parser&apos;) print(mysoup.find(&apos;span&apos;, attrs=&#123;&apos;class&apos;: &apos;zm-profile-section-name&apos;&#125;).text) 然后继续观察，突破点依然在这个&lt;a&gt;&lt;/a&gt;标签，拿”陈亦飘”的信息做个例子，看官们看这里面是不是有个href=&quot;/people/chen-yi-piao，然后看一下她的相关信息： 1234567&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/followers\" class=\"zg-link-gray-normal\"&gt;74469 关注者&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/asks\" class=\"zg-link-gray-normal\"&gt;0 提问&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao/answers\" class=\"zg-link-gray-normal\"&gt;80 回答&lt;/a&gt;/&lt;a target=\"_blank\" href=\"/people/chen-yi-piao\" class=\"zg-link-gray-normal\"&gt;315971 赞同&lt;/a&gt; 发现没有，每一个信息里面的href元素都是我们最开始看到的/people/chen-yi-piao元素加上一些字符串组成的，那么我就可以在这上面做点文章： 12345678910111213141516171819202122232425获取详细信息def getdetial(): followees_url = 'https://www.zhihu.com/people/GitSmile/followees' followees_headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Referer': 'https://www.zhihu.com/people/GitSmile/about', 'Upgrade-Insecure-Requests': '1', 'Accept-Encoding': 'gzip, deflate, sdch, br' &#125; myfollowees = session.get(followees_url, headers=followees_headers) mysoup = BeautifulSoup(myfollowees.content, 'html.parser') print(mysoup.find('span', attrs=&#123;'class': 'zm-profile-section-name'&#125;).text) for result in mysoup.findAll('a', attrs=&#123;'class': 'zm-item-link-avatar'&#125;): print(result.get('title')) # 解析出href元素信息 href = str(result.get('href')) # 关注者 print(mysoup.find('a', attrs=&#123;'href': href + '/followers'&#125;).text) # 提问 print(mysoup.find('a', attrs=&#123;'href': href + '/asks'&#125;).text) # 回答 print(mysoup.find('a', attrs=&#123;'href': href + '/answers'&#125;).text) # 赞同 print(mysoup.find('a', attrs=&#123;'href': href, 'class': 'zg-link-gray-normal'&#125;).text + '\\n') 上面的代码应该很简单了，看一看就能看懂，然后就我信心满满地在PyCharm上输出的时候，发现来来回回只输出20条信息，也就是说，我关注了26人，但是控制台只输出了20个人的信息，然后我就上网查，发现不止一个人有我这样的疑问，当然也多亏了前人踩坑，网上给出来的答案是知乎获取关注的人的时候使用了AJAX技术，也就是动态加载，但是这一部分代码不会再网页Html代码中显示出来，所以为了获取其他关注的人的信息我这里要另辟蹊径。 然后我翻看我关注的人的信息的时候，在开发者面板抓到这么一条POST信息： 这条POST之后下面刷出来的图片是我关注的人的头像并且这些头像在我之前看到的20条数据里面是没有的，加上我总共就关注了27个人，所以我有理由相信这个Post就是浏览器向服务器发送请求的Post，看一下Post的信息： 一个偏移量(offset)，一个哈希值(hash_id)外加一个”order_by”:”created”的键值对，这里偏移量很好理解，这个”hash_id”据我多次登陆发现是一个不变的值，或者说每一台电脑或许精确一点每一个浏览器都会有这么一个给定的值，照抄，那么改进后的代码如下： 123456789101112131415161718192021222324252627282930313233343536# 获取所有关注的人的信息def getallview(): nums = 27 # 这个是我关注的人数 followees_headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36&apos;, &apos;Referer&apos;: &apos;https://www.zhihu.com/people/GitSmile/followees&apos;, &apos;Origin&apos;: &apos;https://www.zhihu.com&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;, &apos;CG - Sid&apos;: &apos;57226ad5 - 793b - 4a9d - 9791 - 2a9a17e682ef&apos;, &apos;Accept&apos;: &apos;* / *&apos; &#125; # 序号 count = 0 for index in range(0, nums): fo_url = &apos;https://www.zhihu.com/node/ProfileFolloweesListV2&apos; m_data = &#123; &apos;method&apos;: &apos;next&apos;, &apos;params&apos;: &apos;&#123;&quot;offset&quot;:&apos; + str( index) + &apos;,&quot;order_by&quot;:&quot;created&quot;,&quot;hash_id&quot;:&quot;de2cb64bc1afe59cf8a6e456ee5eaebc&quot;&#125;&apos;, &apos;_xsrf&apos;: str(getxsrf()) &#125; result = session.post(fo_url, data=m_data, headers=followees_headers) dic = json.loads(result.content.decode(&apos;utf-8&apos;)) li = dic[&apos;msg&apos;][0] mysoup = BeautifulSoup(li, &apos;html.parser&apos;) for result in mysoup.findAll(&apos;a&apos;, attrs=&#123;&apos;class&apos;: &apos;zm-item-link-avatar&apos;&#125;): print(index + 1) print(result.get(&apos;title&apos;)) href = str(result.get(&apos;href&apos;)) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href + &apos;/followers&apos;&#125;).text) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href + &apos;/asks&apos;&#125;).text) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href + &apos;/answers&apos;&#125;).text) print(mysoup.find(&apos;a&apos;, attrs=&#123;&apos;href&apos;: href, &apos;class&apos;: &apos;zg-link-gray-normal&apos;&#125;).text + &apos;\\n&apos;) count += 1 print(&apos;一共关注了 %d人&apos; % count) 放上程序的入口： 123456789if __name__ == &apos;__main__&apos;: if isLogin(): print(&apos;您已经登录&apos;) else: account = input(&apos;请输入你的用户名\\n&gt; &apos;) secret = input(&quot;请输入你的密码\\n&gt; &quot;) login(secret, account) getallview() 看一下实际效果： 写在结尾 虽然简单，但是提供了一些初学者的思路，下一次准备爬一些知乎上的图片，好像很多人都热衷于这种事，嘻嘻，荆轲刺秦王。 源码","tags":[{"name":"知乎","slug":"知乎","permalink":"https://www.limuyang.cc/tags/知乎/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.limuyang.cc/tags/爬虫/"},{"name":"网络","slug":"网络","permalink":"https://www.limuyang.cc/tags/网络/"}]},{"title":"人生苦短，我用Python--爬虫模拟登陆教务处并且保存数据到本地","date":"2016-08-04T19:26:46.000Z","path":"2016/08/04/人生苦短，我用Python-爬虫模拟登陆教务处并且保存数据到本地/","text":"刚开始接触Python，看很多人玩爬虫我也想玩，找来找去发现很多人用网络爬虫干的第一件事就是模拟登陆，增加点难度就是模拟登陆后在获取数据，但是网上好少有Python 3.x的模拟登陆Demo可以参考，加上自己也不怎么懂HTML，所以这第一个Python爬虫写的异常艰难，不过最终结果还是尽如人意的，下面把这次学习的过程整理一下。工具 系统：win7 64位系统 浏览器：Chrome Python版本：Python 3.5 64-bit IDE：JetBrains PyCharm (貌似很多人都用这个) 我把目标瞄准了我们的教务处，这次爬虫的目的是从教务处获取成绩并且把成绩输入Excel表格中保存起来， 我们学校教务处的地址是：http://jwc.ecjtu.jx.cn/ ，往常每次我们获取成绩都需要先进入教务处，然后点击成绩查询，输入公共的账号密码进入，最后输入相关信息获取成绩表格，这里登陆不需要验证码省了我一番功夫，这样我们先进入成绩查询系统登陆界面，先看看怎么模拟登陆这个过程，在Chrome浏览器下按F12打开开发者面板： 这里我们学校的教务处查询系统的密码是公共的jwc也就是拼音缩写，我们输入用户名和密码点击登陆，这时候注意POST请求： 发现了什么，好像Chrome并没有把Post提交的表单信息保留下来直接跳转到了另一个界面然后展示另一个界面的数据，这里就需要我们自己动手操作一下，注意开发者面板左上角的小红点表示这时候正在抓取数据，如果点击一下就会变成灰色，就可以变相地保存下当时抓取到的包，我在点击登陆后新界面未刷新出来之前点击了这个小红点，如愿以偿的得到了Post的表单数据： 这样就获取了浏览器在登陆时候向服务器传递的表单数据，看一下这个表单都有些什么： 这里看到我们需要传递三个参数，分别是：user、pass、Submit，可以很容易的理解这几个单词的字面意思，这样有了思路，我们就可以写出这次代码的第一步：模拟登陆教务处 直接上代码: 1234567891011121314151617#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsurl = 'http://jwc.ecjtu.jx.cn/mis_o/login.php'datas = &#123;'user': 'jwc', 'pass': 'jwc', 'Submit': '%CC%E1%BD%BB' &#125;headers = &#123;'Referer': 'http://jwc.ecjtu.jx.cn/mis_o/login.htm', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 ' '(KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8', &#125;sessions = requests.session()response = sessions.post(url, headers=headers, data=datas)print(response.status_code) 代码输出： 1200 说明我们模拟登陆成功了，这里用到了Requests模块，还不会使用的可以查看中文文档 ，它给自己的定义是：HTTP for Humans，因为简单易用易上手，我们只需要传入Url地址，构造请求头，传入post方法需要的数据，就可以模拟浏览器登陆了，这里因为有进一步获取成绩的操作所以使用了session来保持连接，这里单看最后的返回码的话我们是成功了的，具体如何还要看下一步操作，接下来： 这里为了简便代码我们设定输入学号查询所有成绩，减少其他判断，同样对Post数据进行抓包： 同样查看Post的数据： 因为这里就分析输入学号的情况所以其他都为空，这样我们就可以写出查询成绩的代码： 1234567891011121314151617181920212223score_healders = &#123;'Connection': 'keep-alive', 'User - Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) ' 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36', 'Content - Type': 'application / x - www - form - urlencoded', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Content - Length': '69', 'Host': 'jwc.ecjtu.jx.cn', 'Referer': 'http: // jwc.ecjtu.jx.cn / mis_o / main.php', 'Upgrade - Insecure - Requests': '1', 'Accept - Language': 'zh - CN, zh;q = 0.8' &#125;score_url = 'http://jwc.ecjtu.jx.cn/mis_o/query.php?start=' + str( pagenum) + '&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=' + numscore_data = &#123;'Name': '', 'StuID': num, 'Course': '', 'Term': '', 'ClassID': '', 'Submit': '%B2%E9%D1%AF' &#125;score_response = sessions.post(score_url, data=score_data, headers=score_healders)content = score_response.content 这里解释一下上面的代码，上面的score_url 并不是浏览器上显示的地址，我们要获取真正的地址，在Chrome下右键–查看网页源代码，找到这么一行： 1a href=query.php?start=1&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=xxxxxxx 这个才是真正的地址，点击这个地址转入的才是真正的界面，因为这里成绩数据较多，所以这里采用了分页显示，这个start=1说明是第一页，这个参数是可变的需要我们传入，还有StuID后面的是我们输入的学号，这样我们就可以拼接出Url地址： 1score_url = &apos;http://jwc.ecjtu.jx.cn/mis_o/query.php?start=&apos; + str(pagenum) + &apos;&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=&apos; + num 同样使用Post方法传递数据并获取响应的内容： 12score_response = sessions.post(score_url, data=score_data,headers=score_healders)content = score_response.content 这里采用Beautiful Soup 4.2.0来解析返回的响应内容，因为我们要获取的是成绩，这里到教务处成绩查询界面，查看获取到的成绩在网页中是以表格的形式存在： 观察表格的网页源代码： 12345678910111213&lt;table align=center border=1&gt;&lt;tr&gt;&lt;td bgcolor=009999&gt;学期&lt;/td&gt;&lt;td bgcolor=009999&gt;学号&lt;/td&gt;&lt;td bgcolor=009999&gt;姓名&lt;/td&gt;&lt;td bgcolor=009999&gt;课程&lt;/td&gt;&lt;td bgcolor=009999&gt;课程要求&lt;/td&gt;&lt;td bgcolor=009999&gt;学分&lt;/td&gt;&lt;td bgcolor=009999&gt;成绩&lt;/td&gt;&lt;td bgcolor=009999&gt;重考一&lt;/td&gt;&lt;td bgcolor=009999&gt;重考二&lt;/td&gt;&lt;/tr&gt;......&lt;/tr&gt;&lt;/table&gt; 这里拿出第一行举例，虽然我不太懂Html但是从这里可以看出来&lt;tr&gt; 代表的是一行，而&lt;td&gt;应该是代表这一行中的每一列，这样就好办了，取出每一行然后分解出每一列，打印输出就可以得到我们要的结果： 1234from bs4 import BeautifulSoupsoup = BeautifulSoup(content, 'html.parser')# 找到每一行target = soup.findAll('tr') 这里分解每一列的时候要小心，因为这里表格分成了三页显示，每页最多显示30条数据，这里因为只是收集已经毕业的学生的成绩数据所以不对其他数据量不足的学生成绩的情况做统计，默认收集的都是大四毕业的学生成绩数据。这里采用两个变量i和j分别代表行和列： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 注:这里的print单纯是我为了验证结果打印在PyCharm的控制台上而已i=0, j=0for tag in target[1:]: tds = tag.findAll('td') # 每一次都是从列头开始获取 j = 0 # 学期 semester = str(tds[0].string) if semester == 'None': break else: print(semester.ljust(6) + '\\t\\t\\t', end='') # 学号 studentid = tds[1].string print(studentid.ljust(14) + '\\t\\t\\t', end='') j += 1 # 姓名 name = tds[2].string print(name.ljust(3) + '\\t\\t\\t', end='') j += 1 # 课程 course = tds[3].string print(course.ljust(20, ' ') + '\\t\\t\\t', end='') j += 1 # 课程要求 requirments = tds[4].string print(requirments.ljust(10, ' ') + '\\t\\t', end='') j += 1 # 学分 scredit = tds[5].string print(scredit.ljust(2, ' ') + '\\t\\t', end='') j += 1 # 成绩 achievement = tds[6].string print(achievement.ljust(2) + '\\t\\t', end='') j += 1 # 重考一 reexaminef = tds[7].string print(reexaminef.ljust(2) + '\\t\\t', end='') j += 1 # 重考二 reexamines = tds[8].string print(reexamines.ljust(2) + '\\t\\t') j += 1 i += 1 这里查了很多别人的博客都是用正则表达式来分解数据，表示自己的正则写的并不好也尝试了但是没成功，所以无奈选择这种方式，如果有人有测试成功的正则欢迎跟我说一声，我也学习学习。 把数据保存到Excel 因为已经清楚了这个网页保存成绩的具体结构，所以顺着每次循环解析将数据不断加以保存就是了，这里使用xlwt写入数据到Excel，因为xlwt模块打印输出到Excel中的样式宽度偏小，影响观看，所以这里还加入了一个方法去控制打印到Excel表格中的样式: 123456789101112file = xlwt.Workbook(encoding='utf-8')table = file.add_sheet('achieve')# 设置Excel样式def set_style(name, height, bold=False): style = xlwt.XFStyle() # 初始化样式 font = xlwt.Font() # 为样式创建字体 font.name = name # 'Times New Roman' font.bold = bold font.color_index = 4 font.height = height style.font = font return style 运用到代码中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354for tag in target[1:]: tds = tag.findAll(&apos;td&apos;) j = 0 # 学期 semester = str(tds[0].string) if semester == &apos;None&apos;: break else: print(semester.ljust(6) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) table.write(i, j, semester, set_style(&apos;Arial&apos;, 220)) # 学号 studentid = tds[1].string print(studentid.ljust(14) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, studentid, set_style(&apos;Arial&apos;, 220)) table.col(i).width = 256 * 16 # 姓名 name = tds[2].string print(name.ljust(3) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, name, set_style(&apos;Arial&apos;, 220)) # 课程 course = tds[3].string print(course.ljust(20, &apos; &apos;) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, course, set_style(&apos;Arial&apos;, 220)) # 课程要求 requirments = tds[4].string print(requirments.ljust(10, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, requirments, set_style(&apos;Arial&apos;, 220)) # 学分 scredit = tds[5].string print(scredit.ljust(2, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, scredit, set_style(&apos;Arial&apos;, 220)) # 成绩 achievement = tds[6].string print(achievement.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, achievement, set_style(&apos;Arial&apos;, 220)) # 重考一 reexaminef = tds[7].string print(reexaminef.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, reexaminef, set_style(&apos;Arial&apos;, 220)) # 重考二 reexamines = tds[8].string print(reexamines.ljust(2) + &apos;\\t\\t&apos;) j += 1 table.write(i, j, reexamines, set_style(&apos;Arial&apos;, 220)) i += 1file.save(&apos;demo.xls&apos;) 最后稍加整合，写成一个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 获取成绩# 这里num代表输入的学号，pagenum代表页数，总共76条数据，一页30条所以总共有三页def getScore(num, pagenum, i, j): score_healders = &#123;&apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User - Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) &apos; &apos;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36&apos;, &apos;Content - Type&apos;: &apos;application / x - www - form - urlencoded&apos;, &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Content - Length&apos;: &apos;69&apos;, &apos;Host&apos;: &apos;jwc.ecjtu.jx.cn&apos;, &apos;Referer&apos;: &apos;http: // jwc.ecjtu.jx.cn / mis_o / main.php&apos;, &apos;Upgrade - Insecure - Requests&apos;: &apos;1&apos;, &apos;Accept - Language&apos;: &apos;zh - CN, zh;q = 0.8&apos; &#125; score_url = &apos;http://jwc.ecjtu.jx.cn/mis_o/query.php?start=&apos; + str( pagenum) + &apos;&amp;job=see&amp;=&amp;Name=&amp;Course=&amp;ClassID=&amp;Term=&amp;StuID=&apos; + num score_data = &#123;&apos;Name&apos;: &apos;&apos;, &apos;StuID&apos;: num, &apos;Course&apos;: &apos;&apos;, &apos;Term&apos;: &apos;&apos;, &apos;ClassID&apos;: &apos;&apos;, &apos;Submit&apos;: &apos;%B2%E9%D1%AF&apos; &#125; score_response = sessions.post(score_url, data=score_data, headers=score_healders) # 输出到文本 with open(&apos;text.txt&apos;, &apos;wb&apos;) as f: f.write(score_response.content) content = score_response.content soup = BeautifulSoup(content, &apos;html.parser&apos;) target = soup.findAll(&apos;tr&apos;) try: for tag in target[1:]: tds = tag.findAll(&apos;td&apos;) j = 0 # 学期 semester = str(tds[0].string) if semester == &apos;None&apos;: break else: print(semester.ljust(6) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) table.write(i, j, semester, set_style(&apos;Arial&apos;, 220)) # 学号 studentid = tds[1].string print(studentid.ljust(14) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, studentid, set_style(&apos;Arial&apos;, 220)) table.col(i).width = 256 * 16 # 姓名 name = tds[2].string print(name.ljust(3) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, name, set_style(&apos;Arial&apos;, 220)) # 课程 course = tds[3].string print(course.ljust(20, &apos; &apos;) + &apos;\\t\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, course, set_style(&apos;Arial&apos;, 220)) # 课程要求 requirments = tds[4].string print(requirments.ljust(10, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, requirments, set_style(&apos;Arial&apos;, 220)) # 学分 scredit = tds[5].string print(scredit.ljust(2, &apos; &apos;) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, scredit, set_style(&apos;Arial&apos;, 220)) # 成绩 achievement = tds[6].string print(achievement.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, achievement, set_style(&apos;Arial&apos;, 220)) # 重考一 reexaminef = tds[7].string print(reexaminef.ljust(2) + &apos;\\t\\t&apos;, end=&apos;&apos;) j += 1 table.write(i, j, reexaminef, set_style(&apos;Arial&apos;, 220)) # 重考二 reexamines = tds[8].string print(reexamines.ljust(2) + &apos;\\t\\t&apos;) j += 1 table.write(i, j, reexamines, set_style(&apos;Arial&apos;, 220)) i += 1 except: print(&apos;出了一点小Bug&apos;) file.save(&apos;demo.xls&apos;) 在模拟登陆操作后增加一个判断： 1234567891011# 判断是否登陆def isLogin(num): return_code = response.status_code if return_code == 200: if re.match(r&quot;^\\d&#123;14&#125;$&quot;, num): print(&apos;请稍等&apos;) else: print(&apos;请输入正确的学号&apos;) return True else: return False 最后在__main__中这么调用： 123456if __name__ == &apos;__main__&apos;: num = input(&apos;请输入你的学号：&apos;) if isLogin(num): getScore(num, pagenum=0, i=0, j=0) getScore(num, pagenum=1, i=31, j=0) getScore(num, pagenum=2, i=61, j=0) 在PyCharm下按alt+shift+x快捷键运行程序： 控制台会有如下输出(这里只截取部分，不要吐槽没有对齐，这里我也用了格式化输出还是不太行，不过最起码出来了结果，而且我们的目的是输出到Excel中不是吗) 然后去程序根目录找看看有没有生成一个叫demo.xls的文件，我的程序就放在桌面，所以去桌面找： 点开查看是否成功获取： 至此，大功告成 小结刚开始接触Python一个星期的样子，这次写了这么一个简单的网络爬虫检验一下学习成果，虽然程序还有些许Bug，不过总归得到了一定收获，当然也为下一步学习打下了基础，嗯哼，为了接下来批量获取网络上美女图片并分类保存我会继续自学Python，荆轲刺秦王~ 源码","tags":[{"name":"Python","slug":"Python","permalink":"https://www.limuyang.cc/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.limuyang.cc/tags/爬虫/"},{"name":"模拟登陆","slug":"模拟登陆","permalink":"https://www.limuyang.cc/tags/模拟登陆/"},{"name":"保存数据","slug":"保存数据","permalink":"https://www.limuyang.cc/tags/保存数据/"}]},{"title":"Python网络编程基础","date":"2016-07-25T19:24:55.000Z","path":"2016/07/25/Python网络编程基础/","text":"原文转自：Python教程 TCP/IP简介虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。 计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。 为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接”网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。 因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。 通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。 IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。 IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334。 TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。 许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。 一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。 端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个IP包来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。 一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。 了解了TCP/IP协议的基本概念，IP地址和端口的概念，我们就可以开始进行网络编程了。 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示”打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 客户端 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。 所以，我们要创建一个基于TCP连接的Socket，可以这样做： 123456# 导入socket库:import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('www.sina.com.cn', 80)) 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。 客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名www.sina.com.cn自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？ 答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，因为80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。 因此，我们连接新浪服务器的代码如下： 1s.connect(('www.sina.com.cn', 80)) 注意参数是一个tuple，包含地址和端口号。 建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容： 12# 发送数据:s.send(b'GET / HTTP/1.1\\r\\nHost: www.sina.com.cn\\r\\nConnection: close\\r\\n\\r\\n') TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。 发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了： 12345678910# 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b''.join(buffer) 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。 当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了： 12# 关闭连接:s.close() 接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件： 12345header, html = data.split(b'\\r\\n\\r\\n', 1)print(header.decode('utf-8'))# 把接收的数据写入文件:with open('sina.html', 'wb') as f: f.write(html) 现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。 服务器 和客户端编程相比，服务器编程就要复杂一些。 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。 首先，创建一个基于IPv4和TCP协议的Socket： 1s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。 端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定： 12# 监听端口:s.bind(('127.0.0.1', 9999)) 紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量： 12s.listen(5)print('Waiting for connection...') 接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接: 123456while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接： 1234567891011def tcplink(sock, addr): print('Accept new connection from %s:%s...' % addr) sock.send(b'Welcome!') while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode('utf-8') == 'exit': break sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8')) sock.close() print('Connection from %s:%s closed.' % addr) 连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。 要测试这个服务器程序，我们还需要编写一个客户端程序： 1234567891011s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect((&apos;127.0.0.1&apos;, 9999))# 接收欢迎消息:print(s.recv(1024).decode(&apos;utf-8&apos;))for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]: # 发送数据: s.send(data) print(s.recv(1024).decode(&apos;utf-8&apos;))s.send(b&apos;exit&apos;)s.close() 我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了： 需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。 小结 用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。 同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。 源码： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python3# -*- coding: utf-8 -*-import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('www.sina.com.cn', 80))# 发送数据:s.send(b'GET / HTTP/1.1\\r\\nHost: www.sina.com.cn\\r\\nConnection: close\\r\\n\\r\\n')# 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b''.join(buffer)# 关闭连接:s.close()header, html = data.split(b'\\r\\n\\r\\n', 1)print(header.decode('utf-8'))# 把接收的数据写入文件:with open('sina.html', 'wb') as f: f.write(html) UDP编程TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口： 123s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind(('127.0.0.1', 9999)) 创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据： 123456print('Bind UDP on 9999...')while True: # 接收数据: data, addr = s.recvfrom(1024) print('Received from %s:%s.' % addr) s.sendto(b'Hello, %s!' % data, addr) recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 注意这里省掉了多线程，因为这个例子很简单。 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： 1234567s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8'))s.close() 从服务器接收数据仍然调用recv()方法。 仍然用两个命令行分别启动服务器和客户端测试，结果如下： 小结 UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。 sever.py 123456789101112131415161718#!/usr/bin/env python3# -*- coding: utf-8 -*-import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind(('127.0.0.1', 9999))print('Bind UDP on 9999...')while True: # 接收数据: data, addr = s.recvfrom(1024) print('Received from %s:%s.' % addr) reply = 'Hello, %s!' % data.decode('utf-8') s.sendto(reply.encode('utf-8'), addr) client.py 1234567891011121314#!/usr/bin/env python3# -*- coding: utf-8 -*-import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8'))s.close()","tags":[{"name":"Python","slug":"Python","permalink":"https://www.limuyang.cc/tags/Python/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.limuyang.cc/tags/计算机网络/"}]},{"title":"Android Design Support Library--FloatingActionButton及其Behavior的使用","date":"2016-05-31T00:20:19.000Z","path":"2016/05/31/Android-Design-Support-Library-FloatingActionButton及其Behavior的使用/","text":"引言如果说前面提到的TextInputLayout、SnackBar的应用还不是很常见的话，那么今天提到的FloatingActionButton绝对是一个随处可见的Material Design控件了，无论是我们常用的知乎、印象笔记或者是可爱的谷歌全家桶套装都可以见到FloatingActionButton的身影，今天就来说说FloatingActionButton。 关于使用其实我相信很多人都用过了Material Design控件了，但是还是要说一下，毕竟有些人接触的晚一些，一些人接触的早一些，先从最简单的使用看起： 属性值 作用 app:elevation 设置FAB未按下时的景深 app:pressedTranslationZ 设置FAB按下时的景深 app:fabSize 设置FAB的大小，默认只有normal和mini两种选项 app:borderWidth 设置FAB的边框宽度 android:src 设置FAB的drawaber app:rippleColor 设置FAB按下时的背景色 app:backgroundTint 设置FAB未按下时的背景色 app:layout_anchor 设置FAB的锚点 app:layout_anchorGravity 设置FAB相对于锚点的位置 app:layout_behavior 设置FAB的Behavior行为属性 大部分的属性还是很好理解的，这里要提一下几个注意的点 app:borderWidth :这个一般设置为0dp，不然的话在4.1的sdk上FAB会显示为正方形，而且在5.0以后的sdk没有阴影效果 app:rippleColor：当我使用com.android.support:design:23.2.0 的时候这个属性会失效，建议使用最新的 com.android.support:design:23.3.0&#39; 或者适当的降低版本 android:layout_marginBottom :由于FAB 支持库仍然存在一些 bug，在 Kitkat 和 Lollipop 中分别运行示例代码，可以看到如下结果： Lollipop 中的 FAB： Kitkat 中的 FAB： 很容易看出，Lollipop 中存在边缘显示的问题。为了解决此问题，API21+ 的版本统一定义底部与右边缘空白为 16dp，Lollipop 以下版本统一设置为 0dp.解决办法： values/dimens.xml12&lt;dimen name=\"fab_margin_right\"&gt;0dp&lt;/dimen&gt;&lt;dimen name=\"fab_margin_bottom\"&gt;0dp&lt;/dimen&gt; values-v21/dimens.xml 12&lt;dimen name=\"fab_margin_right\"&gt;16dp&lt;/dimen&gt;&lt;dimen name=\"fab_margin_bottom\"&gt;16dp&lt;/dimen&gt; 布局文件的 FAB 中，也设置相应的值： 12345&lt;android.support.design.widget.FloatingActionButton ... ... android:layout_marginBottom=\"@dimen/fab_margin_bottom\" android:layout_marginRight=\"@dimen/fab_margin_right\"/&gt; 以上这段话出处 app:layout_anchor：和app:layout_anchorGravity属性一起搭配使用，可以做出不同的效果： 最简单的使用1234567&lt;android.support.design.widget.FloatingActionButton ... ... app:layout_anchor=\"@id/mRecycleView\" app:layout_anchorGravity=\"bottom|right|end\" ... /&gt; 更酷炫的效果 123456&lt;android.support.design.widget.FloatingActionButton ... app:layout_anchor=&quot;@id/collapsingToolbarLayout&quot; app:layout_anchorGravity=&quot;bottom|center&quot; ... /&gt; 这张图片出处 可以看出我们只要使用app:layout_anchor属性设置一个控件作为FAB的锚，然后通过app:layout_anchorGravity 属性放置FAB在这个相对的锚的位置，就能做出你想要的效果。 app:layout_behavior：这个属性接下来会重点讲，也就是这个属性成就了Material Design的众多动画交互效果，我们熟知的SnackBar配合FAB可以侧滑以及APPBarLayout等动画效果都是通过Behavior做出来的 自定义Behavior如果你还记得这张图的话： 或者说你见过这种交互效果： 其实这些都是通过Behavior这个类做出来的，以上的两种动画都是默认自带的Behavior，在CoordinatorLayout 内部有对Behavior类的描述： 123456789/** * Interaction behavior plugin for child views of &#123;@link CoordinatorLayout&#125;. * * &lt;p&gt;A Behavior implements one or more interactions that a user can take on a child view. * These interactions may include drags, swipes, flings, or any other gestures.&lt;/p&gt; * * @param &lt;V&gt; The View type that this Behavior operates on */ public static abstract class Behavior&lt;V extends View&gt; &#123; 可以看到这是一个抽象类，我们可以在各个Material Design去实现这个类，这里提到FAB，我们可以找一下FAB中的默认Behavior交互的实现： 123456789/** * Behavior designed for use with &#123;@link FloatingActionButton&#125; instances. It's main function * is to move &#123;@link FloatingActionButton&#125; views so that any displayed &#123;@link Snackbar&#125;s do * not cover them. */ public static class Behavior extends CoordinatorLayout.Behavior&lt;FloatingActionButton&gt; &#123; // We only support the FAB &lt;&gt; Snackbar shift movement on Honeycomb and above. This is // because we can use view translation properties which greatly simplifies the code. private static final boolean SNACKBAR_BEHAVIOR_ENABLED = Build.VERSION.SDK_INT &gt;= 11; 这里只贴出一部分，如果英文不差的话看得懂注释的意思：大致就是说我们这里只提供API 11以上的Snackbar和FAB的运动交互效果，也就是我们上面动图中看到的效果：当出现了一个SnackBar时候，FAB会自动向上移动一段距离，当SnackBar消失的时候FAB会回到原来位置，那么如何定义一个属于我们自己的Behavior，先来看看需要用到的知识： 其实细分的话有两种情况：1、当一个View的变化依赖于另一个View的尺寸、位置等变化的时候，我们只需要关注以下两种方法： 123456789* @param parent 第一个参数不用解释吧* @param 你要依赖别的View的那个View* @param dependency 你要依赖的View* @return return 如果找到了你依赖的那个View就返回true * @see #onDependentViewChanged(CoordinatorLayout, android.view.View, android.view.View) */ public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; 12345678* @param parent 同上，不解释* @param child 同上* @param dependency 同上* @return 如果这个Behavior改变了child的位置或者尺寸大小就返回true */ public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; 其实FAB里面就是实现了这两种方法来与SnackBar交互的，看一下标准写法： 1234567891011121314151617181920@Override public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; // We're dependent on all SnackbarLayouts (if enabled) return SNACKBAR_BEHAVIOR_ENABLED &amp;&amp; dependency instanceof Snackbar.SnackbarLayout; &#125; ... ... @Override public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; if (dependency instanceof Snackbar.SnackbarLayout) &#123; updateFabTranslationForSnackbar(parent, child, dependency); &#125; else if (dependency instanceof AppBarLayout) &#123; // If we're depending on an AppBarLayout we will show/hide it automatically // if the FAB is anchored to the AppBarLayout updateFabVisibility(parent, (AppBarLayout) dependency, child); &#125; return false; &#125; 2、另一种情况是当一个View监听CoordinatorLayout内部滑动的View进行交互时，我们需要关注的方法稍微多一点，这些方法都写在了NestedScrollingParent接口里面，而且CoordinatorLayout已经对这个接口有了默认实现： onStartNestedScroll1234567891011121314151617 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param directTargetChild the child view of the CoordinatorLayout that either is or * contains the target of the nested scroll operation * @param target the descendant view of the CoordinatorLayout initiating the nested scroll * @param nestedScrollAxes the axes that this nested scroll applies to. See * &#123;@link ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;, * &#123;@link ViewCompat#SCROLL_AXIS_VERTICAL&#125; 滑动时是横轴和纵轴 * @return true if the Behavior wishes to accept this nested scroll * * @see NestedScrollingParent#onStartNestedScroll(View, View, int) */public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes) &#123; return false;&#125; onNestedPreScroll12345678910111213141516 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param target the descendant view of the CoordinatorLayout performing the nested scroll * @param dx the raw horizontal number of pixels that the user attempted to scroll * @param dy the raw vertical number of pixels that the user attempted to scroll * @param consumed out parameter. consumed[0] should be set to the distance of dx that * was consumed, consumed[1] should be set to the distance of dy that * was consumed * * @see NestedScrollingParent#onNestedPreScroll(View, int, int, int[]) */public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dx, int dy, int[] consumed) &#123; // Do nothing&#125; onNestedFling123456789101112131415 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param target the descendant view of the CoordinatorLayout performing the nested scroll * @param velocityX horizontal velocity of the attempted fling * @param velocityY vertical velocity of the attempted fling * @param consumed true if the nested child view consumed the fling * @return true if the Behavior consumed the fling * * @see NestedScrollingParent#onNestedFling(View, float, float, boolean) */public boolean onNestedFling(CoordinatorLayout coordinatorLayout, V child, View target, float velocityX, float velocityY, boolean consumed) &#123; return false;&#125; onNestedScroll1234567891011121314151617 * @param coordinatorLayout the CoordinatorLayout parent of the view this Behavior is * associated with * @param child the child view of the CoordinatorLayout this Behavior is associated with * @param target the descendant view of the CoordinatorLayout performing the nested scroll * @param dxConsumed horizontal pixels consumed by the target's own scrolling operation * @param dyConsumed vertical pixels consumed by the target's own scrolling operation * @param dxUnconsumed horizontal pixels not consumed by the target's own scrolling * operation, but requested by the user * @param dyUnconsumed vertical pixels not consumed by the target's own scrolling operation, * but requested by the user * * @see NestedScrollingParent#onNestedScroll(View, int, int, int, int) */public void onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; // Do nothing&#125; 如果是码农的话上面的英文注释应该不难吧，这四个方法的区别如下： onStartNestedScroll ：当你想要初始化一个滑动的时候调用 onNestedPreScroll 和onNestedScroll：存在着两个方法的原因是一些Behaviors（比如和AppBarLayout使用的）可能会消费掉部分滚动事件，我们可以在onNestedPreScroll方法内部计算需要滚动的距离，具体的话请看这里 onNestedScroll：当target正尝试滑动或者已经滑动时候调用这个方法 onNestedFling：看到Fling就明白是这是Fling情况下调用的方法，Fling最直观的体现是你滑动一个ListView时松手的时候ListView还会因为惯性自动滑动一小段距离 这么看可能太笼统了，看一下这一类Behavior的实际体现，我们自己自定义一个Behavior： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class FadeBehavior extends FloatingActionButton.Behavior &#123; /** * 因为是在XML中使用app:layout_behavior定义静态的这种行为, * 必须实现一个构造函数使布局的效果能够正常工作。 * 否则 Could not inflate Behavior subclass error messages. * @param context * @param attrs */ public FadeBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; /** * 处理垂直方向上的滚动事件 * * @param coordinatorLayout * @param child * @param directTargetChild * @param target * @param nestedScrollAxes * @return */ @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123; // Ensure we react to vertical scrolling return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); &#125; /** * 检查Y的位置，并决定按钮是否动画进入或退出 * @param coordinatorLayout * @param child * @param target * @param dxConsumed * @param dyConsumed * @param dxUnconsumed * @param dyUnconsumed */ @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB child.hide(); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB child.show(); &#125; &#125;&#125; 这里继承了FAB的Behavior写了一个我们自己的实现，注意实现自己的Behavior的时候一定要重写两个参数的构造方法，因为CoordinatorLayout会从我们在XML中定义的app:layout_behavior属性去找这个Behavior，了解自定义View的对这个应该不会陌生，一般的写法是： 1app:layout_behavior=\".FadeBehavior \" 在查资料的过程中发现很多人把自定义Behavior类所在的包名也写进去了，其实亲测没必要这样做，而且CoordinatorLayout里面也有专门的方法去解析： 1234567891011121314151617181920212223242526272829303132333435363738static Behavior parseBehavior(Context context, AttributeSet attrs, String name) &#123; if (TextUtils.isEmpty(name)) &#123; return null; &#125; final String fullName; if (name.startsWith(\".\")) &#123; // Relative to the app package. Prepend the app package name. fullName = context.getPackageName() + name; &#125; else if (name.indexOf('.') &gt;= 0) &#123; // Fully qualified package name. fullName = name; &#125; else &#123; // Assume stock behavior in this package (if we have one) fullName = !TextUtils.isEmpty(WIDGET_PACKAGE_NAME) ? (WIDGET_PACKAGE_NAME + '.' + name) : name; &#125; try &#123; Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get(); if (constructors == null) &#123; constructors = new HashMap&lt;&gt;(); sConstructors.set(constructors); &#125; Constructor&lt;Behavior&gt; c = constructors.get(fullName); if (c == null) &#123; final Class&lt;Behavior&gt; clazz = (Class&lt;Behavior&gt;) Class.forName(fullName, true, context.getClassLoader()); c = clazz.getConstructor(CONSTRUCTOR_PARAMS); c.setAccessible(true); constructors.put(fullName, c); &#125; return c.newInstance(context, attrs); &#125; catch (Exception e) &#123; throw new RuntimeException(\"Could not inflate Behavior subclass \" + fullName, e); &#125; &#125; 可以看到用这种方式的系统会自动给我们加上包名，写太多反而显的累赘，这个自定义Behavior应该很好理解，效果就是随着RecycleView的滑动FAB会隐藏/显示，是一个很常见的效果： 只要向上滚动FAB就会消失，向下滚动FAB就是显示，这里要注意的是FAB可以与RecycleView形成这种效果，但是暂时并不支持ListView，没关系，反正RecycleView当成ListView来用就好，接下来仿照实现知乎的FAB效果的实现，先看一下知乎的效果： 可以很清楚的看到FAB随着RecycleView的滑动呈现出滚动推出的效果，并且点击FAB会出现旋转效果并且弹出一个蒙版，我们可以先自定义一个用于执行FAB旋转的Behavior，可以看到这里FAB是逆时针旋转135度，那么代码就可以这么写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class RotateBehavior extends CoordinatorLayout.Behavior&lt;FloatingActionButton&gt; &#123; private static final String TAG = RotateBehavior.class.getSimpleName(); public RotateBehavior() &#123; &#125; public RotateBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; return dependency instanceof Snackbar.SnackbarLayout; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; float translationY = getFabTranslationYForSnackBar(parent, child); float percentComplete = -translationY / dependency.getHeight(); child.setRotation(-135 * percentComplete); child.setTranslationY(translationY); return true; &#125; private float getFabTranslationYForSnackBar(CoordinatorLayout parent, FloatingActionButton fab) &#123; float minOffset = 0; final List&lt;View&gt; dependencies = parent.getDependencies(fab); for (int i = 0, z = dependencies.size(); i &lt; z; i++) &#123; final View view = dependencies.get(i); if (view instanceof Snackbar.SnackbarLayout &amp;&amp; parent.doViewsOverlap(fab, view)) &#123; //view.getHeight()固定为144 //ViewCompat.getTranslationY(view)从144-0，再从0-144 minOffset = Math.min(minOffset, ViewCompat.getTranslationY(view) - view.getHeight()); Log.d(\"TranslationY\",ViewCompat.getTranslationY(view)+\"\"); Log.d(\"Height\",view.getHeight()+\"\"); &#125; &#125; return minOffset; &#125;&#125; 这里可能就这段代码比较难理解： 12minOffset = Math.min(minOffset, ViewCompat.getTranslationY(view) - view.getHeight()); 我在上面打了两个Log，分别得出了ViewCompat.getTranslationY(view) 和view.getHeight() ，这样看代码就比较容易看懂，但是为什么ViewCompat.getTranslationY(view) 是正数呢，这里的的View我们都知道指的是SnackBar，我们都知道向上移动的话getTranslationY 应该是负数啊，其实SnackBar的源代码中有一个这样的动作： 12345ViewCompat.setTranslationY(mView, mView.getHeight()); ViewCompat.animate(mView) .translationY(0f) .setInterpolator(FAST_OUT_SLOW_IN_INTERPOLATOR) .setDuration(ANIMATION_DURATION) 也就是说SnackBar一开始就向下移动了mView.getHeight()的长度，当SnackBar出现的时候只是向着它原来的位置移动，本质上还是相当于从它原来的位置移动了一段距离，只是这个距离随着SnackBar向上浮动的越来越多而变得越来越小，直至回到原来的位置，这么说应该可以理解了，接下来我们在XML文件中加入一个TextView作为蒙版： 123456&lt;TextView android:id=&quot;@+id/hide&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffff&quot; android:visibility=&quot;gone&quot; /&gt; 因为CoordinatorLayout相当于帧布局是一层一层叠加的所以这个蒙版放在RecycleView和FAB中间，整个布局代码： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/coor&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/mRecycleView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;TextView android:id=&quot;@+id/hide&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffff&quot; android:visibility=&quot;gone&quot; /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;@dimen/fab_margin_bottom&quot; android:layout_marginEnd=&quot;@dimen/fab_margin_right&quot; android:src=&quot;@mipmap/plus&quot; app:backgroundTint=&quot;#0767C8&quot; app:borderWidth=&quot;0dp&quot; app:elevation=&quot;6dp&quot; app:fabSize=&quot;normal&quot; app:layout_anchor=&quot;@id/mRecycleView&quot; app:layout_anchorGravity=&quot;bottom|right|end&quot; app:layout_behavior=&quot;.FadeBehavior&quot; app:pressedTranslationZ=&quot;12dp&quot; app:rippleColor=&quot;#0767C8&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 看看效果： 是不是有一个很奇怪的地方，知乎的FAB并没有SnackBar弹出啊，那就说明一开始的思路错了，但是一个FAB只能设置一个app:layout_behavior ，如果我们把这个Behavior用作FAB的旋转效果那么FAB的滚动移出视图的效果就没了，所以换一种思路，用Object动画来做FAB的旋转效果： 123456789101112131415161718192021222324252627282930 //开始旋转 public void turnLeft(View v) &#123; ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(v, \"rotation\", 0, -155, -135); objectAnimator.setDuration(300); objectAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); objectAnimator.start(); hide.setVisibility(View.VISIBLE); AlphaAnimation alphaAnimation = new AlphaAnimation(0, 0.75f); alphaAnimation.setDuration(300); alphaAnimation.setFillAfter(true); hide.startAnimation(alphaAnimation); hide.setClickable(true); isOpen = true; &#125; //回到起始位置 public void turnRight(View v) &#123; ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(v, \"rotation\", -135, 20, 0); objectAnimator.setDuration(300); objectAnimator.setInterpolator(new AccelerateDecelerateInterpolator()); objectAnimator.start(); hide.setVisibility(View.GONE); AlphaAnimation alphaAnimation = new AlphaAnimation(0.75f, 0); alphaAnimation.setDuration(300); alphaAnimation.setFillAfter(true); hide.startAnimation(alphaAnimation); hide.setClickable(false); isOpen = false; &#125;//注:hide就是TextView控件(蒙版) 然后实现FAB的滚动移出视图效果的Behavior： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ScrollAwareFABBehavior extends FloatingActionButton.Behavior &#123; //先慢后快再慢 private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator(); private boolean mIsAnimatingOut = false; public ScrollAwareFABBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; //初始条件 @Override public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) &#123; //垂直滚动 return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); &#125; @Override public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; !this.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB animateOut(child); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB animateIn(child); &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits private void animateOut(final FloatingActionButton button) &#123; if (Build.VERSION.SDK_INT &gt;= 14) &#123; //withLayer()使动画中的某些操作变得更顺畅,加速渲染,API 14以后 ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer() .setListener(new ViewPropertyAnimatorListener() &#123; public void onAnimationStart(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = true; &#125; public void onAnimationCancel(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = false; &#125; public void onAnimationEnd(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = false; view.setVisibility(View.GONE); &#125; &#125;).start(); &#125; else &#123; &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters private void animateIn(FloatingActionButton button) &#123; button.setVisibility(View.VISIBLE); if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(0) .setInterpolator(INTERPOLATOR).withLayer().setListener(null) .start(); &#125; else &#123; &#125; &#125; private int getMarginBottom(View v) &#123; int marginBottom = 0; final ViewGroup.LayoutParams layoutParams = v.getLayoutParams(); if (layoutParams instanceof ViewGroup.MarginLayoutParams) &#123; marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin; &#125; return marginBottom; &#125; 最后实现的效果： 这里部分参考了仿知乎FloatingActionButton浮动按钮动画效果实现 至于FAB弹出的InBox这里就不去实现了，比较麻烦，可以参考第三方的实现： FloatingActionButtonPlus 写在末尾主要参考：浮动操作按钮的选择FloatingActionButton.Behaviorcodepath教程：浮动操作按钮详解Design Support Library (II): Floating Action ButtonCoordinatorLayout高级用法-自定义Behavior 项目源代码GitHub地址 写文章不容易，如果可以的话请给个赞","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https://www.limuyang.cc/tags/Material-Design/"},{"name":"Google","slug":"Google","permalink":"https://www.limuyang.cc/tags/Google/"},{"name":"FloatingActionButton","slug":"FloatingActionButton","permalink":"https://www.limuyang.cc/tags/FloatingActionButton/"}]},{"title":"Android Design Support Library--简约而不简单的SnackBar","date":"2016-05-07T20:15:16.000Z","path":"2016/05/07/Android-Design-Support-Library-简约而不简单的SnackBar/","text":"引言在之前我有提到这一篇Android Design Support Library系列文章是关于SnackBar的，但是由于要用到CoordinatorLayout所以先翻译了一篇相关文章，如果还不了解的可以先看一下Android Design Support Library–使用CoordinatorLayout来处理滚动 ，这一篇我们讲SnackBar，SnackBar其实就是Toast的升级版，他们之间最大的不同就是：SnackBar会对我们的操作提供一个轻量级的反馈，并且可以对点击事件做出响应，如果是在手机上使用一个SnackBar的话，我们会看到在屏幕底部出现一条简短的信息，如果是在更大的屏幕上这条信息应该会显示在左下角，并且当一个SnackBar显示的时候它是凌驾于当前所有屏幕元素之上的，我们在屏幕上一次只能显示一个SnackBar，如果这么讲不是很清楚的话，我们先来看一个小Demo，通过代码驱动理解是比较好的方式。 示例根据SnackBar的特点，在屏幕上显示出不同的SnackBar，效果如下： 先看一下相关的API文档： 方法类型 方法 作用 void dismiss() 使SnackBar消失 int getDuration() 返回SnackBar的持续时间 View getView() 返回当前SnackBar的View boolean isShown() 判断该SnackBar是否正在显示 boolean isShownOrQueued() 判断该SnackBar是否正在显示或者排队等待即将要显示 static Snackbar make(View view, int resId, int duration) 新建一个用来显示信息的SnackBar static Snackbar make(View view, CharSequence text, int duration) 同上 Snackbar setAction(int resId, View.OnClickListener listener) 设置这个即将显示的SnackBar的动作 Snackbar setAction(CharSequence text, View.OnClickListener listener) 同上 Snackbar setActionTextColor(ColorStateList colors) 设置action的文字颜色(右边的) Snackbar setActionTextColor(int color) 同上 Snackbar setCallback(Snackbar.Callback callback) 设置一个回调，当SnackBar的可见性改变的时候调用 Snackbar setDuration(int duration) 设置SnackBar信息的显示时间 Snackbar setText(int resId) 更新SnackBar上显示的文字 Snackbar setText(CharSequence message) 同上 void show() 显示SnackBar，最后一定要调用这个方法，不然SnackBar不显示，联想Toast 可以看到Demo上显示了三种不同的SnackBar，我们都知道SnackBar是Toast的升级版，但也说明了一个问题那就是SnackBar是用来显示消息的，同时根据你的需求不同可以对这些消息做出一定的响应动作，下面分析三种显示消息方式的不同： 普通的SnackBar 也许有的人并没有过多的需求，只是单纯地想把SnackBar当作一个显示消息的控件而已，那么可以很简单的在代码中这么使用： 1Snackbar.make(mCoor, R.string.normal, Snackbar.LENGTH_SHORT).show(); 对比一下我们的Toast方式： 1Toast.makeText(MainActivity.this,R.string.normal,Toast.LENGTH_SHORT).show(); 是不是很像，没错简单的使用的话SnackBar跟Toast并没有多大区别，但是动画效果上是有差异的，如果你注意到了这一点： 看，这个侧边滑动消失的效果只有当你使用CoordinatorLayout作为根布局才有，这就是为什么在写SnackBar之前我要先说明一下CoordinatorLayout的原因，如果你使用普通的LinearLayout或者RelativeLayout是不会有这种动画交互效果的，另外，注意SnackBar的make方法有两种重载方法，分别是： 1make(View view, int resId, int duration) 和 1make(View view, CharSequence text, int duration) 这里有三个参数，第一个参数View表示的意思是我们传入一个View，然后SnackBar会遍历整个View Tree来找到一个合适的View承载SnackBar的View，如果你想要实现上面的动画交互效果的话最好是传入CoordinatorLayout对象，第二个参数的话是两个重载方法不同的地方，有一种是我们熟知的： 1Snackbar.make(mCoor, \"普通的SnackBar\", Snackbar.LENGTH_SHORT).show(); 还有一种要求传入一个ID，注意这个ID并不是指其他的什么，就是你在string.xml文件中定义的字符串资源的ID，比如这样： 1Snackbar.make(mCoor, R.string.normal, Snackbar.LENGTH_SHORT).show(); 然后第三个参数是SnackBar的持续时间，只有三种： 1231、Snackbar.LENGTH_INDEFINITE 一直显示直到另一个SnackBar出现或者主动调用了dismiss()方法2、Snackbar.LENGTH_SHORT 显示较短的时间3、Snackbar.LENGTH_LONG 显示较长的时间 但是官方文档是这么描述的： 1either be one of the predefined lengths: LENGTH_SHORT, LENGTH_LONG, or a custom duration in milliseconds. 说是可以自定义显示时间，但是我自己试了确实不可以，应该是API文档的一个小bug，如果谁试成功了赶紧告诉我~~如果使用过Toast的话上面的应该很好理解，好了，如果你的业务中对SnackBar并没有更多的要求，那么最普通的SnackBar应该满足了，接下来看稍微高级一点的： 带回调的SnackBar： 如果还不太清楚回调的话可以看看这个Android回调函数机制那点事 ，讲这个之前先提一点，如果我们想更加灵活的使用Snackbar的话最好是先持有它的引用，也就是： 1private Snackbar mSnackBar 原因很简单，你会发现上面提供的常用API中很多方法都是非静态方法并不是静态方法，你要调用的话只能通过SnackBar对象去调用。 然后说SnackBar回调之前先说一下Action，SnackBar提供了一个setAction方法： 121、setAction(int resId, View.OnClickListener listener)2、setAction(CharSequence text, View.OnClickListener listener) 同样是两个重载方法，第一个参数跟前面解释的一样，第二个参数是我们熟知的对点击事件的监听，使用方法如下： 1234567Snackbar.make(mCoor,R.string.callback,Snackbar.LENGTH_SHORT) .setAction(R.string.UNDO, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // do something &#125; &#125;).show(); 看一下效果： 当我们调用了setAction方法并且传入一个字符串之后，SnackBar的右下角就会呈现出我们传入的字符串，并且这个字符串是可点击的，我们可以在点击事件里面做出响应，比如说跳转Activity或者弹出一个Toast等等，这里默认你点击了这个Action这个SnackBar是会消失的。也就是无论你的duration参数设置的是一直显示还是显示多长时间都会消失。 有些人可能对右下角这个文字的颜色不满足想要改变，没问题，你想到的Google都给你想好了，SnackBar专门提供了方法来更改Action的文字颜色: 121、setActionTextColor(ColorStateList colors)2、setActionTextColor(int color) 这里第一种方式不建议用，太复杂，你要想这么用也行： 123Resources resource = (Resources) getBaseContext().getResources(); ColorStateList csl = (ColorStateList) resource.getColorStateList(R.color.PeachPuff); mSnackBar.setActionTextColor(csl); 这是网上找到的一种方式，但是我还是推荐使用第二种方式来更改Action的文字颜色，可以看到是我们熟悉的传入一个int型的值，我提供如下几种方式更改： 1231、mSnackBar.setActionTextColor(Color.rgb(232,44,123))2、mSnackBar.setActionTextColor(Color.BLUE)3、mSnackBar.setActionTextColor(Color.parseColor(&quot;#FFDAB9&quot;)); 对了，我还发现一种额外的方式，我们现在使用Android Studio创建新的Project时候系统都会默认在style.xml文件夹下面生成这个： 123456&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; 这里的 1&lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; 其实也可以更改Action文字颜色，而且默认的Action文字颜色就是这里设置的颜色，但是有一个缺点就是如果你改动了这里，那么很多Material Design控件的相关颜色都会改变，如果你看过我之前写的Android Design Support Library–TextInputLayout的使用你会知道TextInputLayout下划线的颜色也是通过这个属性来更改的，所以为了稳定起见还是使用官方提供的方法去更改吧，我这纯属抖个机灵。 那么回到正题，讲讲SnackBar的回调，眼尖的朋友可能发现了，我的Demo里面带回调的SnackBar在弹出和消失的时候都会有Toast通知出现，其实就是使用了SnackBar自带的 1setCallback(Snackbar.Callback callback) 方法，这里需要传入一个Snackbar.Callback callback 参数，其实这个，这个Callback 是SnackBar内部的一个抽象类，它内部有两个空实现的方法： 123onDismissed(Snackbar snackbar, int event)onShown(Snackbar snackbar) 顾名思义，我们可以可以分别在这两个方法中定义出当SnackBar消失和产生时我们需要做的事，这两个方法会在SnackBar消失和产生时被回调，打个比方： 12345678910111213mSnackBar.setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this,\"SnackBar Dismiss\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Toast.makeText(MainActivity.this,\"SnackBar Show\",Toast.LENGTH_SHORT).show(); &#125; &#125;); 这样就实现了在SnackBar消失和产生时弹出Toast通知的动作，其他具体的逻辑可以自己去实现。 完全自定义你自己的SnackBar如果你对上述使用还是不甚满意，那么接下来我教你怎么自定义你自己的SnackBar，说实话用到的场景并不多，但是学了就学个透彻，这一部分知识的灵感来自于没时间解释了，快使用Snackbar! ，SnackBar并没有提供更改背景或者其他样式的方法，但是我们可以通过查看源码来试试可不可以自定义自己样式，我们找到这么一段代码： 12345678910private Snackbar(ViewGroup parent) &#123; mTargetParent = parent; mContext = parent.getContext(); ThemeUtils.checkAppCompatTheme(mContext); LayoutInflater inflater = LayoutInflater.from(mContext); mView = (SnackbarLayout) inflater.inflate( R.layout.design_layout_snackbar, mTargetParent, false);&#125; 最后一行的inflate是不是很熟悉，我们可不可以认为Snackbar的布局就是这么加载的，这个SnackBarLayout是在SnackBar内部定义的一个继承自LinearLayout的内部类： 123456public static class SnackbarLayout extends LinearLayout &#123; private TextView mMessageView; private Button mActionView; private int mMaxWidth; private int mMaxInlineActionWidth; 看到这几个变量的定义，我已经确定了上面的想法，接下来我们找到上面代码加载的那段布局： 12345678910111213141516171819202122232425262728293031&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;&lt;TextView android:id=\"@+id/snackbar_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:paddingTop=\"14dp\" android:paddingBottom=\"14dp\" android:paddingLeft=\"12dp\" android:paddingRight=\"12dp\" android:textAppearance=\"@style/TextAppearance.Design.Snackbar.Message\" android:maxLines=\"2\" android:layout_gravity=\"center_vertical|left|start\" android:ellipsize=\"end\" android:textAlignment=\"viewStart\"/&gt;&lt;Button android:id=\"@+id/snackbar_action\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"0dp\" android:layout_marginStart=\"0dp\" android:layout_gravity=\"center_vertical|right|end\" android:paddingTop=\"14dp\" android:paddingBottom=\"14dp\" android:paddingLeft=\"12dp\" android:paddingRight=\"12dp\" android:visibility=\"gone\" android:textColor=\"?attr/colorAccent\" style=\"?attr/borderlessButtonStyle\"/&gt;&lt;/merge&gt; 看到这两个控件的ID了么 12android:id=\"@+id/snackbar_text\"android:id=\"@+id/snackbar_action\" 那么第一个就是SnackBar左边显示的message，第二个就是我们设置了action时候显示的Button咯，这就简单了，如果你仔细看了上面提供的API文档你会发现有这么一个方法： 123public View getView ()Returns the Snackbar's view. 这个方法可以返回我们SnackBar的View，那么这个View是什么，看源码： 1234567/** * Returns the &#123;@link Snackbar&#125;'s view. */@NonNullpublic View getView() &#123; return mView;&#125; 找一下mView在哪里定义的： 123private final SnackbarLayout mView;mView = (SnackbarLayout) inflater.inflate( R.layout.design_layout_snackbar, mTargetParent, false); 好了，这下一切都清楚了，接下里示范一下怎么自定义你自己的SnackBar： 12345678910111213141516171819private View view; ....省略中间代码 view = mCustomSnackBar.getView(); if (view != null) &#123; view.setBackgroundColor(Color.parseColor(\"#7B68EE\")); //获取Snackbar的message控件，修改字体颜色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(Color.parseColor(\"#FFDAB9\")); //添加图标 Snackbar.SnackbarLayout snackbarLayout = (Snackbar.SnackbarLayout) view; //添加自定义布局，这里布局就包含了一个ImageView //custom_layout是你自定义的布局 View add_view = LayoutInflater.from(view.getContext()).inflate(R.layout.custom_layout, null); LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); p.gravity = Gravity.CENTER_VERTICAL; //数字表示新加的布局在SnackBar中的位置，从0开始,取决于你SnackBar里面有多少个子View snackbarLayout.addView(add_view, 0, p); &#125; 最后一行，addView方法第二个参数表示新加的布局在SnackBar中的位置，注意不要超过总的View的个数不然会报错，message和Action text分别算一个View，其他的话注释已经写得很清楚就不一一解释了，这个代码呈现的效果如下： 为了方便自定义样式，发现这一特性的作者还给我们封装了成为一个工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/** * Created by 赵晨璞 on 2016/5/1. */public class SnackbarUtil &#123;public static final int Info = 1;public static final int Confirm = 2;public static final int Warning = 3;public static final int Alert = 4;public static int red = 0xfff44336;public static int green = 0xff4caf50;public static int blue = 0xff2195f3;public static int orange = 0xffffc107;/** * 短显示Snackbar，自定义颜色 * @param view * @param message * @param messageColor * @param backgroundColor * @return */public static Snackbar ShortSnackbar(View view, String message, int messageColor, int backgroundColor)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_SHORT); setSnackbarColor(snackbar,messageColor,backgroundColor); return snackbar;&#125;/** * 长显示Snackbar，自定义颜色 * @param view * @param message * @param messageColor * @param backgroundColor * @return */public static Snackbar LongSnackbar(View view, String message, int messageColor, int backgroundColor)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_LONG); setSnackbarColor(snackbar,messageColor,backgroundColor); return snackbar;&#125;/** * 自定义时常显示Snackbar，自定义颜色 * @param view * @param message * @param messageColor * @param backgroundColor * @return */public static Snackbar IndefiniteSnackbar(View view, String message,int duration,int messageColor, int backgroundColor)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_INDEFINITE).setDuration(duration); setSnackbarColor(snackbar,messageColor,backgroundColor); return snackbar;&#125;/** * 短显示Snackbar，可选预设类型 * @param view * @param message * @param type * @return */public static Snackbar ShortSnackbar(View view, String message, int type)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_SHORT); switchType(snackbar,type); return snackbar;&#125;/** * 长显示Snackbar，可选预设类型 * @param view * @param message * @param type * @return */public static Snackbar LongSnackbar(View view, String message,int type)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_LONG); switchType(snackbar,type); return snackbar;&#125;/** * 自定义时常显示Snackbar，可选预设类型 * @param view * @param message * @param type * @return */public static Snackbar IndefiniteSnackbar(View view, String message,int duration,int type)&#123; Snackbar snackbar = Snackbar.make(view,message, Snackbar.LENGTH_INDEFINITE).setDuration(duration); switchType(snackbar,type); return snackbar;&#125;//选择预设类型private static void switchType(Snackbar snackbar,int type)&#123; switch (type)&#123; case Info: setSnackbarColor(snackbar,blue); break; case Confirm: setSnackbarColor(snackbar,green); break; case Warning: setSnackbarColor(snackbar,orange); break; case Alert: setSnackbarColor(snackbar,Color.YELLOW,red); break; &#125;&#125;/** * 设置Snackbar背景颜色 * @param snackbar * @param backgroundColor */public static void setSnackbarColor(Snackbar snackbar, int backgroundColor) &#123; View view = snackbar.getView(); if(view!=null)&#123; view.setBackgroundColor(backgroundColor); &#125;&#125;/** * 设置Snackbar文字和背景颜色 * @param snackbar * @param messageColor * @param backgroundColor */public static void setSnackbarColor(Snackbar snackbar, int messageColor, int backgroundColor) &#123; View view = snackbar.getView(); if(view!=null)&#123; view.setBackgroundColor(backgroundColor); ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(messageColor); &#125;&#125;/** * 向Snackbar中添加view * @param snackbar * @param layoutId * @param index 新加布局在Snackbar中的位置 */public static void SnackbarAddView( Snackbar snackbar,int layoutId,int index) &#123; View snackbarview = snackbar.getView(); Snackbar.SnackbarLayout snackbarLayout=(Snackbar.SnackbarLayout)snackbarview; View add_view = LayoutInflater.from(snackbarview.getContext()).inflate(layoutId,null); LinearLayout.LayoutParams p = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT); p.gravity= Gravity.CENTER_VERTICAL; snackbarLayout.addView(add_view,index,p);&#125;&#125; 使用示例如下： 1SnackbarUtil.ShortSnackbar(coordinator,\"妹子向你发来一条消息\",SnackbarUtil.Info).show(); 在此要非常感谢简名 给我们提供这么好的工具类，那么还有什么不懂得可以留言探讨，下面上整个项目的代码： MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.muyang.snackbardemo;import android.graphics.Color;import android.os.Bundle;import android.support.design.widget.CoordinatorLayout;import android.support.design.widget.Snackbar;import android.support.v7.app.AppCompatActivity;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button btn_normal, btn_callback, btn_custom; private CoordinatorLayout mCoor; private Snackbar mSnackBar, mCustomSnackBar; private View view; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initWidget(); mSnackBar = Snackbar.make(mCoor, R.string.callback, Snackbar.LENGTH_SHORT) .setAction(R.string.UNDO, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); //SnackBar回调方法 mSnackBar.setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this,\"SnackBar Dismiss\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Toast.makeText(MainActivity.this,\"SnackBar Show\",Toast.LENGTH_SHORT).show(); &#125; &#125;);// 1、Resources resource = (Resources) getBaseContext().getResources();// ColorStateList csl = (ColorStateList) resource.getColorStateList(R.color.PeachPuff);// mSnackBar.setActionTextColor(csl);// 2、mSnackBar.setActionTextColor(Color.rgb(232,44,123))// 3、mSnackBar.setActionTextColor(Color.BLUE) mSnackBar.setActionTextColor(Color.parseColor(\"#FFDAB9\")); //自定义SnackBar样式 mCustomSnackBar = Snackbar.make(mCoor, R.string.custom, Snackbar.LENGTH_SHORT) .setAction(R.string.UNDO, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); mCustomSnackBar.setActionTextColor(Color.parseColor(\"#FFDAB9\")); //获得SnackBar这个View view = mCustomSnackBar.getView(); if (view != null) &#123; view.setBackgroundColor(Color.parseColor(\"#7B68EE\")); //获取Snackbar的message控件，修改字体颜色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(Color.parseColor(\"#FFDAB9\")); //添加图标 Snackbar.SnackbarLayout snackbarLayout = (Snackbar.SnackbarLayout) view; //custom_layout是你自定义的布局 View add_view = LayoutInflater.from(view.getContext()).inflate(R.layout.custom_layout, null); LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); p.gravity = Gravity.CENTER_VERTICAL; //数字表示新加的布局在SnackBar中的位置，从0开始,取决于你SnackBar里面有多少个子View snackbarLayout.addView(add_view, 0, p); &#125; &#125; private void initWidget() &#123; btn_normal = (Button) findViewById(R.id.btn_normal); btn_normal.setOnClickListener(this); btn_callback = (Button) findViewById(R.id.btn_callback); btn_callback.setOnClickListener(this); btn_custom = (Button) findViewById(R.id.btn_custom); btn_custom.setOnClickListener(this); mCoor = (CoordinatorLayout) findViewById(R.id.coordinatorLayout); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_normal: Snackbar.make(mCoor, R.string.normal, Snackbar.LENGTH_SHORT).show(); break; case R.id.btn_callback:// Snackbar.make(mCoor,R.string.callback,Snackbar.LENGTH_SHORT)// .setAction(R.string.UNDO, new View.OnClickListener() &#123;// @Override// public void onClick(View v) &#123;//// &#125;// &#125;).show(); mSnackBar.show(); break; case R.id.btn_custom: mCustomSnackBar.show();// if (mSnackBar.isShown()) &#123;// mSnackBar.dismiss();// &#125; break; &#125; &#125;&#125; activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/coordinatorLayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/btn_normal\" android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"80dp\" android:background=\"@drawable/btn_bg\" android:text=\"@string/normal\" android:textSize=\"15sp\" /&gt; &lt;Button android:id=\"@+id/btn_callback\" android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" android:layout_alignStart=\"@+id/btn_normal\" android:layout_below=\"@+id/btn_normal\" android:layout_marginTop=\"38dp\" android:background=\"@drawable/btn_bg\" android:text=\"@string/callback\" android:textSize=\"15sp\" /&gt; &lt;Button android:id=\"@+id/btn_custom\" android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" android:layout_alignStart=\"@+id/btn_callback\" android:layout_below=\"@+id/btn_callback\" android:layout_marginTop=\"45dp\" android:background=\"@drawable/btn_bg\" android:text=\"@string/custom\" android:textSize=\"15sp\" /&gt; &lt;/RelativeLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; custom_layout.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; &gt; &lt;ImageView android:layout_width=&quot;35dp&quot; android:layout_height=&quot;35dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:src=&quot;@drawable/header&quot;/&gt;&lt;/LinearLayout&gt; 彩蛋SnackBar源码 项目源码项目GitHub地址 参考没时间解释了，快使用Snackbar!Android Material Design Snackbar Example 喜欢Android Design Support Library系列的朋友欢迎关注我的微信公众号未央进化论，第一时间通知博客更新，荆轲刺秦王(＾－＾)","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https://www.limuyang.cc/tags/Material-Design/"},{"name":"Google","slug":"Google","permalink":"https://www.limuyang.cc/tags/Google/"},{"name":"Android","slug":"Android","permalink":"https://www.limuyang.cc/tags/Android/"}]},{"title":"Android Design Support Library--TextInputLayout的使用","date":"2016-04-30T00:20:19.000Z","path":"2016/04/30/Android-Design-Support-Library-TextInputLayout的使用/","text":"引言Google在2015的IO大会上，给我们带来了更加详细的Material Design设计规范，同时，也给我们带来了全新的Android Design Support Library，Android Design Support Library的兼容性更广，直接可以向下兼容到Android 2.2，我准备从最简单的控件开始，逐渐延伸，把新控件都给熟悉一遍。先从看起来最简单的控件开始，也就是TextInputLayout，说实话TextInputLayout 我所见到的平常用的并不多，它的大体作用是在我们正常的EditText左上角显示出一个浮动标签，这个标签的内容就是我们设置的android:hint 属性的值。先来看一下它的继承结构： 可以很清晰的看到我们的TextInputLayout 继承于LinearLayout ，那么很明显这是一个布局，需要配合它的子控件来显示出想要的效果，这里谷歌把它专门设计用来包裹EditText(或者EditText的子类)，然后当用户进行输入动作的时候我们设置的android:hint 提示就会以动画的形式运动到左上角，谷歌官方提供的最简单的使用示例如下： 12345678910&lt;android.support.design.widget.TextInputLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.design.widget.TextInputEditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/form_username\"/&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 有些人可能会奇怪，之前说好的TextInputLayout 是用来包裹EditText 的，为什么这里出现了TextInputEditText ，先别急，我们看一下谷歌官方对这个控件的描述： 123A special sub-class of EditText designed for use as a child of TextInputLayout.Using this class allows us to display a hint in the IME when in 'extract' mode. 大意是说，这只是一种特殊的EditText 的子类，用来在&#39;extract&#39; mode 下在输入法编辑器中显示我们的hint提示信息，这里的&#39;extract&#39; mode 其实就是全屏模式，谷歌官方对它的解释是有时候你的输入框的UI界面很大，大的不能与你自己的应用程序的UI结合起来，这时候就可以切换到全屏模式来输入，这么说可能不太明白，上图：比如说，下面这种情况使用的是EditText： 我们看到下面那里输入框已经很大了，然后你点击输入框进行输入，会发现这个现象： 你进入到了全屏模式输入，但是界面上空空如也，对比一下使用TextInputEditText 的情况： 看到左上角的文字了嘛，这是我们在之前设置的android:hint 属性的值，这么一看这两者的区别的就一目了然了，但是说实话TextInputEditText 用到的地方还是很有限的，所以日常开发我们还是使用TextInputLayout 去包裹EditText 来实现浮动标签的功能。 以上图片出处 感谢万能的stackoverflow 常用方法因为它是继承自LinearLayout的所以理论上LinearLayout 有的属性它全都有，这里我们只看有关它本身的属性： 属性名 相关方法 描述 app:counterEnabled setCounterEnabled(boolean) 设置是否显示一个计数器，布尔值 app:counterMaxLength setCounterMaxLength(int) 设置计数器的最大计数数值，整型 app:errorEnabled setErrorEnabled(boolean) 设置是否显示一个错误信息，布尔值 app:hintAnimationEnabled setHintAnimationEnabled(boolean) 设置是否要显示输入状态时候的动画效果，布尔值 app:hintEnabled setHintEnabled(boolean) 设置是否要用这个浮动标签的功能，布尔值 app:hintTextAppearance setHintTextAppearance(int) 设置提示文字的样式(注意这里是运行了动画效果之后的样式) 这里我们通过一个简单的Demo来了解以上这些属性，简单起见我们就做一个登录界面，这个界面长这样： 先上布局文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" tools:context=\"com.test.textinputlayoutdemo.MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginTop=\"65dp\" android:orientation=\"vertical\"&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/layout_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterEnabled=\"true\" app:counterMaxLength=\"5\" app:counterOverflowTextAppearance=\"@style/MyOverflowText\" app:errorTextAppearance=\"@style/MyErrorStyle\"&gt; &lt;EditText android:id=\"@+id/input_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/EnterName\" android:singleLine=\"true\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/layout_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterEnabled=\"true\" app:counterMaxLength=\"11\" app:counterOverflowTextAppearance=\"@style/MyOverflowText\" app:errorTextAppearance=\"@style/MyErrorStyle\"&gt; &lt;EditText android:id=\"@+id/input_password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/EnterPassWord\" android:inputType=\"textPassword\" android:singleLine=\"true\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id=\"@+id/layout_email\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:counterOverflowTextAppearance=\"@style/MyOverflowText\" app:errorTextAppearance=\"@style/MyErrorStyle\"&gt; &lt;EditText android:id=\"@+id/input_email\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/EnterEmail\" android:inputType=\"textEmailAddress\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;Button android:id=\"@+id/login\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"50dp\" android:background=\"@color/colorPrimary\" android:text=\"@string/login\" android:textColor=\"#ffffff\" android:textSize=\"20sp\" android:textStyle=\"bold\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText input_name, input_password, input_email; private TextInputLayout layout_name, layout_password, layout_email; private Button btn_login; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initWidget(); &#125; private void initWidget() &#123; input_name = (EditText) findViewById(R.id.input_name); input_password = (EditText) findViewById(R.id.input_password); input_email = (EditText) findViewById(R.id.input_email); layout_name = (TextInputLayout) findViewById(R.id.layout_name); layout_password = (TextInputLayout) findViewById(R.id.layout_password); layout_email = (TextInputLayout) findViewById(R.id.layout_email); btn_login = (Button) findViewById(R.id.login); btn_login.setOnClickListener(this); //添加监听 input_name.addTextChangedListener(new MyTextWatcher(input_name)); input_password.addTextChangedListener(new MyTextWatcher(input_password)); input_email.addTextChangedListener(new MyTextWatcher(input_email)); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.login: canLogin(); break; default: break; &#125; &#125; /** * 判断是否可以登录的方法 */ private void canLogin() &#123; if (!isNameValid()) &#123; Toast.makeText(this, getString(R.string.check), Toast.LENGTH_SHORT).show(); return; &#125; if (!isPasswordValid()) &#123; Toast.makeText(this, getString(R.string.check), Toast.LENGTH_SHORT).show(); return; &#125; if (!isEmailValid()) &#123; Toast.makeText(this, getString(R.string.check), Toast.LENGTH_SHORT).show(); return; &#125; Toast.makeText(this, getString(R.string.login_success), Toast.LENGTH_SHORT).show(); &#125; public boolean isNameValid() &#123; if (input_name.getText().toString().trim().equals(\"\") || input_name.getText().toString().trim().isEmpty()) &#123; layout_name.setError(getString(R.string.error_name)); input_name.requestFocus(); return false; &#125; layout_name.setErrorEnabled(false); return true; &#125; public boolean isPasswordValid() &#123; if (input_password.getText().toString().trim().equals(\"\") || input_password.getText().toString().trim().isEmpty()) &#123; layout_password.setErrorEnabled(true); layout_password.setError(getResources().getString(R.string.error_password)); input_password.requestFocus(); return false; &#125; layout_password.setErrorEnabled(false); return true; &#125; public boolean isEmailValid() &#123; String email = input_email.getText().toString().trim(); if (TextUtils.isEmpty(email) || !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) &#123; layout_email.setErrorEnabled(true); layout_email.setError(getString(R.string.error_email)); layout_email.requestFocus(); return false; &#125; layout_email.setErrorEnabled(false); return true; &#125; //动态监听输入过程 private class MyTextWatcher implements TextWatcher &#123; private View view; private MyTextWatcher(View view) &#123; this.view = view; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; switch (view.getId()) &#123; case R.id.input_name: isNameValid(); break; case R.id.input_password: isPasswordValid(); break; case R.id.input_email: isEmailValid(); break; &#125; &#125; &#125;&#125; 先来看一下最终的实现效果： 可以很明显的看到，当我们同时设置了app:counterEnabled 和app:counterMaxLength 属性时，我们输入的EditText 右下角会出现一个计数器还有一个最大输入字符数的数字显示，我们在输入名字这一栏设置最大输入为5个字符，所以当超过了5个字符的时候，EditText 的整个样式的颜色都会改变以示警告，如果我们只设置了app:counterEnabled 属性的话EditText 右下角一开始会出现一个0，随着输入字符的增多而逐步进行计数，注意如果设置了整个属性我们EditText 布局的高度会有一定的增大，具体的可以自己实践一下。 另外，我们在代码中设置了不同的饿输入类型，如果输入类型错误，我们就可以通过设置app:errorEnabled 来开启错误显示，此时需要通过在代码中调用 setError(string) 方法来设置显示的错误提示文字，当不需要的时候记得设置app:errorEnabled(false) 来取消错误提示，不然错误提示会一直存在。 注意： 当我们使用app:counterMaxLength 这个属性的时候，一定要设置 app:counterOverflowTextAppearance 属性，不然的话程序运行会报错，这个属性是设置当我们输入字符超过限定的个数时候EditText控件整体显示的样式，需要在style.xml文件里面定义一个自己的style，注意我们自定义的style的parent是TextAppearance.AppCompat.Small ，拿我上面的程序举例： 123&lt;style name=\"MyOverflowText\" parent=\"TextAppearance.AppCompat.Small\"&gt; &lt;item name=\"android:textColor\"&gt;#f3672b&lt;/item&gt;&lt;/style&gt; 这样定义好后再在app:counterOverflowTextAppearance 里面设置这个style就行 关于自定义样式有些人可能不喜欢官方提供的默认样式想要自己定义，下面说一下自定义几种样式的方法： 如果你想更改下划线的颜色，只要在style.xml文件里面找到AppTheme： 123456&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; 更改里面的colorAccent属性就行了 如果你想更改错误提示的样式的话，也是在style.xml文件里面，自定义一个style，同样拿上面的程序举例： 123&lt;style name=\"MyErrorStyle\"&gt; &lt;item name=\"android:textColor\"&gt;#ec4722&lt;/item&gt; &lt;/style&gt; 然后在xml文件TextInputLayout控件里面这么设置一下就行了： 1app:errorTextAppearance=&quot;@style/MyErrorStyle&quot; 包括前面提到的设置当输入字符大于我们限定个数字符时的样式，基本上我们可以很好地自定义出自己想要的style了，以上两种不提供演示，都很简单，可以自己去尝试。 最后下一次准备分析SnackBar控件，很多东西说简单也简单，说不简单也不简单，就像做这个Demo我之前光看官方文档根本没有告诉有app:counterOverflowTextAppearance 这个属性的存在，也是一直查资料，还是要亲自去尝试一下才好，下面上源码(注意是AS文件) 参考：Android Material Design Floating Labels for EditText 项目GitHub地址 最后来个小提示，当我们在Android Studio中导入support design开发包的时候，版本号最好和v7包的版本号一致，不然有些时候会出现莫名其妙的错误： 123compile fileTree(dir: 'libs', include: ['*.jar'])compile 'com.android.support:appcompat-v7:23.0.1'compile 'com.android.support:design:23.0.1' 有任何问题欢迎留言探讨~","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"https://www.limuyang.cc/tags/Material-Design/"},{"name":"Google","slug":"Google","permalink":"https://www.limuyang.cc/tags/Google/"},{"name":"TextInputLayout","slug":"TextInputLayout","permalink":"https://www.limuyang.cc/tags/TextInputLayout/"}]},{"title":"ViewGroup的事件分发机制","date":"2016-04-04T21:08:19.000Z","path":"2016/04/04/ViewGroup的事件分发机制/","text":"引言上一次我在View的事件分发机制里完整的分析了View对于触屏点击事件的分发过程，接下来继续探索之旅，紧接着分析ViewGroup的事件分发机制，ViewGroup其实就是一组View的集合，它也是继承于View的，它本身也可以包含View和ViewGroup，方便起见我们还是延用上一次的布局，不过这一次我们给根布局也设置了点击事件和触摸事件： 1234567891011121314151617181920212223242526public class MainActivity extends Activity implements OnClickListener,OnTouchListener&#123; private RelativeLayout re_Layout; private Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn=(Button) findViewById(R.id.btn); re_Layout=(RelativeLayout) findViewById(R.id.re_layout); btn.setOnClickListener(this); btn.setOnTouchListener(this); re_Layout.setOnClickListener(this); re_Layout.setOnTouchListener(this); &#125; @Override public void onClick(View v) &#123; Log.d(&quot;TAG&quot;, &quot;OnClick--&quot;+v); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(&quot;TAG&quot;, &quot;onTouch--&quot;+event.getAction()+&quot;--&quot;+v); return false; &#125;&#125; 效果图也依旧没有变，现在我们先点击一下Button,查看Log输出： 可以很清楚的看到这里和上一节分析得情况一样：当点击事件发生时onTouch()方法是优先于onClick()方法执行的，并且如果onTouch()返回False既不消耗点击事件那么如果控件设置了setOnClickListener最终是会执行到onClick()方法的，可是我很好奇ViewGroup的点击事件和View的到底有什么区别，点击事件事件的分发到底是从ViewGroup开始还是从View开始的呢，于是我点击了Button以外的空白区域，捕捉到如下信息(注:我的根布局就是RelativeLayout)： 说明根布局也就是Viewroup也是可以响应点击事件的，但是我们点击View的时候为什么没有ViewGroup的Log输出，这是不是说明android事件分发是先传到View的，当View消耗的这个事件它的ViewGroup就无法接收这个事件了呢，为了彻底的谈清楚原因，我们先重写一个ViewGroup，然后重写这个ViewGroup里面的onInterceptTouchEvent(MotionEvent ev)、dispatchTouchEvent(MotionEvent event)还有onTouchEvent(MotionEvent event)这三个方法通过Log输出信息来判断： 123456789101112131415161718192021public class MyLayout extends RelativeLayout&#123; public MyLayout(Context context,AttributeSet attrs) &#123; super(context,attrs); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.d(&quot;TAG&quot;, ev.getAction()+&quot; action&quot;+&quot;MyLayout onInterceptTouchEvent&quot;); return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.d(&quot;TAG&quot;, event.getAction()+&quot; action&quot;+&quot;MyLayout onTouchEvent&quot;); return super.onTouchEvent(event); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;TAG&quot;, ev.getAction()+&quot; action&quot;+&quot;MyLayout dispatchTouchEvent&quot;); return super.dispatchTouchEvent(ev); &#125; 同理我们还需要重写一个Button： 123456789101112131415public class MyButton extends Button&#123; public MyButton(Context context,AttributeSet attrs)&#123; super(context,attrs); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.d(&quot;TAG&quot;, event.getAction()+&quot; action&quot;+&quot;MyButton onTouchEvent&quot;); return super.onTouchEvent(event); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;TAG&quot;, ev.getAction()+&quot; action&quot;+&quot;MyButton dispatchTouchEvent&quot;); return super.dispatchTouchEvent(ev); &#125; //这里注意View是没有onInterceptTouchEvent方法的 效果图是一样的这里就不再贴了，为了验证刚才的想法我们直接点击一下界面上的Button，Log输出如下： 发现了什么，我们点击的是Button,然而这个事件最开始是传到了我们的根布局MyLayout，并且还按照：dispatchTouchEvent、onInterceptTouchEvent、dispatchTouchEvent的顺序执行，紧接着执行View的onTouch()和onTouchEvent()方法，还有一点很奇怪的事只有最开始ACTION_DOWN的时候调用了ViewGroup的onInterceptTouchEvent方法，在后面的ACTION_UP事件派发过程中却没有调用，这里给出一个合理的猜想：一旦一个View开始处理这个触摸事件，那么接下来的ACTION_MOVE和ACTION_UP事件都会交给它去处理，就好比你在公司里面做事，分到你做的事你已经做了一些，那么接下来的事你的完完整整的做好，那么如果做到一半不做了会怎么样(即View不消耗ACTION_DOWN事件)？我们可以大胆的假设如果上级交给你做的事没有做好，那么上级_在短期内肯定不敢交代事情给你做了(后续的ACTION_MOVE、ACTION_DOWN事件这个View都接收不到了)，那么究竟如何我们还是从源码看起。 对源码的分析我们已经知道当一个点击操作发生时事件是先传给ViewGroup处理的并且首先执行的是ViewGroup的dispatchTouchEvent,那么我们就先来看看它的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218/** * &#123;@inheritDoc&#125; */ @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 相当长，还是一点点来看，源码这种东西看不懂肯定会觉得很枯燥，所以能弄懂的尽量弄懂，最开始只是一些对View是否可以获得焦点的判断、设置标志位以及初始化一些布尔值，并且在ACTION_DOWN事件产生的时候清楚以外的状态并且准备开始新一轮的手势操作，不重要： 1234567891011121314151617181920212223if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; 先看这一段： 12345678910111213141516// Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 这里首先设立了一个布尔值interception去判断当前ViewGroup是否要拦截View的点击事件，if条件语句中的内容是当产生ACTION_DOWN按下事件或者mFirstTouchTarget != null的时候去判断是否要拦截当前事件，这里主要关注mFirstTouchTarget != null这个点，我们找一找哪个方法跟这个mFirstTouchTarget变量有关，还真给我找到了，看下面：1234567891011private void clearTouchTargets() &#123; TouchTarget target = mFirstTouchTarget; if (target != null) &#123; do &#123; TouchTarget next = target.next; target.recycle(); target = next; &#125; while (target != null); mFirstTouchTarget = null; &#125; &#125; 12345678910111213141516171819202122232425/** * Cancels and clears all touch targets. */ private void cancelAndClearTouchTargets(MotionEvent event) &#123; if (mFirstTouchTarget != null) &#123; boolean syntheticEvent = false; if (event == null) &#123; final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; &#125; for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; resetCancelNextUpFlag(target.child); dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); &#125; clearTouchTargets(); if (syntheticEvent) &#123; event.recycle(); &#125; &#125; &#125; 这两段代码结合起来，在加上在ACTION_DOWN初始时候是调用了cancelAndClearTouchTargets(MotionEvent event)这个方法的，所以我们可以推荐起初这个mFirstTouchTarget 的值是null的，那么mFirstTouchTarget是在哪里赋值的呢，我们在dispatchTouchEvent(MotionEvent ev)接着往下看： 1newTouchTarget = addTouchTarget(child, idBitsToAssign); 我们看到newTouchTarget是在这里赋值的，看一下addTouchTarget方法： 12345678910/** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */ private TouchTarget addTouchTarget(View child, int pointerIdBits) &#123; TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; &#125; 从该方法的内部结构可以看出，mFirstTouchTarget其实是一中单链表结构，如果找到了处理该点击事件的子View那么mFirstTouchTarget就会被赋值并且会指向子元素。这一下弄清楚了回到刚才的那段代码： 123456789101112131415final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 1final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; 这个布尔值是判断子元素是否调用了requestDisallowInterceptTouchEvent这个方法，如果调用了这个布尔值就为True，这里看一眼这个方法的代码： 123456789101112131415161718192021/** * &#123;@inheritDoc&#125; */ public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123; // We&apos;re already in this state, assume our ancestors are too return; &#125; if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125; &#125; 你可以在子View中调用这个方法来让ViewGroup不拦截除了ACTION_DOWN以外的点击事件，这里为什么说是ACTION_DOWN以外呢，因为ViewGroup在分发事件的时候最开始是会重置FLAG_DISALLOW_INTERCEPT这个标志位的，所以无论你有没有在子View中设置requestDisallowInterceptTouchEvent方法都不会影响到ViewGroup去拦截ACTION_DOWN事件的，接着往下看： 1234567891011if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 如果子View没有设置requestDisallowInterceptTouchEvent方法那么就调用ViewGroup的onInterceptTouchEvent(ev)方法，我们找到这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Implement this method to intercept all touch screen motion events. This * allows you to watch events as they are dispatched to your children, and * take ownership of the current gesture at any point. * * &lt;p&gt;Using this function takes some care, as it has a fairly complicated * interaction with &#123;@link View#onTouchEvent(MotionEvent) * View.onTouchEvent(MotionEvent)&#125;, and using it requires implementing * that method as well as this one in the correct way. Events will be * received in the following order: * * &lt;ol&gt; * &lt;li&gt; You will receive the down event here. * &lt;li&gt; The down event will be handled either by a child of this view * group, or given to your own onTouchEvent() method to handle; this means * you should implement onTouchEvent() to return true, so you will * continue to see the rest of the gesture (instead of looking for * a parent view to handle it). Also, by returning true from * onTouchEvent(), you will not receive any following * events in onInterceptTouchEvent() and all touch processing must * happen in onTouchEvent() like normal. * &lt;li&gt; For as long as you return false from this function, each following * event (up to and including the final up) will be delivered first here * and then to the target&apos;s onTouchEvent(). * &lt;li&gt; If you return true from here, you will not receive any * following events: the target view will receive the same event but * with the action &#123;@link MotionEvent#ACTION_CANCEL&#125;, and all further * events will be delivered to your onTouchEvent() method and no longer * appear here. * &lt;/ol&gt; * * @param ev The motion event being dispatched down the hierarchy. * @return Return true to steal motion events from the children and have * them dispatched to this ViewGroup through onTouchEvent(). * The current target will receive an ACTION_CANCEL event, and no further * messages will be delivered here. */ public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; 唔，注释相当长，但是有用的就一个返回值，这里返回False，说明ViewGrup不拦截点击事件，事件可以继续往下传递，这个方法的最后，如果当前界面除了一个ViewGroup没有任何子View，那么此时ViewGroup也会拦截点击事件，就好比一个公司人手不够，公司领导需要亲力亲为一样。接着： 12345// If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; 如果确定拦截或者已经有子View着手处理这个点击事件，那么就开始正常的事件分发流程。 12final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; 这里是通过标志位和ACTION_CANCLE来检查是否cancle，再下去： 1final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; 首先可以看见获取一个boolean变量标记split来标记，默认是true，作用是是否把事件分发给多个子View，这个同样在ViewGroup中提供了public的方法设置，如下： 12345678910public void setMotionEventSplittingEnabled(boolean split) &#123; // TODO Applications really shouldn&apos;t change this setting mid-touch event, // but perhaps this should handle that case and send ACTION_CANCELs to any child views // with gestures in progress when this is changed. if (split) &#123; mGroupFlags |= FLAG_SPLIT_MOTION_EVENTS; &#125; else &#123; mGroupFlags &amp;= ~FLAG_SPLIT_MOTION_EVENTS; &#125; &#125; 这一段摘自：Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇) 1if (!canceled &amp;&amp; !intercepted) &#123; 如果没有取消当前动作并且ViewGroup未拦截事件那么事件就传递到接收了该点击事件的View，接下来是一大段代码预警： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; 嗯，这段代码的逻辑比较清晰，大体上就是遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件，接收的依据有两种：第一种是判断子元素是否在播放动画，第二种是判断点击事件的坐标是否落在子元素的区域内，从这里可以看出来： 12345678910111213if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; 如果子元素满足了这两个条件，点击事件就会交给它处理，接下来这段代码里面有一个很重要的方法： 1234567891011121314151617181920if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; 这里if判断里面这个dispatchTransformedTouchEvent是将Touch事件传递给特定的子View，它实际上在内部是调用了子元素的disPatchTouchEvent方法，找一下它的源码： 1234567891011121314151617181920212223242526272829303132/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don&apos;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; 看这一段内容： 12345if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; 如果传递的child为null就调用父类的dispatchTouchEvent否则就调用子类的dispatchTouchEvent，而上面的代码中child不为null，所以执行子元素的dispatchTouchEvent，如果子元素的dispatchTouchEvent返回的是True，那么含有dispatchTransformedTouchEvent这个方法内部的for循环就不会继续下去，直接跳到这里： 12345mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; 这个地方前面说过是给mFirstTouchTarget赋值的地方，如果情况改变，前面那个dispatchTransformedTouchEvent方法中child返回的是False，那么如果当前ViewGroup会把点击事件传递给下一个子元素进行处理，执行for循环查找下一个子元素，此时mFirstTouchTarget依然未被赋值为null，那么这时候继续查看接下来的代码： 123456789if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; 这一段代码表示当前没有找到可以接收点击事件的View并且我们的mFirstTouchTarget!=null那么就把最开始的TouchTarget赋值给newTouchTarget，最后： 12345// Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); 执行到这里的话有两种情况，一种是ViewGroup里面没有找到子View，另一种就是找到了处理这次点击事件的子View但是这个子View的disPatchTouchEvent返回了False，我们通过前面的分析知道disPatchTouchEvent中是先执行onTouch()方法的，而一般onTouch()方法返回的是False，此时disPatchTouchEvent方法的返回值由onTouchEvent方法决定，出现这种情况说明onTouchEvent返回了False，在以上两种情况下，ViewGroup会自己处理这个点击事件，注意这里这个方法里的child传入的是null，我们前面就知道了传入null会执行handled = super.dispatchTouchEvent(event);也就是说此时交由ViewGroup处理这个事件。而ViewGroup也是View的子类，它里面是没有重写View的onTouchEvent方法的，所以它自身处理点击事件的流程和我们在View的事件分发机制解析里面分析得是一样的，至此ViewGroup的分发事件分析完毕。 总结这次我们只分析了点击Button时的Log输出，下面给出点击空白处的Log输出，可以自己检验一下分析成果： 一些结论 ViewGroup默认不拦截任何事件，Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false View的onTouchEvent默认都会消耗事件(返回true)，除非是不可点击的(clickable和longClicjable同时为false)，View的longClickable属性默认是false的 View的enable属性不会影响onTouchEvent的返回值，哪怕该View为disable的，只要它的clickable和longClickable其中一个为true，那么它的onTouchEvent就返回true 事件传递过程是由外向内的，即事件总是先传给父元素，然后再由父元素分发给子VIew,子View可以通过requestDisallowInterceptTouchEvent来干预父元素的分发过程，但是影响不到ACTION_DOWN事件 参考：Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇) Android事件分发机制完全解析，带你从源码的角度彻底理解(下)","tags":[{"name":"事件分发","slug":"事件分发","permalink":"https://www.limuyang.cc/tags/事件分发/"},{"name":"回调","slug":"回调","permalink":"https://www.limuyang.cc/tags/回调/"},{"name":"ViewGroup","slug":"ViewGroup","permalink":"https://www.limuyang.cc/tags/ViewGroup/"}]},{"title":"View的事件分发机制解析","date":"2016-04-03T22:41:55.000Z","path":"2016/04/03/View的事件分发机制解析/","text":"引言 Android事件构成在Android中，事件主要包括点按、长按、拖拽、滑动等，点按又包括单击和双击，另外还包括单指操作和多指操作。所有这些都构成了Android中的事件响应。总的来说，所有的事件都由如下三个部分作为基础： 按下(ACTION_DOWN) 移动(ACTION_MOVE) 抬起(ACTION_UP) 所有的操作事件首先必须执行的是按下操作（ACTION_DOWN），之后所有的操作都是以按下操作作为前提，当按下操作完成后，接下来可能是一段移动（ACTION_MOVE）然后抬起（ACTION_UP），或者是按下操作执行完成后没有移动就直接抬起。这一系列的动作在Android中都可以进行控制。 这些操作事件都发生在我们手机的触摸屏上面，而我们手机上响应我们各种操作事件的就是各种各样的视图组件也就是View，在Android中，所有的视图都继承于View，另外通过各种布局组件（ViewGroup）来对View进行布局，ViewGroup也继承于View。所有的UI控件例如Button、TextView都是继承于View，而所有的布局控件例如RelativeLayout、容器控件例如ListView都是继承于ViewGroup。所以，我们的事件操作主要就是发生在View和ViewGroup之间。 事件分发的概念所谓点击事件的事件分发，就是当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View(ViewGroup也继承于View),这个传递的过程就叫做分发过程，这个点击事件的分发过程需要三个很重要的方法来共同完成：disPatchTouchEvent、onInterceptTouchEvent、和onTouchEvent。 public boolean disPatchTouchEvent(MotionEvent ev) 用来进行事件的分发，如果事件能够传递给当前的View,那么此方法一定会被调用，Android中所有的点击事件都必须经过这个方法的分发，然后决定是自身消费当前事件还是继续往下分发给子控件处理。返回true表示不继续分发，事件已被消费,返回false则继续往下分发，如果是ViewGroup则分发给onInterceptTouchEvent进行判断是否拦截该事件，这个方法的返回结果受到当前View的onTouchEvent和下级View的disPatchTouchEvent方法的影响，返回结果表示是否消耗当前事件。 public boolean onTouchEvent(MotionEvent ev) 在diaPatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列当中，当前View无法再次接收到事件。 public boolean onInterceptTouchEvent(MotionEvent ev) 是ViewGroup中才有的方法，View中没有，它的作用是负责事件的拦截，返回true的时候表示拦截当前事件，不继续往下分发，交给自身的onTouchEvent进行处理。返回false则不拦截，继续往下传。这是ViewGroup特有的方法，因为ViewGroup中可能还有子View，而在Android中View中是不能再包含子View的(IOS可以)，在上述方法内部被调用，如果当前View拦截了某个事件，那么同一个事件序列中(指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，中间含有不定的ACTION_MOVE事件，最终以ACTION_UP事件结束)此方法不会被再次调用，返回结果表示是否拦截当前事件。 这三个方法可以用如下伪代码表示： 123456789101112public boolean disPathchTouchEvent(MotionEvent ev)&#123;//consume指代点击事件是否被消耗 boolean consume=false; //表示当前父布局要拦截该事件 if(onInterceptTouchEvent(MotionEvent ev))&#123; consume=onTouchEvent(ev); &#125;else&#123; //传递给子元素去处理 child.disPatchTouchEvent(ev); &#125; return consume;&#125; 分析View的事件分发机制 为了简单起见我们先从View的事件分发机制开始分析，然后在分析ViewGroup的，首先我们建一个简单的项目，这个项目里只有一个Button，并且我们给这个Button设置点击事件： 12345678910111213141516&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;Button android:id=\"@+id/btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"100dp\" android:text=\"Click me\" /&gt;&lt;/RelativeLayout&gt; 123456789101112131415161718192021222324252627282930313233343536package com.example.testbtn;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.MotionEvent;import android.view.View;import android.view.View.OnClickListener;import android.view.View.OnTouchListener;import android.widget.Button;public class MainActivity extends Activity implements OnClickListener,OnTouchListener&#123; private Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn=(Button) findViewById(R.id.btn); btn.setOnClickListener(this); btn.setOnTouchListener(this); &#125; @Override public void onClick(View v) &#123; Log.d(\"TAG\", \"OnClick\"); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(\"TAG\", \"onTouch\"+event.getAction()); return false; &#125;&#125; 界面是这样的： 运行这个程序，点击Button，查看Log打印输出的信息： (这里onTouch0代表的是ACTION_DOWN，onTouch1代表的是ACTION_UP，onTouch2表示ACTION_MOVE，因为我们只是稳稳的点击了一下Button所以不会有ACTION_MOVE的Log信息出现) 这样我们可以得到一个初步的结论：onTouch()方法是优先于onClick()执行的，然后我们会发现onTouch()方法有一个很明显的和onClick()方法不同的地方的，那就是它有一个Boolean类型的返回值，如果我们把这个默认为False的返回值改为True会怎么样呢： 发现了什么：onClick()方法没有被执行，这里我们把这种现象叫做点击事件被onTouch()消费掉了，事件不会在继续向onClick()方法传递了，那么事件分发机制最基本的几条我们已经了解了，下面我们来分析产生这种机制的根本原因。 View对点击事件的处理过程首先我们给出一个结论：Android中所有的事件都必须经过disPatchTouchEvent(MotionEvent ev)这个方法的分发，然后决定是自身消费当前事件还是继续往下分发给子控件处理，那么我们就来看看这个disPatchTouchEvent(MotionEvent ev)到底干了什么。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 代码有点多，我们一步步来看： 123456789// If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; 最前面这一段就是判断当前事件是否能获得焦点，如果不能获得焦点或者不存在一个View那我们就直接返回False跳出循环，接下来： 123456789if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; 设置一些标记和处理input与手势等传递，不用管，到这里： 12345678910111213if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; 这里if (onFilterTouchEventForSecurity(event))是用来判断View是否被遮住等，ListenerInfo是View的静态内部类，专门用来定义一些XXXListener等方法的，到了重点： 12345if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; 很长的一个判断，一个个来解释：第一个li肯定不为空，因为在这个If判断语句之前就new了一个li，第二个条件li.mOnTouchListener != null，怎么确定这个mOnTouchListener不为空呢？我们在View类里面发现了如下方法： 1234567/** * Register a callback to be invoked when a touch event is sent to this view. * @param l the touch listener to attach to this view */ public void setOnTouchListener(OnTouchListener l) &#123; getListenerInfo().mOnTouchListener = l; &#125; 意味着只要给控件注册了onTouch事件这个mOnTouchListener就一定会被赋值,接下来(mViewFlags &amp; ENABLED_MASK) == ENABLED是通过位与运算来判断这个View是否是ENABLED的，我们默认控件都是ENABLED的所以这一条也成立，最后一条li.mOnTouchListener.onTouch(this, event)是判断onTouch()的返回值是否为True，我们后面把默认为False的返回值改成了True，所以这一整系列的判断都是True，那么这个disPatchTouchEvent(MotionEvent ev)方法直接就返回了True,那么接下来的代码都不会被执行，我们下面有这么一段代码： 123if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; 最开始我们onTouch()方法的返回值是False的，那么 12345if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; 这里面的判断就不成立，result最开始的默认值也是false，那么此时如果 1onTouchEvent(event) 返回值也是True，那么if (!result &amp;&amp; onTouchEvent(event))这个方法判断条件成立，disPatchTouchEvent(MotionEvent ev)返回True，否则返回False。 这里我们得到两个结论： OnTouchListener的优先级比onTouchEvent要高，联想到刚才的小Demo也可以得出onTouch方法优先于onClick()方法执行(onClick()是在onTouchEvent(event)方法中被执行的这个待会会说到) 如果控件（View）的onTouch返回False或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是ENABLE的情况下会调用onTouchEvent方法，此时dispatchTouchEvent方法的返回值与onTouchEvent的返回值一样。 那么接下来我们就分析dispatchTouchEvent方法里面onTouchEvent的实现,给出onTouchEvent的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 代码还是很多，我们依然一段一段来分析，最前面的一段代码： 12345678910if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; 根据前面的分析我们知道这一段代码是对当前View处于不可用状态的情况下的分析，通过注释我们知道即使是一个不可用状态下的View依然会消耗点击事件，只是不会对这个点击事件作出响应罢了，另外通过观察这个return返回值，只要这个View的CLICKABLE和LONG_CLICKABLE或者CONTEXT_CLICKABLE有一个为True，那么返回值就是True，onTouchEvent方法会消耗当前事件。 看下一段代码： 12345if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; 这段代码的意思是如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent(event)方法，这个onTouchEvent(event)的工作机制看起来和OnTouchListener类似，这里不深入研究。 –《Android开发艺术探索》 下面看一下onTouchEvent中对点击事件的具体处理流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 我们还是一行行来分解： 12345678if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; //省略 &#125; return false; &#125; 这个判断之前描述过不再赘述，如果这个判断不成立直接跳到方法尾部返回False，如果判断成立则继续进入方法内部进行一个switch(event)的判断，这里ACTION_DOWN和ACTION_MOVE都只是进行一些必要的设置与置位，我们主要看ACTION_UP： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; 首先判断了是否被按下 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;接下来判断是不是可以获得焦点，同时尝试去获取焦点： 1234boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; 经过种种判断后我们看到这一行： 123if (!post(mPerformClick)) &#123; performClick(); &#125; 这是判断如果不是longPressed则通过post在UI Thread中执行一个PerformClick的Runnable，也就是performClick方法，这个方法的源码如下： 12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; &#125; 我们发现了什么，那就是当ACTION_UP事件发生时，会触发performClick()方法，如果这个View设置了OnClickListener那么最终会执行到OnClickListener的回调方法onClick(),这也就验证了刚才所说的：onClick()方法是在onTouchEvent内部被调用的。 同我们前面找到mOnTouchListener在哪里赋值的一样，我们也可以找到mOnClickListener在哪里赋值的： 1234567891011121314/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; 我们知道View的LONG_CLICKABLE属性默认是False的，需要的话我们可以自己在xml或者java文件中去设置，但是CLICKABLE的False与True是和具体的View有关的，比如我们知道Button是可点击的，但是TextView默认是不可点击的，但是如果给TextView设置了点击事件，那么根据 123if (!isClickable()) &#123; setClickable(true); &#125; 这几行代码TextView也会被设置为可点击的，同理还有setOnLongClickListener也有这种作用： 1234567891011121314/** * Register a callback to be invoked when this view is clicked and held. If this view is not * long clickable, it becomes long clickable. * * @param l The callback that will run * * @see #setLongClickable(boolean) */ public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l; &#125; 总结到此，View的事件分发机制已经分析完了，整个过程查了许多资料，最主要的是跟着任玉刚老师的《Android开发艺术探索》学习，最后把这个学习的过程记录下来就是这篇博客了，等有时间的时候把ViewGroup的事件分发机制也分析一遍。 主要参考 Android触摸屏事件派发机制详解与源码分析一(View篇) Android事件传递机制 请看后续 ViewGroup的事件分发机制","tags":[{"name":"事件分发","slug":"事件分发","permalink":"https://www.limuyang.cc/tags/事件分发/"},{"name":"回调","slug":"回调","permalink":"https://www.limuyang.cc/tags/回调/"}]},{"title":"回调函数机制","date":"2016-04-01T23:12:01.000Z","path":"2016/04/01/回调函数机制/","text":"引言 在Android的学习过程中经常会听到或者见到“回调”这个词，那么什么是回调呢？所谓的回调函数就是：在A类中定义了一个方法，这个方法中用到了一个接口和该接口中的抽象方法，但是抽象方法没有具体的实现，需要B类去实现，B类实现该方法后，它本身不会去调用该方法，而是传递给A类，供A类去调用，这种机制就称为回调。 这么说可能还是有些模模糊糊，接下来我们用类比的方法一步步来看到底该怎么写一个回调函数，因为android回调中最常见的是Button的点击事件的回调，这里以此为参照： 1、在A类中定义一个接口：需要我们在类中定义出一个接口，并且给这个接口定义出一个抽象方法，就像下面这样： 123public interface CallBack&#123; public abstract void work() &#125; 以下是View.java类中定义的响应点击事件的接口： 1234567891011/** * Interface definition for a callback to be invoked when a view is clicked. */ public interface OnClickListener &#123; /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); &#125; 2、在A类中定义出该接口的一个成员变量： 1public CallBack mCallBack 以下是View.java类中获取点击事件接口成员变量的源码：123456/** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ public OnClickListener mOnClickListener; 3、在A类中定义出一个公共方法，可以用来设置这个接口的对象，调用该方法可以给接口对象变量赋值： 123public void setCallBack(CallBack callBack) &#123; this.mCallBack = callBack; &#125; 这里看英文注释也看得出来是什么意思，是不是想到了我们平常使用setOnClickListener(OnClickListener l)的时候呢:1234567891011121314/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; 最后一步，如果说前面的都没问题，但这一步可能更不好理解了，不过没关系，我们先看一下 4、在A类中调用接口对象中的方法： 123public void doWork()&#123; mCallBack.work();&#125; 在View.java中的体现： 123456789101112131415161718/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this);//就是这里 result = true; &#125; else &#123; result = false; &#125; 这里附上整个项目的代码，这里A类映射到实际中使用Employee 这个类来代表： 123456789101112131415161718192021222324public class Employee &#123; /* * 定义回调接口的成员变量 */ private CallBack mCallBack; /* * 声明回调接口 */ public interface CallBack&#123; public abstract void work(); &#125; /* * 设置回调接口对象成员变量 */ public void setCallBack(CallBack callBack) &#123; this.mCallBack = callBack; &#125; /* * 调用回调接口对象中的方法 */ public void doWork() &#123; mCallback.work(); &#125; &#125; 我们在定义出一个B类，就用Boss类吧： 123456789101112public class Boss &#123; private Employee employee; /* * 为Employee设置回调函数, 在这里定义具体的回调方法 */ employee.setCallback(new Employee.Callback() &#123; @Override public void work() &#123; System.out.println(\"work\"); &#125; &#125;); &#125; 如果第一眼看不明白，我们附上我们最常用的Button点击事件的处理的代码，这里Employee 类类比一下就是View类： 123456789101112public class TestCallBack&#123; private Button button; button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //做一些操作 doWork(); &#125; &#125;); &#125; 这时候我们在再回头关于回调的定义： 在A类中定义了一个方法，这个方法中用到了一个接口和该接口中的抽象方法，但是抽象方法没有具体的实现，需要B类去实现，B类实现该方法后，它本身不会去调用该方法，而是传递给A类，供A类去调用 这里回到我们的代码中就是：我们在Employee(View)类中定义了一个接口，接口当中还含有一个抽象方法，这个抽象方法没有具体的实现，当我们需要时候自己去实现这个方法，比如这里的Boss (Button)类，这句话可能难以理解：B类实现该方法后，它本身不会去调用该方法，而是传递给A类，供A类去调用，有些人会想，诶，在onClick()方法中我不是写了具体的实现嘛，其实真的是这样吗，我们接着往下看，我们就来好好的分析一下这个Button点击事件。分析首先，在View类中我们能找到setOnClickListener(OnClickListener l)方法： 123456public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; 这里将OnClickListener赋值给了mOnClickListener，我们想要找到onClick()方法是由View回调而不是Button自己回调的证据，就在这里： 12345678910public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); return true; &#125; return false; &#125; 对此我们的解释是：在父类中我们要用到onClick()方法，但是父类却没有去实现该方法，而是定义了一个方法setOnClickListener(OnClickListener l)，如果子类想要自己能够响应点击事件，则它就必须重写父类的该方法，实现OnClickListener接口和它的onClick()方法。在子类实现该接口和方法后，将其通过参数传递给父类，在父类中执行onClick()方法。那么我们是如何运行到这个OnClick()函数的呢，这里由于涉及到View的事件分发机制不细说，想了解的话网上有很多资料，这里只给出结论，因为我们在TestCallBack这个类中没有实现OnTouchListener这个接口，那么当点击事件发的时候必然会运行到onTouchEvent()这个方法，我们来看一下这个方法： 12345678910111213141516171819202122232425262728293031public boolean onTouchEvent(MotionEvent event) &#123; // 略去无用代码... if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: // 略去无用代码... if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); //重点在这 &#125; &#125; &#125; //略去无用代码.. break; &#125; return true; &#125; return false; &#125; 还记得前面我们在performClick();类里面找到的关于View.java类中对于回调方法onClick的调用么 1li.mOnClickListener.onClick(this);//就是这里 这样我们就完整的了解了整个OnClickListener()接口中体现出来的回调机制总结一下为了实现一个回调方法，首先要先定义一个包含了接口的类，并且这个接口中要有一个抽象方法，这个抽象方法的具体实现由其他类来完成(比如我们响应Button的点击事件，onClick()方法里写上当点击事件产生并且该方法被调用时候需要做的操作，比如显示一些文本信息等等)，最后该方法的回调是之前的包含有抽象方法的那个接口所在的类去调用的，比如说onClick()方法是当点击事件产生之后经过一系列的事件分发在View类中被调用的。这其中的奥秘就是： 回调其实是一种双向调用模式，也就说调用方在接口被调用时也会调用对方的接口，实现方法交还给提供接口的父类处理！ 为什么要用回调 我们都知道Java是一门面向对象的语言，有一句很著名的话就是”万事万物皆为对象”，我们把普通事物的共性抽取出来，而这些共性之中又充斥着特性，每个不同的特性就需要交给特定的情况处理，通过暴露接口方法可以减少很多重复，代码更加优雅。 打个比方，Button、ImageButton等都具有可被点击的共性，但是被点击之后相关事件的处理是不同的，比如说我想我要点击的这个Button弹出一个消息提示，然而我希望我的ImageButton点击之后可以弹出一个Notifaction通知，这个时候回调方法的好处就体现出来了，因为android对外暴露的OnClickListener()接口中含有一个OnClick()方法，你需要怎样的具体实现都由你自己定义，而这个回调方法的所在类View不会管你怎么实现的，它只负责调用这个回调方法，这就是使用回调的好处。主要参考 android中的回调Android中回调函数机制解析","tags":[{"name":"回调","slug":"回调","permalink":"https://www.limuyang.cc/tags/回调/"},{"name":"分析","slug":"分析","permalink":"https://www.limuyang.cc/tags/分析/"}]},{"title":"APP启动页的正确配置方式","date":"2016-03-01T20:23:31.000Z","path":"2016/03/01/APP启动页的正确配置方式/","text":"在APP的启动页面(Splash Screen)好多都是等待3秒，好一点的还可以跳过，但是有的跳过也是假的按钮。当然像一些大厂的APP，像网易新闻等启动页面都是广告，人家要收广告费的。但是，对于一些普通的APP，有的也出现等待三秒的启动画面，出现一个大大的logo,好像告诉用户他打开的是什么应用，加深用户的映像，这完全是浪费用户的时间，给用户很差的体验！其实我只想快点进入APP啊！！！而且有些APP启动时候都会出现一个短暂的空白界面，现在我们就来避免这些已知的问题。 你看到在这个APP的启动页面所花费的时间正是APP所初始化配置自己的时间，第一次启动也是这样的，所以第一次是最慢的，但是如果有缓存了，那么每次再打开应该是立即打开了吧 实现一个启动页面(Splash Screen) 实现一个启动页面可能和你想象的有点不一样。这个启动的页面必须是立即准备好的页面，即使是在Activity中加载一个xml页面也要是立刻加载好的。 所以，一般不会用layout来当启动页面。取而代之的是用一个颜色作为你的Activity的主题背景，接下来，在你的res/drawable文件夹下创建一个XML的drawable。 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@color/gray\"/&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 这里，我设置了背景颜色和一张居中的图片。 然后，在主题中，将这个设置为Activity的背景。打开你的styles.xml然后为你的Activity添加一个新的主题。 12345678910 &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt; &lt;style name=\"SplashTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/background_splash&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在你新的SplashTheme中，设置窗口背景属性为我们之前写的XML的drawable，就是layer-list的xml。然后在你的AndroidManifest.xml中配置一下就好了。 123456789&lt;activity android:name=\".SplashActivity\" android:theme=\"@style/SplashTheme\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 最后，在你的SplashActivity.class文件中，编码直接进入主页面就行了。 1234567891011public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = new Intent(this, MainActivity.class); startActivity(intent); finish(); &#125;&#125; 这里发现你并没有为Activity设置layout视图，视图来自于主题！所以，这应该是最快的方法启动页面了（相比较加载layout视图）。如果你一定要通过加载layout来显示页面，可能你初始化完了才跳出页面，这时已经有点迟了，所以，你应该考虑用极短的时间来显示加载layout视图. 正确的打开它 当你完成这些步骤，你就正确的完成了启动页面。","tags":[{"name":"冷热启动","slug":"冷热启动","permalink":"https://www.limuyang.cc/tags/冷热启动/"},{"name":"app","slug":"app","permalink":"https://www.limuyang.cc/tags/app/"}]},{"title":"AsyncTask初步解析","date":"2015-12-18T20:26:43.000Z","path":"2015/12/18/AsyncTask初步解析/","text":"AsyncTask – 直接继承与Object类 在API-3中开始就被定义 一、AsyncTask初步介绍 在Android程序开始运行的时候会单独启动一个进程，默认情况下所有这个程序操作都在这个进程中进行。一个Android程序默认情况下只有一个进程，但是一个进程却是可以有许线程的。 在这些线程中，有一个线程叫做UI线程，也叫做Main Thread，除了Main Thread之外的线程都可称为Worker Thread。Main Thread主要负责控制UI页面的显示、更新、交互等。 因此所有在UI线程中的操作要求越短越好，只有这样用户才会觉得操作比较流畅。一个比较好的做法是把一些比较耗时的操作，例如网络请求、数据库操作、 复杂计算等逻辑都封装到单独的线程，这样就可以避免阻塞主线程，这个时候就用到了异步任务类AsyncTask。 AsyncTask 是一个综合Thread 和 Handler的辅助类，并不是通用线程框架的一部分。AsyncTask 是短期后台操作的理想选择（最多几秒钟），如果你需要线程长时间的保持运行，强烈建议你使用 java.util.concurrent 包提供的各种API以满足你的需求，比如：Executor, ThreadPoolExecutor and FutureTask.这里我们只讨论AsyncTask的初步使用。 二、AsyncTask的内部机制 首先我们来看一下AsyncTask的方法定义： 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; 我们可以很明显的看到这里有三个泛型参数，当我们要利用AsyncTask类的时候必须传入如下三个参数： Parms：启动该异步任务的时候传入的参数类型 Progress：当异步任务在后台执行时返回的进度单位，也可以简单的理解为后台任务执行的进度 Result：后台任务执行结束时返回的结果类型Android Developer还告知我们：在某些情况有些泛型不需要被指定，这时我们为了简便可以传入一个空类型的参数： 1private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; ... &#125; 接下来，为了执行一个异步任务我们还需要执行如下几个步骤： onPreExecute()：在UI线程中被执行，通常是用来做任务执行前的准备工作，例如加载一个进度条或者在UI界面上显示一个文本等 doInBackground(Params…)：在onPreExecute()方法完成之后立即被后台进程调用，用于执行一些耗时操作，启动异步任务时执行的Parms参数也会被传递到该方法，在这一方法中我们可以使用publishProgress(Progress…)方法来更新进度信息，并且在该方法内不可以更新UI信息 onProgressUpdate(Progress…)：在UI线程中执行，如果我们在doInBackground(Params…)方法中使用了publishProgress(Progress…)那么进度信息将可以以进度条或者Log的形式显示在UI组件上 onPostExecute(Result)：在UI线程中执行，当后台任务操作结束之后该方法会被执行，doInBackground(Params…)方法计算得到的结果将作为该方法的输入参数来进行一些UI更新的操作 取消AsyncTask任务操作 我们可以在异步任务执行的任何时候通过调用cancel(boolean )方法来取消；我们在cancel(boolean)方法中传入true参数则表明取消正在执行的任务，如果调用成功，那么之后我们使用isCancelled()方法来判断任务是否被取消的时候都会返回true，取消之后在执行完doInBackground(Object[])后onCancelled(Object)方法会代替onPostExecute(Object)方法被执行。为了确保能够尽快的取消一个任务，我们应该在doInBackground(Object[])里面周期性的检查isCancelled()的返回值(例如在一个循环里面) 注意事项 AsyncTask 类必须在UI主线程中被加载,从Android4.1开始系统上已经帮我们自动完成这一点 AsyncTask类的实例必须在UI线程中进行创建 execute(Params…) 必须在UI主线程中被调用 不要手动的去调用 onPreExecute(), onPostExecute(Result), doInBackground(Params…), onProgressUpdate(Progress…)这些方法 任务只能被执行一次(如果执行第二次则抛出一个异常) 三、AsyncTask的使用 下面给出一个关于AsyncTask的使用的Demo，布局只有两个Button、一个TextView和一个ProgressBar，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ProgressBar android:id=\"@+id/progressBar\" android:layout_width=\"match_parent\" android:layout_height=\"25dp\" android:layout_centerInParent=\"true\" android:layout_margin=\"5dip\" android:layout_marginTop=\"60dp\" android:background=\"@drawable/btn_style\" android:indeterminate=\"false\" android:indeterminateOnly=\"false\" android:max=\"100\" android:progress=\"0\" android:progressDrawable=\"@drawable/bakground_progress\" /&gt; &lt;Button android:id=\"@+id/Cancle\" android:layout_width=\"100dp\" android:layout_height=\"wrap_content\" android:layout_alignRight=\"@+id/progressBar\" android:layout_below=\"@+id/progressBar\" android:layout_marginRight=\"24dp\" android:background=\"@drawable/btn_style\" android:text=\"Cancle\" android:textColor=\"#ffffff\" android:textStyle=\"bold\" /&gt; &lt;Button android:id=\"@+id/Execute\" android:layout_width=\"100dp\" android:layout_height=\"wrap_content\" android:layout_alignLeft=\"@+id/progressBar\" android:layout_below=\"@+id/progressBar\" android:layout_marginLeft=\"42dp\" android:background=\"@drawable/btn_style\" android:text=\"Excuse\" android:textColor=\"#ffffff\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/tv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/progressBar\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"31dp\" android:text=\"AsyncTask测试\" android:textSize=\"20sp\" android:textColor=\"#000000\" android:textStyle=\"bold\" /&gt;&lt;/RelativeLayout&gt; 结构相对简单，接下里让我们看看TestAsyncTask.java的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.example.testasynctask;import android.app.Activity;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ProgressBar;import android.widget.TextView;import android.widget.Toast;public class TestAsyncTask extends Activity &#123; private Button execute, cancle; private ProgressBar progressBar; private TextView tv; private TestAsyncTaskProgressBar testAsyncTaskProgressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); execute = (Button) findViewById(R.id.Execute); tv = (TextView) findViewById(R.id.tv); progressBar = (ProgressBar) findViewById(R.id.progressBar); execute.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /** * 这里注意新建的任务只能执行一次，否则会出现异常 */ testAsyncTaskProgressBar = new TestAsyncTaskProgressBar(); testAsyncTaskProgressBar.execute(); execute.setEnabled(false); cancle.setEnabled(true); &#125; &#125;); cancle = (Button) findViewById(R.id.Cancle); cancle.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /** * 使用该方法可以尝试取消正在执行的任务 */ testAsyncTaskProgressBar.cancel(true); &#125; &#125;); &#125; /** * 要使用AsyncTask必须创建它的子类，并且该子类至少需要覆盖doInBackground(Params...)方法 */ class TestAsyncTaskProgressBar extends AsyncTask&lt;Void, Integer, Void&gt; &#123; /** * 当onPreExecute()方法结束执行时该方法立即在后台执行，用于进行一些耗时的操作，并且在执行后台操作的同时 * 还可以通过publishProgress * (Progress...)将执行进度实时传送到UI线程，利用onProgressUpdate(Progress...)方法 * 可以进行动态展示，而且在该方法内不允许修改UI */ @Override protected Void doInBackground(Void... params) &#123; while (!isCancelled() &amp;&amp; progressBar.getProgress() &lt; 100) &#123; publishProgress(new Integer(5)); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; /** * 该方法在UI线程中被执行，主要用在执行后台操作之前做一些UI操作譬如显示一个进度条 */ @Override protected void onPreExecute() &#123; super.onPreExecute(); tv.setText(\"开始执行\"); &#125; /** * 后台任务执行完毕之后该方法立即执行，后台任务执行结果的参数会被传递到该方法中 */ @Override protected void onPostExecute(Void result) &#123; super.onPostExecute(result); tv.setText(\"执行完毕\"); &#125; /** * 当publishProgress(Progress...)方法被执行的时候被调用，并且接受传入第二个参数 */ @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); progressBar.setProgress(progressBar.getProgress() + values[0]); &#125; /** * cancel(boolean)方法被调用并且doInBackground(Object[])方法执行完毕时执行 */ @Override protected void onCancelled() &#123; super.onCancelled(); tv.setText(\"执行中断\"); progressBar.setProgress(0); execute.setEnabled(true); cancle.setEnabled(false); &#125; &#125;&#125; 总体执行效果如下：AsyncTask Demo源码 参考链接： http://blog.csdn.net/ahuier/article/details/16953793 http://blog.csdn.net/liuhe688/article/details/6532519","tags":[{"name":"异步IO","slug":"异步IO","permalink":"https://www.limuyang.cc/tags/异步IO/"},{"name":"AsyncTask","slug":"AsyncTask","permalink":"https://www.limuyang.cc/tags/AsyncTask/"}]}]